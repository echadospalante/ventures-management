
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model XUserPreferences
 * 
 */
export type XUserPreferences = $Result.DefaultSelection<Prisma.$XUserPreferencesPayload>
/**
 * Model UserDetail
 * 
 */
export type UserDetail = $Result.DefaultSelection<Prisma.$UserDetailPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Municipality
 * 
 */
export type Municipality = $Result.DefaultSelection<Prisma.$MunicipalityPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model EventCategory
 * 
 */
export type EventCategory = $Result.DefaultSelection<Prisma.$EventCategoryPayload>
/**
 * Model EventDonation
 * 
 */
export type EventDonation = $Result.DefaultSelection<Prisma.$EventDonationPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PublicationClap
 * 
 */
export type PublicationClap = $Result.DefaultSelection<Prisma.$PublicationClapPayload>
/**
 * Model PublicationContent
 * 
 */
export type PublicationContent = $Result.DefaultSelection<Prisma.$PublicationContentPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Venture
 * 
 */
export type Venture = $Result.DefaultSelection<Prisma.$VenturePayload>
/**
 * Model XVentureVencureCategory
 * 
 */
export type XVentureVencureCategory = $Result.DefaultSelection<Prisma.$XVentureVencureCategoryPayload>
/**
 * Model VentureCategory
 * 
 */
export type VentureCategory = $Result.DefaultSelection<Prisma.$VentureCategoryPayload>
/**
 * Model VentureDetail
 * 
 */
export type VentureDetail = $Result.DefaultSelection<Prisma.$VentureDetailPayload>
/**
 * Model VentureEvent
 * 
 */
export type VentureEvent = $Result.DefaultSelection<Prisma.$VentureEventPayload>
/**
 * Model VenturePublication
 * 
 */
export type VenturePublication = $Result.DefaultSelection<Prisma.$VenturePublicationPayload>
/**
 * Model VentureSponsorship
 * 
 */
export type VentureSponsorship = $Result.DefaultSelection<Prisma.$VentureSponsorshipPayload>
/**
 * Model VentureSubscription
 * 
 */
export type VentureSubscription = $Result.DefaultSelection<Prisma.$VentureSubscriptionPayload>
/**
 * Model XEventCategory
 * 
 */
export type XEventCategory = $Result.DefaultSelection<Prisma.$XEventCategoryPayload>
/**
 * Model XUserRoles
 * 
 */
export type XUserRoles = $Result.DefaultSelection<Prisma.$XUserRolesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  WELCOME: 'WELCOME',
  ACCOUNT_VERIFIED: 'ACCOUNT_VERIFIED',
  ACCOUNT_LOCKED: 'ACCOUNT_LOCKED',
  ACCOUNT_UNLOCKED: 'ACCOUNT_UNLOCKED',
  NEW_FOLLOWER: 'NEW_FOLLOWER',
  NEW_COMMENT: 'NEW_COMMENT',
  NEW_SPONSOR: 'NEW_SPONSOR',
  NEW_DONATION: 'NEW_DONATION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  READ: 'READ',
  UNREAD: 'UNREAD'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const ContentType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  ACHIEVEMENT: 'ACHIEVEMENT'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const AppRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  MODERATOR: 'MODERATOR',
  NEWS_WRITER: 'NEWS_WRITER'
};

export type AppRole = (typeof AppRole)[keyof typeof AppRole]


export const PublicationType: {
  TEXTUAL: 'TEXTUAL',
  VIDEO: 'VIDEO',
  IMAGE: 'IMAGE',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  ACHIEVEMENT: 'ACHIEVEMENT'
};

export type PublicationType = (typeof PublicationType)[keyof typeof PublicationType]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type AppRole = $Enums.AppRole

export const AppRole: typeof $Enums.AppRole

export type PublicationType = $Enums.PublicationType

export const PublicationType: typeof $Enums.PublicationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.xUserPreferences`: Exposes CRUD operations for the **XUserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XUserPreferences
    * const xUserPreferences = await prisma.xUserPreferences.findMany()
    * ```
    */
  get xUserPreferences(): Prisma.XUserPreferencesDelegate<ExtArgs>;

  /**
   * `prisma.userDetail`: Exposes CRUD operations for the **UserDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDetails
    * const userDetails = await prisma.userDetail.findMany()
    * ```
    */
  get userDetail(): Prisma.UserDetailDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.municipality`: Exposes CRUD operations for the **Municipality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipalities
    * const municipalities = await prisma.municipality.findMany()
    * ```
    */
  get municipality(): Prisma.MunicipalityDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.eventCategory`: Exposes CRUD operations for the **EventCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCategories
    * const eventCategories = await prisma.eventCategory.findMany()
    * ```
    */
  get eventCategory(): Prisma.EventCategoryDelegate<ExtArgs>;

  /**
   * `prisma.eventDonation`: Exposes CRUD operations for the **EventDonation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventDonations
    * const eventDonations = await prisma.eventDonation.findMany()
    * ```
    */
  get eventDonation(): Prisma.EventDonationDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.publicationClap`: Exposes CRUD operations for the **PublicationClap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicationClaps
    * const publicationClaps = await prisma.publicationClap.findMany()
    * ```
    */
  get publicationClap(): Prisma.PublicationClapDelegate<ExtArgs>;

  /**
   * `prisma.publicationContent`: Exposes CRUD operations for the **PublicationContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicationContents
    * const publicationContents = await prisma.publicationContent.findMany()
    * ```
    */
  get publicationContent(): Prisma.PublicationContentDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.venture`: Exposes CRUD operations for the **Venture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventures
    * const ventures = await prisma.venture.findMany()
    * ```
    */
  get venture(): Prisma.VentureDelegate<ExtArgs>;

  /**
   * `prisma.xVentureVencureCategory`: Exposes CRUD operations for the **XVentureVencureCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XVentureVencureCategories
    * const xVentureVencureCategories = await prisma.xVentureVencureCategory.findMany()
    * ```
    */
  get xVentureVencureCategory(): Prisma.XVentureVencureCategoryDelegate<ExtArgs>;

  /**
   * `prisma.ventureCategory`: Exposes CRUD operations for the **VentureCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VentureCategories
    * const ventureCategories = await prisma.ventureCategory.findMany()
    * ```
    */
  get ventureCategory(): Prisma.VentureCategoryDelegate<ExtArgs>;

  /**
   * `prisma.ventureDetail`: Exposes CRUD operations for the **VentureDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VentureDetails
    * const ventureDetails = await prisma.ventureDetail.findMany()
    * ```
    */
  get ventureDetail(): Prisma.VentureDetailDelegate<ExtArgs>;

  /**
   * `prisma.ventureEvent`: Exposes CRUD operations for the **VentureEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VentureEvents
    * const ventureEvents = await prisma.ventureEvent.findMany()
    * ```
    */
  get ventureEvent(): Prisma.VentureEventDelegate<ExtArgs>;

  /**
   * `prisma.venturePublication`: Exposes CRUD operations for the **VenturePublication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VenturePublications
    * const venturePublications = await prisma.venturePublication.findMany()
    * ```
    */
  get venturePublication(): Prisma.VenturePublicationDelegate<ExtArgs>;

  /**
   * `prisma.ventureSponsorship`: Exposes CRUD operations for the **VentureSponsorship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VentureSponsorships
    * const ventureSponsorships = await prisma.ventureSponsorship.findMany()
    * ```
    */
  get ventureSponsorship(): Prisma.VentureSponsorshipDelegate<ExtArgs>;

  /**
   * `prisma.ventureSubscription`: Exposes CRUD operations for the **VentureSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VentureSubscriptions
    * const ventureSubscriptions = await prisma.ventureSubscription.findMany()
    * ```
    */
  get ventureSubscription(): Prisma.VentureSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.xEventCategory`: Exposes CRUD operations for the **XEventCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XEventCategories
    * const xEventCategories = await prisma.xEventCategory.findMany()
    * ```
    */
  get xEventCategory(): Prisma.XEventCategoryDelegate<ExtArgs>;

  /**
   * `prisma.xUserRoles`: Exposes CRUD operations for the **XUserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XUserRoles
    * const xUserRoles = await prisma.xUserRoles.findMany()
    * ```
    */
  get xUserRoles(): Prisma.XUserRolesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    XUserPreferences: 'XUserPreferences',
    UserDetail: 'UserDetail',
    Department: 'Department',
    Municipality: 'Municipality',
    Comment: 'Comment',
    EventCategory: 'EventCategory',
    EventDonation: 'EventDonation',
    Location: 'Location',
    Notification: 'Notification',
    PublicationClap: 'PublicationClap',
    PublicationContent: 'PublicationContent',
    Role: 'Role',
    Venture: 'Venture',
    XVentureVencureCategory: 'XVentureVencureCategory',
    VentureCategory: 'VentureCategory',
    VentureDetail: 'VentureDetail',
    VentureEvent: 'VentureEvent',
    VenturePublication: 'VenturePublication',
    VentureSponsorship: 'VentureSponsorship',
    VentureSubscription: 'VentureSubscription',
    XEventCategory: 'XEventCategory',
    XUserRoles: 'XUserRoles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "xUserPreferences" | "userDetail" | "department" | "municipality" | "comment" | "eventCategory" | "eventDonation" | "location" | "notification" | "publicationClap" | "publicationContent" | "role" | "venture" | "xVentureVencureCategory" | "ventureCategory" | "ventureDetail" | "ventureEvent" | "venturePublication" | "ventureSponsorship" | "ventureSubscription" | "xEventCategory" | "xUserRoles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      XUserPreferences: {
        payload: Prisma.$XUserPreferencesPayload<ExtArgs>
        fields: Prisma.XUserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XUserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XUserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.XUserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XUserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          findMany: {
            args: Prisma.XUserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>[]
          }
          create: {
            args: Prisma.XUserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          createMany: {
            args: Prisma.XUserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XUserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.XUserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          update: {
            args: Prisma.XUserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.XUserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XUserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XUserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.XUserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXUserPreferences>
          }
          groupBy: {
            args: Prisma.XUserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<XUserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.XUserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<XUserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserDetail: {
        payload: Prisma.$UserDetailPayload<ExtArgs>
        fields: Prisma.UserDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          findFirst: {
            args: Prisma.UserDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          findMany: {
            args: Prisma.UserDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>[]
          }
          create: {
            args: Prisma.UserDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          createMany: {
            args: Prisma.UserDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>[]
          }
          delete: {
            args: Prisma.UserDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          update: {
            args: Prisma.UserDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          deleteMany: {
            args: Prisma.UserDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDetailPayload>
          }
          aggregate: {
            args: Prisma.UserDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDetail>
          }
          groupBy: {
            args: Prisma.UserDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDetailCountArgs<ExtArgs>
            result: $Utils.Optional<UserDetailCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Municipality: {
        payload: Prisma.$MunicipalityPayload<ExtArgs>
        fields: Prisma.MunicipalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findFirst: {
            args: Prisma.MunicipalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findMany: {
            args: Prisma.MunicipalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          create: {
            args: Prisma.MunicipalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          createMany: {
            args: Prisma.MunicipalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MunicipalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          delete: {
            args: Prisma.MunicipalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          update: {
            args: Prisma.MunicipalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          deleteMany: {
            args: Prisma.MunicipalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          aggregate: {
            args: Prisma.MunicipalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipality>
          }
          groupBy: {
            args: Prisma.MunicipalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipalityCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      EventCategory: {
        payload: Prisma.$EventCategoryPayload<ExtArgs>
        fields: Prisma.EventCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findFirst: {
            args: Prisma.EventCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findMany: {
            args: Prisma.EventCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>[]
          }
          create: {
            args: Prisma.EventCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          createMany: {
            args: Prisma.EventCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>[]
          }
          delete: {
            args: Prisma.EventCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          update: {
            args: Prisma.EventCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          deleteMany: {
            args: Prisma.EventCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          aggregate: {
            args: Prisma.EventCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCategory>
          }
          groupBy: {
            args: Prisma.EventCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryCountAggregateOutputType> | number
          }
        }
      }
      EventDonation: {
        payload: Prisma.$EventDonationPayload<ExtArgs>
        fields: Prisma.EventDonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventDonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventDonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          findFirst: {
            args: Prisma.EventDonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventDonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          findMany: {
            args: Prisma.EventDonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>[]
          }
          create: {
            args: Prisma.EventDonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          createMany: {
            args: Prisma.EventDonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventDonationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>[]
          }
          delete: {
            args: Prisma.EventDonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          update: {
            args: Prisma.EventDonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          deleteMany: {
            args: Prisma.EventDonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventDonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventDonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventDonationPayload>
          }
          aggregate: {
            args: Prisma.EventDonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventDonation>
          }
          groupBy: {
            args: Prisma.EventDonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventDonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventDonationCountArgs<ExtArgs>
            result: $Utils.Optional<EventDonationCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PublicationClap: {
        payload: Prisma.$PublicationClapPayload<ExtArgs>
        fields: Prisma.PublicationClapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationClapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationClapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          findFirst: {
            args: Prisma.PublicationClapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationClapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          findMany: {
            args: Prisma.PublicationClapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>[]
          }
          create: {
            args: Prisma.PublicationClapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          createMany: {
            args: Prisma.PublicationClapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicationClapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>[]
          }
          delete: {
            args: Prisma.PublicationClapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          update: {
            args: Prisma.PublicationClapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          deleteMany: {
            args: Prisma.PublicationClapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationClapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicationClapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationClapPayload>
          }
          aggregate: {
            args: Prisma.PublicationClapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicationClap>
          }
          groupBy: {
            args: Prisma.PublicationClapGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationClapGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationClapCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationClapCountAggregateOutputType> | number
          }
        }
      }
      PublicationContent: {
        payload: Prisma.$PublicationContentPayload<ExtArgs>
        fields: Prisma.PublicationContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          findFirst: {
            args: Prisma.PublicationContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          findMany: {
            args: Prisma.PublicationContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>[]
          }
          create: {
            args: Prisma.PublicationContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          createMany: {
            args: Prisma.PublicationContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicationContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>[]
          }
          delete: {
            args: Prisma.PublicationContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          update: {
            args: Prisma.PublicationContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          deleteMany: {
            args: Prisma.PublicationContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicationContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationContentPayload>
          }
          aggregate: {
            args: Prisma.PublicationContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicationContent>
          }
          groupBy: {
            args: Prisma.PublicationContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationContentCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationContentCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Venture: {
        payload: Prisma.$VenturePayload<ExtArgs>
        fields: Prisma.VentureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          findFirst: {
            args: Prisma.VentureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          findMany: {
            args: Prisma.VentureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>[]
          }
          create: {
            args: Prisma.VentureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          createMany: {
            args: Prisma.VentureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>[]
          }
          delete: {
            args: Prisma.VentureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          update: {
            args: Prisma.VentureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          deleteMany: {
            args: Prisma.VentureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePayload>
          }
          aggregate: {
            args: Prisma.VentureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenture>
          }
          groupBy: {
            args: Prisma.VentureGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureCountArgs<ExtArgs>
            result: $Utils.Optional<VentureCountAggregateOutputType> | number
          }
        }
      }
      XVentureVencureCategory: {
        payload: Prisma.$XVentureVencureCategoryPayload<ExtArgs>
        fields: Prisma.XVentureVencureCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XVentureVencureCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XVentureVencureCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          findFirst: {
            args: Prisma.XVentureVencureCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XVentureVencureCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          findMany: {
            args: Prisma.XVentureVencureCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>[]
          }
          create: {
            args: Prisma.XVentureVencureCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          createMany: {
            args: Prisma.XVentureVencureCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XVentureVencureCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>[]
          }
          delete: {
            args: Prisma.XVentureVencureCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          update: {
            args: Prisma.XVentureVencureCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          deleteMany: {
            args: Prisma.XVentureVencureCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XVentureVencureCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XVentureVencureCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XVentureVencureCategoryPayload>
          }
          aggregate: {
            args: Prisma.XVentureVencureCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXVentureVencureCategory>
          }
          groupBy: {
            args: Prisma.XVentureVencureCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<XVentureVencureCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.XVentureVencureCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<XVentureVencureCategoryCountAggregateOutputType> | number
          }
        }
      }
      VentureCategory: {
        payload: Prisma.$VentureCategoryPayload<ExtArgs>
        fields: Prisma.VentureCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          findFirst: {
            args: Prisma.VentureCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          findMany: {
            args: Prisma.VentureCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>[]
          }
          create: {
            args: Prisma.VentureCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          createMany: {
            args: Prisma.VentureCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>[]
          }
          delete: {
            args: Prisma.VentureCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          update: {
            args: Prisma.VentureCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          deleteMany: {
            args: Prisma.VentureCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureCategoryPayload>
          }
          aggregate: {
            args: Prisma.VentureCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentureCategory>
          }
          groupBy: {
            args: Prisma.VentureCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<VentureCategoryCountAggregateOutputType> | number
          }
        }
      }
      VentureDetail: {
        payload: Prisma.$VentureDetailPayload<ExtArgs>
        fields: Prisma.VentureDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          findFirst: {
            args: Prisma.VentureDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          findMany: {
            args: Prisma.VentureDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>[]
          }
          create: {
            args: Prisma.VentureDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          createMany: {
            args: Prisma.VentureDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>[]
          }
          delete: {
            args: Prisma.VentureDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          update: {
            args: Prisma.VentureDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          deleteMany: {
            args: Prisma.VentureDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureDetailPayload>
          }
          aggregate: {
            args: Prisma.VentureDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentureDetail>
          }
          groupBy: {
            args: Prisma.VentureDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureDetailCountArgs<ExtArgs>
            result: $Utils.Optional<VentureDetailCountAggregateOutputType> | number
          }
        }
      }
      VentureEvent: {
        payload: Prisma.$VentureEventPayload<ExtArgs>
        fields: Prisma.VentureEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          findFirst: {
            args: Prisma.VentureEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          findMany: {
            args: Prisma.VentureEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>[]
          }
          create: {
            args: Prisma.VentureEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          createMany: {
            args: Prisma.VentureEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>[]
          }
          delete: {
            args: Prisma.VentureEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          update: {
            args: Prisma.VentureEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          deleteMany: {
            args: Prisma.VentureEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureEventPayload>
          }
          aggregate: {
            args: Prisma.VentureEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentureEvent>
          }
          groupBy: {
            args: Prisma.VentureEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureEventCountArgs<ExtArgs>
            result: $Utils.Optional<VentureEventCountAggregateOutputType> | number
          }
        }
      }
      VenturePublication: {
        payload: Prisma.$VenturePublicationPayload<ExtArgs>
        fields: Prisma.VenturePublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenturePublicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenturePublicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          findFirst: {
            args: Prisma.VenturePublicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenturePublicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          findMany: {
            args: Prisma.VenturePublicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>[]
          }
          create: {
            args: Prisma.VenturePublicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          createMany: {
            args: Prisma.VenturePublicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenturePublicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>[]
          }
          delete: {
            args: Prisma.VenturePublicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          update: {
            args: Prisma.VenturePublicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          deleteMany: {
            args: Prisma.VenturePublicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenturePublicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenturePublicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenturePublicationPayload>
          }
          aggregate: {
            args: Prisma.VenturePublicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenturePublication>
          }
          groupBy: {
            args: Prisma.VenturePublicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenturePublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenturePublicationCountArgs<ExtArgs>
            result: $Utils.Optional<VenturePublicationCountAggregateOutputType> | number
          }
        }
      }
      VentureSponsorship: {
        payload: Prisma.$VentureSponsorshipPayload<ExtArgs>
        fields: Prisma.VentureSponsorshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureSponsorshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureSponsorshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          findFirst: {
            args: Prisma.VentureSponsorshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureSponsorshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          findMany: {
            args: Prisma.VentureSponsorshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>[]
          }
          create: {
            args: Prisma.VentureSponsorshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          createMany: {
            args: Prisma.VentureSponsorshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureSponsorshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>[]
          }
          delete: {
            args: Prisma.VentureSponsorshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          update: {
            args: Prisma.VentureSponsorshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          deleteMany: {
            args: Prisma.VentureSponsorshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureSponsorshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureSponsorshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSponsorshipPayload>
          }
          aggregate: {
            args: Prisma.VentureSponsorshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentureSponsorship>
          }
          groupBy: {
            args: Prisma.VentureSponsorshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureSponsorshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureSponsorshipCountArgs<ExtArgs>
            result: $Utils.Optional<VentureSponsorshipCountAggregateOutputType> | number
          }
        }
      }
      VentureSubscription: {
        payload: Prisma.$VentureSubscriptionPayload<ExtArgs>
        fields: Prisma.VentureSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VentureSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VentureSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.VentureSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VentureSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          findMany: {
            args: Prisma.VentureSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>[]
          }
          create: {
            args: Prisma.VentureSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          createMany: {
            args: Prisma.VentureSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VentureSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.VentureSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          update: {
            args: Prisma.VentureSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.VentureSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VentureSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VentureSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentureSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.VentureSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVentureSubscription>
          }
          groupBy: {
            args: Prisma.VentureSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VentureSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VentureSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<VentureSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      XEventCategory: {
        payload: Prisma.$XEventCategoryPayload<ExtArgs>
        fields: Prisma.XEventCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XEventCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XEventCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          findFirst: {
            args: Prisma.XEventCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XEventCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          findMany: {
            args: Prisma.XEventCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>[]
          }
          create: {
            args: Prisma.XEventCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          createMany: {
            args: Prisma.XEventCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XEventCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>[]
          }
          delete: {
            args: Prisma.XEventCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          update: {
            args: Prisma.XEventCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          deleteMany: {
            args: Prisma.XEventCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XEventCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XEventCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XEventCategoryPayload>
          }
          aggregate: {
            args: Prisma.XEventCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXEventCategory>
          }
          groupBy: {
            args: Prisma.XEventCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<XEventCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.XEventCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<XEventCategoryCountAggregateOutputType> | number
          }
        }
      }
      XUserRoles: {
        payload: Prisma.$XUserRolesPayload<ExtArgs>
        fields: Prisma.XUserRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XUserRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XUserRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          findFirst: {
            args: Prisma.XUserRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XUserRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          findMany: {
            args: Prisma.XUserRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>[]
          }
          create: {
            args: Prisma.XUserRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          createMany: {
            args: Prisma.XUserRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XUserRolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>[]
          }
          delete: {
            args: Prisma.XUserRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          update: {
            args: Prisma.XUserRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          deleteMany: {
            args: Prisma.XUserRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XUserRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XUserRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XUserRolesPayload>
          }
          aggregate: {
            args: Prisma.XUserRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXUserRoles>
          }
          groupBy: {
            args: Prisma.XUserRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<XUserRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.XUserRolesCountArgs<ExtArgs>
            result: $Utils.Optional<XUserRolesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    comments: number
    eventDonations: number
    notifications: number
    publicationClaps: number
    ventures: number
    ventureSponsorships: number
    ventureSubscriptions: number
    roles: number
    XUserRoles: number
    preferences: number
    XUserPreferences: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    eventDonations?: boolean | UserCountOutputTypeCountEventDonationsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    publicationClaps?: boolean | UserCountOutputTypeCountPublicationClapsArgs
    ventures?: boolean | UserCountOutputTypeCountVenturesArgs
    ventureSponsorships?: boolean | UserCountOutputTypeCountVentureSponsorshipsArgs
    ventureSubscriptions?: boolean | UserCountOutputTypeCountVentureSubscriptionsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    XUserRoles?: boolean | UserCountOutputTypeCountXUserRolesArgs
    preferences?: boolean | UserCountOutputTypeCountPreferencesArgs
    XUserPreferences?: boolean | UserCountOutputTypeCountXUserPreferencesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublicationClapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationClapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVenturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVentureSponsorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSponsorshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVentureSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserRolesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserPreferencesWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    municipalities: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipalities?: boolean | DepartmentCountOutputTypeCountMunicipalitiesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
  }


  /**
   * Count Type MunicipalityCountOutputType
   */

  export type MunicipalityCountOutputType = {
    UserDetail: number
  }

  export type MunicipalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserDetail?: boolean | MunicipalityCountOutputTypeCountUserDetailArgs
  }

  // Custom InputTypes
  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipalityCountOutputType
     */
    select?: MunicipalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountUserDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailWhereInput
  }


  /**
   * Count Type EventCategoryCountOutputType
   */

  export type EventCategoryCountOutputType = {
    XEventCategory: number
    VentureEvent: number
  }

  export type EventCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    XEventCategory?: boolean | EventCategoryCountOutputTypeCountXEventCategoryArgs
    VentureEvent?: boolean | EventCategoryCountOutputTypeCountVentureEventArgs
  }

  // Custom InputTypes
  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategoryCountOutputType
     */
    select?: EventCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountXEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XEventCategoryWhereInput
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountVentureEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureEventWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    XUserRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    XUserRoles?: boolean | RoleCountOutputTypeCountXUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountXUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserRolesWhereInput
  }


  /**
   * Count Type VentureCountOutputType
   */

  export type VentureCountOutputType = {
    categories: number
    XVentureVencureCategory: number
  }

  export type VentureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | VentureCountOutputTypeCountCategoriesArgs
    XVentureVencureCategory?: boolean | VentureCountOutputTypeCountXVentureVencureCategoryArgs
  }

  // Custom InputTypes
  /**
   * VentureCountOutputType without action
   */
  export type VentureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCountOutputType
     */
    select?: VentureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VentureCountOutputType without action
   */
  export type VentureCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureCategoryWhereInput
  }

  /**
   * VentureCountOutputType without action
   */
  export type VentureCountOutputTypeCountXVentureVencureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XVentureVencureCategoryWhereInput
  }


  /**
   * Count Type VentureCategoryCountOutputType
   */

  export type VentureCategoryCountOutputType = {
    users: number
    XUserPreferences: number
    ventures: number
    XVentureVencureCategory: number
  }

  export type VentureCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | VentureCategoryCountOutputTypeCountUsersArgs
    XUserPreferences?: boolean | VentureCategoryCountOutputTypeCountXUserPreferencesArgs
    ventures?: boolean | VentureCategoryCountOutputTypeCountVenturesArgs
    XVentureVencureCategory?: boolean | VentureCategoryCountOutputTypeCountXVentureVencureCategoryArgs
  }

  // Custom InputTypes
  /**
   * VentureCategoryCountOutputType without action
   */
  export type VentureCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategoryCountOutputType
     */
    select?: VentureCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VentureCategoryCountOutputType without action
   */
  export type VentureCategoryCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * VentureCategoryCountOutputType without action
   */
  export type VentureCategoryCountOutputTypeCountXUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserPreferencesWhereInput
  }

  /**
   * VentureCategoryCountOutputType without action
   */
  export type VentureCategoryCountOutputTypeCountVenturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureWhereInput
  }

  /**
   * VentureCategoryCountOutputType without action
   */
  export type VentureCategoryCountOutputTypeCountXVentureVencureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XVentureVencureCategoryWhereInput
  }


  /**
   * Count Type VentureDetailCountOutputType
   */

  export type VentureDetailCountOutputType = {
    event: number
    publications: number
    sponsorship: number
    subscription: number
  }

  export type VentureDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | VentureDetailCountOutputTypeCountEventArgs
    publications?: boolean | VentureDetailCountOutputTypeCountPublicationsArgs
    sponsorship?: boolean | VentureDetailCountOutputTypeCountSponsorshipArgs
    subscription?: boolean | VentureDetailCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * VentureDetailCountOutputType without action
   */
  export type VentureDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetailCountOutputType
     */
    select?: VentureDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VentureDetailCountOutputType without action
   */
  export type VentureDetailCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureEventWhereInput
  }

  /**
   * VentureDetailCountOutputType without action
   */
  export type VentureDetailCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenturePublicationWhereInput
  }

  /**
   * VentureDetailCountOutputType without action
   */
  export type VentureDetailCountOutputTypeCountSponsorshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSponsorshipWhereInput
  }

  /**
   * VentureDetailCountOutputType without action
   */
  export type VentureDetailCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSubscriptionWhereInput
  }


  /**
   * Count Type VentureEventCountOutputType
   */

  export type VentureEventCountOutputType = {
    EventDonation: number
    Location: number
    XEventCategory: number
    EventCategory: number
  }

  export type VentureEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventDonation?: boolean | VentureEventCountOutputTypeCountEventDonationArgs
    Location?: boolean | VentureEventCountOutputTypeCountLocationArgs
    XEventCategory?: boolean | VentureEventCountOutputTypeCountXEventCategoryArgs
    EventCategory?: boolean | VentureEventCountOutputTypeCountEventCategoryArgs
  }

  // Custom InputTypes
  /**
   * VentureEventCountOutputType without action
   */
  export type VentureEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEventCountOutputType
     */
    select?: VentureEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VentureEventCountOutputType without action
   */
  export type VentureEventCountOutputTypeCountEventDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDonationWhereInput
  }

  /**
   * VentureEventCountOutputType without action
   */
  export type VentureEventCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * VentureEventCountOutputType without action
   */
  export type VentureEventCountOutputTypeCountXEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XEventCategoryWhereInput
  }

  /**
   * VentureEventCountOutputType without action
   */
  export type VentureEventCountOutputTypeCountEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoryWhereInput
  }


  /**
   * Count Type VenturePublicationCountOutputType
   */

  export type VenturePublicationCountOutputType = {
    Comment: number
    PublicationClap: number
    PublicationContent: number
  }

  export type VenturePublicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | VenturePublicationCountOutputTypeCountCommentArgs
    PublicationClap?: boolean | VenturePublicationCountOutputTypeCountPublicationClapArgs
    PublicationContent?: boolean | VenturePublicationCountOutputTypeCountPublicationContentArgs
  }

  // Custom InputTypes
  /**
   * VenturePublicationCountOutputType without action
   */
  export type VenturePublicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublicationCountOutputType
     */
    select?: VenturePublicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenturePublicationCountOutputType without action
   */
  export type VenturePublicationCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * VenturePublicationCountOutputType without action
   */
  export type VenturePublicationCountOutputTypeCountPublicationClapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationClapWhereInput
  }

  /**
   * VenturePublicationCountOutputType without action
   */
  export type VenturePublicationCountOutputTypeCountPublicationContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationContentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    picture: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    active: boolean | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    onboardingCompleted: boolean | null
    userDetailId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    picture: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    active: boolean | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    onboardingCompleted: boolean | null
    userDetailId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    picture: number
    email: number
    firstName: number
    lastName: number
    active: number
    verified: number
    createdAt: number
    updatedAt: number
    onboardingCompleted: number
    userDetailId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    picture?: true
    email?: true
    firstName?: true
    lastName?: true
    active?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    onboardingCompleted?: true
    userDetailId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    picture?: true
    email?: true
    firstName?: true
    lastName?: true
    active?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    onboardingCompleted?: true
    userDetailId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    picture?: true
    email?: true
    firstName?: true
    lastName?: true
    active?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    onboardingCompleted?: true
    userDetailId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active: boolean
    verified: boolean
    createdAt: Date
    updatedAt: Date
    onboardingCompleted: boolean
    userDetailId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    active?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboardingCompleted?: boolean
    userDetailId?: boolean
    comments?: boolean | User$commentsArgs<ExtArgs>
    eventDonations?: boolean | User$eventDonationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    publicationClaps?: boolean | User$publicationClapsArgs<ExtArgs>
    ventures?: boolean | User$venturesArgs<ExtArgs>
    ventureSponsorships?: boolean | User$ventureSponsorshipsArgs<ExtArgs>
    ventureSubscriptions?: boolean | User$ventureSubscriptionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    detail?: boolean | User$detailArgs<ExtArgs>
    XUserRoles?: boolean | User$XUserRolesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    XUserPreferences?: boolean | User$XUserPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    active?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboardingCompleted?: boolean
    userDetailId?: boolean
    detail?: boolean | User$detailArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    picture?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    active?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboardingCompleted?: boolean
    userDetailId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | User$commentsArgs<ExtArgs>
    eventDonations?: boolean | User$eventDonationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    publicationClaps?: boolean | User$publicationClapsArgs<ExtArgs>
    ventures?: boolean | User$venturesArgs<ExtArgs>
    ventureSponsorships?: boolean | User$ventureSponsorshipsArgs<ExtArgs>
    ventureSubscriptions?: boolean | User$ventureSubscriptionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    detail?: boolean | User$detailArgs<ExtArgs>
    XUserRoles?: boolean | User$XUserRolesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    XUserPreferences?: boolean | User$XUserPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail?: boolean | User$detailArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      eventDonations: Prisma.$EventDonationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      publicationClaps: Prisma.$PublicationClapPayload<ExtArgs>[]
      ventures: Prisma.$VenturePayload<ExtArgs>[]
      ventureSponsorships: Prisma.$VentureSponsorshipPayload<ExtArgs>[]
      ventureSubscriptions: Prisma.$VentureSubscriptionPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      detail: Prisma.$UserDetailPayload<ExtArgs> | null
      XUserRoles: Prisma.$XUserRolesPayload<ExtArgs>[]
      preferences: Prisma.$VentureCategoryPayload<ExtArgs>[]
      XUserPreferences: Prisma.$XUserPreferencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      picture: string
      email: string
      firstName: string
      lastName: string
      active: boolean
      verified: boolean
      createdAt: Date
      updatedAt: Date
      onboardingCompleted: boolean
      userDetailId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    eventDonations<T extends User$eventDonationsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventDonationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    publicationClaps<T extends User$publicationClapsArgs<ExtArgs> = {}>(args?: Subset<T, User$publicationClapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findMany"> | Null>
    ventures<T extends User$venturesArgs<ExtArgs> = {}>(args?: Subset<T, User$venturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findMany"> | Null>
    ventureSponsorships<T extends User$ventureSponsorshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$ventureSponsorshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findMany"> | Null>
    ventureSubscriptions<T extends User$ventureSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$ventureSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany"> | Null>
    detail<T extends User$detailArgs<ExtArgs> = {}>(args?: Subset<T, User$detailArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    XUserRoles<T extends User$XUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$XUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findMany"> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    XUserPreferences<T extends User$XUserPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$XUserPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly picture: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly verified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly onboardingCompleted: FieldRef<"User", 'Boolean'>
    readonly userDetailId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.eventDonations
   */
  export type User$eventDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    where?: EventDonationWhereInput
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    cursor?: EventDonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventDonationScalarFieldEnum | EventDonationScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.publicationClaps
   */
  export type User$publicationClapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    where?: PublicationClapWhereInput
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    cursor?: PublicationClapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationClapScalarFieldEnum | PublicationClapScalarFieldEnum[]
  }

  /**
   * User.ventures
   */
  export type User$venturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    where?: VentureWhereInput
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    cursor?: VentureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureScalarFieldEnum | VentureScalarFieldEnum[]
  }

  /**
   * User.ventureSponsorships
   */
  export type User$ventureSponsorshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    where?: VentureSponsorshipWhereInput
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    cursor?: VentureSponsorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureSponsorshipScalarFieldEnum | VentureSponsorshipScalarFieldEnum[]
  }

  /**
   * User.ventureSubscriptions
   */
  export type User$ventureSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    where?: VentureSubscriptionWhereInput
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    cursor?: VentureSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureSubscriptionScalarFieldEnum | VentureSubscriptionScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.detail
   */
  export type User$detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    where?: UserDetailWhereInput
  }

  /**
   * User.XUserRoles
   */
  export type User$XUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    where?: XUserRolesWhereInput
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    cursor?: XUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XUserRolesScalarFieldEnum | XUserRolesScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    where?: VentureCategoryWhereInput
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    cursor?: VentureCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureCategoryScalarFieldEnum | VentureCategoryScalarFieldEnum[]
  }

  /**
   * User.XUserPreferences
   */
  export type User$XUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    where?: XUserPreferencesWhereInput
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    cursor?: XUserPreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XUserPreferencesScalarFieldEnum | XUserPreferencesScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model XUserPreferences
   */

  export type AggregateXUserPreferences = {
    _count: XUserPreferencesCountAggregateOutputType | null
    _min: XUserPreferencesMinAggregateOutputType | null
    _max: XUserPreferencesMaxAggregateOutputType | null
  }

  export type XUserPreferencesMinAggregateOutputType = {
    userId: string | null
    categoryId: string | null
  }

  export type XUserPreferencesMaxAggregateOutputType = {
    userId: string | null
    categoryId: string | null
  }

  export type XUserPreferencesCountAggregateOutputType = {
    userId: number
    categoryId: number
    _all: number
  }


  export type XUserPreferencesMinAggregateInputType = {
    userId?: true
    categoryId?: true
  }

  export type XUserPreferencesMaxAggregateInputType = {
    userId?: true
    categoryId?: true
  }

  export type XUserPreferencesCountAggregateInputType = {
    userId?: true
    categoryId?: true
    _all?: true
  }

  export type XUserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XUserPreferences to aggregate.
     */
    where?: XUserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserPreferences to fetch.
     */
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XUserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XUserPreferences
    **/
    _count?: true | XUserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XUserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XUserPreferencesMaxAggregateInputType
  }

  export type GetXUserPreferencesAggregateType<T extends XUserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateXUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXUserPreferences[P]>
      : GetScalarType<T[P], AggregateXUserPreferences[P]>
  }




  export type XUserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserPreferencesWhereInput
    orderBy?: XUserPreferencesOrderByWithAggregationInput | XUserPreferencesOrderByWithAggregationInput[]
    by: XUserPreferencesScalarFieldEnum[] | XUserPreferencesScalarFieldEnum
    having?: XUserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XUserPreferencesCountAggregateInputType | true
    _min?: XUserPreferencesMinAggregateInputType
    _max?: XUserPreferencesMaxAggregateInputType
  }

  export type XUserPreferencesGroupByOutputType = {
    userId: string
    categoryId: string
    _count: XUserPreferencesCountAggregateOutputType | null
    _min: XUserPreferencesMinAggregateOutputType | null
    _max: XUserPreferencesMaxAggregateOutputType | null
  }

  type GetXUserPreferencesGroupByPayload<T extends XUserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XUserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XUserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XUserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], XUserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type XUserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    categoryId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xUserPreferences"]>

  export type XUserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    categoryId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xUserPreferences"]>

  export type XUserPreferencesSelectScalar = {
    userId?: boolean
    categoryId?: boolean
  }

  export type XUserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }
  export type XUserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }

  export type $XUserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XUserPreferences"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      VentureCategory: Prisma.$VentureCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      categoryId: string
    }, ExtArgs["result"]["xUserPreferences"]>
    composites: {}
  }

  type XUserPreferencesGetPayload<S extends boolean | null | undefined | XUserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$XUserPreferencesPayload, S>

  type XUserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XUserPreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XUserPreferencesCountAggregateInputType | true
    }

  export interface XUserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XUserPreferences'], meta: { name: 'XUserPreferences' } }
    /**
     * Find zero or one XUserPreferences that matches the filter.
     * @param {XUserPreferencesFindUniqueArgs} args - Arguments to find a XUserPreferences
     * @example
     * // Get one XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XUserPreferencesFindUniqueArgs>(args: SelectSubset<T, XUserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XUserPreferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XUserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a XUserPreferences
     * @example
     * // Get one XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XUserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, XUserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XUserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesFindFirstArgs} args - Arguments to find a XUserPreferences
     * @example
     * // Get one XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XUserPreferencesFindFirstArgs>(args?: SelectSubset<T, XUserPreferencesFindFirstArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XUserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesFindFirstOrThrowArgs} args - Arguments to find a XUserPreferences
     * @example
     * // Get one XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XUserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, XUserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XUserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findMany()
     * 
     * // Get first 10 XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const xUserPreferencesWithUserIdOnly = await prisma.xUserPreferences.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends XUserPreferencesFindManyArgs>(args?: SelectSubset<T, XUserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XUserPreferences.
     * @param {XUserPreferencesCreateArgs} args - Arguments to create a XUserPreferences.
     * @example
     * // Create one XUserPreferences
     * const XUserPreferences = await prisma.xUserPreferences.create({
     *   data: {
     *     // ... data to create a XUserPreferences
     *   }
     * })
     * 
     */
    create<T extends XUserPreferencesCreateArgs>(args: SelectSubset<T, XUserPreferencesCreateArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XUserPreferences.
     * @param {XUserPreferencesCreateManyArgs} args - Arguments to create many XUserPreferences.
     * @example
     * // Create many XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XUserPreferencesCreateManyArgs>(args?: SelectSubset<T, XUserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XUserPreferences and returns the data saved in the database.
     * @param {XUserPreferencesCreateManyAndReturnArgs} args - Arguments to create many XUserPreferences.
     * @example
     * // Create many XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XUserPreferences and only return the `userId`
     * const xUserPreferencesWithUserIdOnly = await prisma.xUserPreferences.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XUserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, XUserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XUserPreferences.
     * @param {XUserPreferencesDeleteArgs} args - Arguments to delete one XUserPreferences.
     * @example
     * // Delete one XUserPreferences
     * const XUserPreferences = await prisma.xUserPreferences.delete({
     *   where: {
     *     // ... filter to delete one XUserPreferences
     *   }
     * })
     * 
     */
    delete<T extends XUserPreferencesDeleteArgs>(args: SelectSubset<T, XUserPreferencesDeleteArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XUserPreferences.
     * @param {XUserPreferencesUpdateArgs} args - Arguments to update one XUserPreferences.
     * @example
     * // Update one XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XUserPreferencesUpdateArgs>(args: SelectSubset<T, XUserPreferencesUpdateArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XUserPreferences.
     * @param {XUserPreferencesDeleteManyArgs} args - Arguments to filter XUserPreferences to delete.
     * @example
     * // Delete a few XUserPreferences
     * const { count } = await prisma.xUserPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XUserPreferencesDeleteManyArgs>(args?: SelectSubset<T, XUserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XUserPreferencesUpdateManyArgs>(args: SelectSubset<T, XUserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XUserPreferences.
     * @param {XUserPreferencesUpsertArgs} args - Arguments to update or create a XUserPreferences.
     * @example
     * // Update or create a XUserPreferences
     * const xUserPreferences = await prisma.xUserPreferences.upsert({
     *   create: {
     *     // ... data to create a XUserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XUserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends XUserPreferencesUpsertArgs>(args: SelectSubset<T, XUserPreferencesUpsertArgs<ExtArgs>>): Prisma__XUserPreferencesClient<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesCountArgs} args - Arguments to filter XUserPreferences to count.
     * @example
     * // Count the number of XUserPreferences
     * const count = await prisma.xUserPreferences.count({
     *   where: {
     *     // ... the filter for the XUserPreferences we want to count
     *   }
     * })
    **/
    count<T extends XUserPreferencesCountArgs>(
      args?: Subset<T, XUserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XUserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XUserPreferencesAggregateArgs>(args: Subset<T, XUserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetXUserPreferencesAggregateType<T>>

    /**
     * Group by XUserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XUserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XUserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: XUserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XUserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XUserPreferences model
   */
  readonly fields: XUserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XUserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XUserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VentureCategory<T extends VentureCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategoryDefaultArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XUserPreferences model
   */ 
  interface XUserPreferencesFieldRefs {
    readonly userId: FieldRef<"XUserPreferences", 'String'>
    readonly categoryId: FieldRef<"XUserPreferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * XUserPreferences findUnique
   */
  export type XUserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which XUserPreferences to fetch.
     */
    where: XUserPreferencesWhereUniqueInput
  }

  /**
   * XUserPreferences findUniqueOrThrow
   */
  export type XUserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which XUserPreferences to fetch.
     */
    where: XUserPreferencesWhereUniqueInput
  }

  /**
   * XUserPreferences findFirst
   */
  export type XUserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which XUserPreferences to fetch.
     */
    where?: XUserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserPreferences to fetch.
     */
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XUserPreferences.
     */
    cursor?: XUserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XUserPreferences.
     */
    distinct?: XUserPreferencesScalarFieldEnum | XUserPreferencesScalarFieldEnum[]
  }

  /**
   * XUserPreferences findFirstOrThrow
   */
  export type XUserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which XUserPreferences to fetch.
     */
    where?: XUserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserPreferences to fetch.
     */
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XUserPreferences.
     */
    cursor?: XUserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XUserPreferences.
     */
    distinct?: XUserPreferencesScalarFieldEnum | XUserPreferencesScalarFieldEnum[]
  }

  /**
   * XUserPreferences findMany
   */
  export type XUserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which XUserPreferences to fetch.
     */
    where?: XUserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserPreferences to fetch.
     */
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XUserPreferences.
     */
    cursor?: XUserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserPreferences.
     */
    skip?: number
    distinct?: XUserPreferencesScalarFieldEnum | XUserPreferencesScalarFieldEnum[]
  }

  /**
   * XUserPreferences create
   */
  export type XUserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a XUserPreferences.
     */
    data: XOR<XUserPreferencesCreateInput, XUserPreferencesUncheckedCreateInput>
  }

  /**
   * XUserPreferences createMany
   */
  export type XUserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XUserPreferences.
     */
    data: XUserPreferencesCreateManyInput | XUserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XUserPreferences createManyAndReturn
   */
  export type XUserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XUserPreferences.
     */
    data: XUserPreferencesCreateManyInput | XUserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XUserPreferences update
   */
  export type XUserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a XUserPreferences.
     */
    data: XOR<XUserPreferencesUpdateInput, XUserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which XUserPreferences to update.
     */
    where: XUserPreferencesWhereUniqueInput
  }

  /**
   * XUserPreferences updateMany
   */
  export type XUserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XUserPreferences.
     */
    data: XOR<XUserPreferencesUpdateManyMutationInput, XUserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which XUserPreferences to update
     */
    where?: XUserPreferencesWhereInput
  }

  /**
   * XUserPreferences upsert
   */
  export type XUserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the XUserPreferences to update in case it exists.
     */
    where: XUserPreferencesWhereUniqueInput
    /**
     * In case the XUserPreferences found by the `where` argument doesn't exist, create a new XUserPreferences with this data.
     */
    create: XOR<XUserPreferencesCreateInput, XUserPreferencesUncheckedCreateInput>
    /**
     * In case the XUserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XUserPreferencesUpdateInput, XUserPreferencesUncheckedUpdateInput>
  }

  /**
   * XUserPreferences delete
   */
  export type XUserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which XUserPreferences to delete.
     */
    where: XUserPreferencesWhereUniqueInput
  }

  /**
   * XUserPreferences deleteMany
   */
  export type XUserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XUserPreferences to delete
     */
    where?: XUserPreferencesWhereInput
  }

  /**
   * XUserPreferences without action
   */
  export type XUserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserDetail
   */

  export type AggregateUserDetail = {
    _count: UserDetailCountAggregateOutputType | null
    _avg: UserDetailAvgAggregateOutputType | null
    _sum: UserDetailSumAggregateOutputType | null
    _min: UserDetailMinAggregateOutputType | null
    _max: UserDetailMaxAggregateOutputType | null
  }

  export type UserDetailAvgAggregateOutputType = {
    municipalityId: number | null
  }

  export type UserDetailSumAggregateOutputType = {
    municipalityId: number | null
  }

  export type UserDetailMinAggregateOutputType = {
    id: string | null
    gender: string | null
    birthDate: Date | null
    municipalityId: number | null
  }

  export type UserDetailMaxAggregateOutputType = {
    id: string | null
    gender: string | null
    birthDate: Date | null
    municipalityId: number | null
  }

  export type UserDetailCountAggregateOutputType = {
    id: number
    gender: number
    birthDate: number
    municipalityId: number
    _all: number
  }


  export type UserDetailAvgAggregateInputType = {
    municipalityId?: true
  }

  export type UserDetailSumAggregateInputType = {
    municipalityId?: true
  }

  export type UserDetailMinAggregateInputType = {
    id?: true
    gender?: true
    birthDate?: true
    municipalityId?: true
  }

  export type UserDetailMaxAggregateInputType = {
    id?: true
    gender?: true
    birthDate?: true
    municipalityId?: true
  }

  export type UserDetailCountAggregateInputType = {
    id?: true
    gender?: true
    birthDate?: true
    municipalityId?: true
    _all?: true
  }

  export type UserDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDetail to aggregate.
     */
    where?: UserDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailOrderByWithRelationInput | UserDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDetails
    **/
    _count?: true | UserDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDetailMaxAggregateInputType
  }

  export type GetUserDetailAggregateType<T extends UserDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDetail[P]>
      : GetScalarType<T[P], AggregateUserDetail[P]>
  }




  export type UserDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDetailWhereInput
    orderBy?: UserDetailOrderByWithAggregationInput | UserDetailOrderByWithAggregationInput[]
    by: UserDetailScalarFieldEnum[] | UserDetailScalarFieldEnum
    having?: UserDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDetailCountAggregateInputType | true
    _avg?: UserDetailAvgAggregateInputType
    _sum?: UserDetailSumAggregateInputType
    _min?: UserDetailMinAggregateInputType
    _max?: UserDetailMaxAggregateInputType
  }

  export type UserDetailGroupByOutputType = {
    id: string
    gender: string
    birthDate: Date
    municipalityId: number
    _count: UserDetailCountAggregateOutputType | null
    _avg: UserDetailAvgAggregateOutputType | null
    _sum: UserDetailSumAggregateOutputType | null
    _min: UserDetailMinAggregateOutputType | null
    _max: UserDetailMaxAggregateOutputType | null
  }

  type GetUserDetailGroupByPayload<T extends UserDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDetailGroupByOutputType[P]>
            : GetScalarType<T[P], UserDetailGroupByOutputType[P]>
        }
      >
    >


  export type UserDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    birthDate?: boolean
    municipalityId?: boolean
    user?: boolean | UserDetail$userArgs<ExtArgs>
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDetail"]>

  export type UserDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    birthDate?: boolean
    municipalityId?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDetail"]>

  export type UserDetailSelectScalar = {
    id?: boolean
    gender?: boolean
    birthDate?: boolean
    municipalityId?: boolean
  }

  export type UserDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDetail$userArgs<ExtArgs>
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }
  export type UserDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }

  export type $UserDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      municipality: Prisma.$MunicipalityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gender: string
      birthDate: Date
      municipalityId: number
    }, ExtArgs["result"]["userDetail"]>
    composites: {}
  }

  type UserDetailGetPayload<S extends boolean | null | undefined | UserDetailDefaultArgs> = $Result.GetResult<Prisma.$UserDetailPayload, S>

  type UserDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserDetailCountAggregateInputType | true
    }

  export interface UserDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDetail'], meta: { name: 'UserDetail' } }
    /**
     * Find zero or one UserDetail that matches the filter.
     * @param {UserDetailFindUniqueArgs} args - Arguments to find a UserDetail
     * @example
     * // Get one UserDetail
     * const userDetail = await prisma.userDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDetailFindUniqueArgs>(args: SelectSubset<T, UserDetailFindUniqueArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserDetailFindUniqueOrThrowArgs} args - Arguments to find a UserDetail
     * @example
     * // Get one UserDetail
     * const userDetail = await prisma.userDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailFindFirstArgs} args - Arguments to find a UserDetail
     * @example
     * // Get one UserDetail
     * const userDetail = await prisma.userDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDetailFindFirstArgs>(args?: SelectSubset<T, UserDetailFindFirstArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailFindFirstOrThrowArgs} args - Arguments to find a UserDetail
     * @example
     * // Get one UserDetail
     * const userDetail = await prisma.userDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDetails
     * const userDetails = await prisma.userDetail.findMany()
     * 
     * // Get first 10 UserDetails
     * const userDetails = await prisma.userDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDetailWithIdOnly = await prisma.userDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDetailFindManyArgs>(args?: SelectSubset<T, UserDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserDetail.
     * @param {UserDetailCreateArgs} args - Arguments to create a UserDetail.
     * @example
     * // Create one UserDetail
     * const UserDetail = await prisma.userDetail.create({
     *   data: {
     *     // ... data to create a UserDetail
     *   }
     * })
     * 
     */
    create<T extends UserDetailCreateArgs>(args: SelectSubset<T, UserDetailCreateArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserDetails.
     * @param {UserDetailCreateManyArgs} args - Arguments to create many UserDetails.
     * @example
     * // Create many UserDetails
     * const userDetail = await prisma.userDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDetailCreateManyArgs>(args?: SelectSubset<T, UserDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDetails and returns the data saved in the database.
     * @param {UserDetailCreateManyAndReturnArgs} args - Arguments to create many UserDetails.
     * @example
     * // Create many UserDetails
     * const userDetail = await prisma.userDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDetails and only return the `id`
     * const userDetailWithIdOnly = await prisma.userDetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserDetail.
     * @param {UserDetailDeleteArgs} args - Arguments to delete one UserDetail.
     * @example
     * // Delete one UserDetail
     * const UserDetail = await prisma.userDetail.delete({
     *   where: {
     *     // ... filter to delete one UserDetail
     *   }
     * })
     * 
     */
    delete<T extends UserDetailDeleteArgs>(args: SelectSubset<T, UserDetailDeleteArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserDetail.
     * @param {UserDetailUpdateArgs} args - Arguments to update one UserDetail.
     * @example
     * // Update one UserDetail
     * const userDetail = await prisma.userDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDetailUpdateArgs>(args: SelectSubset<T, UserDetailUpdateArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserDetails.
     * @param {UserDetailDeleteManyArgs} args - Arguments to filter UserDetails to delete.
     * @example
     * // Delete a few UserDetails
     * const { count } = await prisma.userDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDetailDeleteManyArgs>(args?: SelectSubset<T, UserDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDetails
     * const userDetail = await prisma.userDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDetailUpdateManyArgs>(args: SelectSubset<T, UserDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDetail.
     * @param {UserDetailUpsertArgs} args - Arguments to update or create a UserDetail.
     * @example
     * // Update or create a UserDetail
     * const userDetail = await prisma.userDetail.upsert({
     *   create: {
     *     // ... data to create a UserDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDetail we want to update
     *   }
     * })
     */
    upsert<T extends UserDetailUpsertArgs>(args: SelectSubset<T, UserDetailUpsertArgs<ExtArgs>>): Prisma__UserDetailClient<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailCountArgs} args - Arguments to filter UserDetails to count.
     * @example
     * // Count the number of UserDetails
     * const count = await prisma.userDetail.count({
     *   where: {
     *     // ... the filter for the UserDetails we want to count
     *   }
     * })
    **/
    count<T extends UserDetailCountArgs>(
      args?: Subset<T, UserDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDetailAggregateArgs>(args: Subset<T, UserDetailAggregateArgs>): Prisma.PrismaPromise<GetUserDetailAggregateType<T>>

    /**
     * Group by UserDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDetailGroupByArgs['orderBy'] }
        : { orderBy?: UserDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDetail model
   */
  readonly fields: UserDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDetail$userArgs<ExtArgs> = {}>(args?: Subset<T, UserDetail$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    municipality<T extends MunicipalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipalityDefaultArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDetail model
   */ 
  interface UserDetailFieldRefs {
    readonly id: FieldRef<"UserDetail", 'String'>
    readonly gender: FieldRef<"UserDetail", 'String'>
    readonly birthDate: FieldRef<"UserDetail", 'DateTime'>
    readonly municipalityId: FieldRef<"UserDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserDetail findUnique
   */
  export type UserDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter, which UserDetail to fetch.
     */
    where: UserDetailWhereUniqueInput
  }

  /**
   * UserDetail findUniqueOrThrow
   */
  export type UserDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter, which UserDetail to fetch.
     */
    where: UserDetailWhereUniqueInput
  }

  /**
   * UserDetail findFirst
   */
  export type UserDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter, which UserDetail to fetch.
     */
    where?: UserDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailOrderByWithRelationInput | UserDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDetails.
     */
    cursor?: UserDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDetails.
     */
    distinct?: UserDetailScalarFieldEnum | UserDetailScalarFieldEnum[]
  }

  /**
   * UserDetail findFirstOrThrow
   */
  export type UserDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter, which UserDetail to fetch.
     */
    where?: UserDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailOrderByWithRelationInput | UserDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDetails.
     */
    cursor?: UserDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDetails.
     */
    distinct?: UserDetailScalarFieldEnum | UserDetailScalarFieldEnum[]
  }

  /**
   * UserDetail findMany
   */
  export type UserDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter, which UserDetails to fetch.
     */
    where?: UserDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDetails to fetch.
     */
    orderBy?: UserDetailOrderByWithRelationInput | UserDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDetails.
     */
    cursor?: UserDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDetails.
     */
    skip?: number
    distinct?: UserDetailScalarFieldEnum | UserDetailScalarFieldEnum[]
  }

  /**
   * UserDetail create
   */
  export type UserDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDetail.
     */
    data: XOR<UserDetailCreateInput, UserDetailUncheckedCreateInput>
  }

  /**
   * UserDetail createMany
   */
  export type UserDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDetails.
     */
    data: UserDetailCreateManyInput | UserDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDetail createManyAndReturn
   */
  export type UserDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserDetails.
     */
    data: UserDetailCreateManyInput | UserDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDetail update
   */
  export type UserDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDetail.
     */
    data: XOR<UserDetailUpdateInput, UserDetailUncheckedUpdateInput>
    /**
     * Choose, which UserDetail to update.
     */
    where: UserDetailWhereUniqueInput
  }

  /**
   * UserDetail updateMany
   */
  export type UserDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDetails.
     */
    data: XOR<UserDetailUpdateManyMutationInput, UserDetailUncheckedUpdateManyInput>
    /**
     * Filter which UserDetails to update
     */
    where?: UserDetailWhereInput
  }

  /**
   * UserDetail upsert
   */
  export type UserDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDetail to update in case it exists.
     */
    where: UserDetailWhereUniqueInput
    /**
     * In case the UserDetail found by the `where` argument doesn't exist, create a new UserDetail with this data.
     */
    create: XOR<UserDetailCreateInput, UserDetailUncheckedCreateInput>
    /**
     * In case the UserDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDetailUpdateInput, UserDetailUncheckedUpdateInput>
  }

  /**
   * UserDetail delete
   */
  export type UserDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    /**
     * Filter which UserDetail to delete.
     */
    where: UserDetailWhereUniqueInput
  }

  /**
   * UserDetail deleteMany
   */
  export type UserDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDetails to delete
     */
    where?: UserDetailWhereInput
  }

  /**
   * UserDetail.user
   */
  export type UserDetail$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserDetail without action
   */
  export type UserDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    municipalities?: boolean | Department$municipalitiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipalities?: boolean | Department$municipalitiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      municipalities: Prisma.$MunicipalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipalities<T extends Department$municipalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Department$municipalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.municipalities
   */
  export type Department$municipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    cursor?: MunicipalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Municipality
   */

  export type AggregateMunicipality = {
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  export type MunicipalityAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type MunicipalitySumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type MunicipalityMinAggregateOutputType = {
    id: number | null
    name: string | null
    departmentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MunicipalityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    departmentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MunicipalityCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MunicipalityAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type MunicipalitySumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type MunicipalityMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MunicipalityMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MunicipalityCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MunicipalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipality to aggregate.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipalities
    **/
    _count?: true | MunicipalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalityMaxAggregateInputType
  }

  export type GetMunicipalityAggregateType<T extends MunicipalityAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipality[P]>
      : GetScalarType<T[P], AggregateMunicipality[P]>
  }




  export type MunicipalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithAggregationInput | MunicipalityOrderByWithAggregationInput[]
    by: MunicipalityScalarFieldEnum[] | MunicipalityScalarFieldEnum
    having?: MunicipalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalityCountAggregateInputType | true
    _avg?: MunicipalityAvgAggregateInputType
    _sum?: MunicipalitySumAggregateInputType
    _min?: MunicipalityMinAggregateInputType
    _max?: MunicipalityMaxAggregateInputType
  }

  export type MunicipalityGroupByOutputType = {
    id: number
    name: string
    departmentId: number
    createdAt: Date
    updatedAt: Date
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  type GetMunicipalityGroupByPayload<T extends MunicipalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
        }
      >
    >


  export type MunicipalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Department?: boolean | Municipality$DepartmentArgs<ExtArgs>
    UserDetail?: boolean | Municipality$UserDetailArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Department?: boolean | Municipality$DepartmentArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MunicipalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Department?: boolean | Municipality$DepartmentArgs<ExtArgs>
    UserDetail?: boolean | Municipality$UserDetailArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Department?: boolean | Municipality$DepartmentArgs<ExtArgs>
  }

  export type $MunicipalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipality"
    objects: {
      Department: Prisma.$DepartmentPayload<ExtArgs> | null
      UserDetail: Prisma.$UserDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      departmentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["municipality"]>
    composites: {}
  }

  type MunicipalityGetPayload<S extends boolean | null | undefined | MunicipalityDefaultArgs> = $Result.GetResult<Prisma.$MunicipalityPayload, S>

  type MunicipalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipalityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipalityCountAggregateInputType | true
    }

  export interface MunicipalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipality'], meta: { name: 'Municipality' } }
    /**
     * Find zero or one Municipality that matches the filter.
     * @param {MunicipalityFindUniqueArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipalityFindUniqueArgs>(args: SelectSubset<T, MunicipalityFindUniqueArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipalityFindUniqueOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipalityFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipalityFindFirstArgs>(args?: SelectSubset<T, MunicipalityFindFirstArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipalityFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipalities
     * const municipalities = await prisma.municipality.findMany()
     * 
     * // Get first 10 Municipalities
     * const municipalities = await prisma.municipality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalityWithIdOnly = await prisma.municipality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MunicipalityFindManyArgs>(args?: SelectSubset<T, MunicipalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipality.
     * @param {MunicipalityCreateArgs} args - Arguments to create a Municipality.
     * @example
     * // Create one Municipality
     * const Municipality = await prisma.municipality.create({
     *   data: {
     *     // ... data to create a Municipality
     *   }
     * })
     * 
     */
    create<T extends MunicipalityCreateArgs>(args: SelectSubset<T, MunicipalityCreateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipalities.
     * @param {MunicipalityCreateManyArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipalityCreateManyArgs>(args?: SelectSubset<T, MunicipalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Municipalities and returns the data saved in the database.
     * @param {MunicipalityCreateManyAndReturnArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MunicipalityCreateManyAndReturnArgs>(args?: SelectSubset<T, MunicipalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Municipality.
     * @param {MunicipalityDeleteArgs} args - Arguments to delete one Municipality.
     * @example
     * // Delete one Municipality
     * const Municipality = await prisma.municipality.delete({
     *   where: {
     *     // ... filter to delete one Municipality
     *   }
     * })
     * 
     */
    delete<T extends MunicipalityDeleteArgs>(args: SelectSubset<T, MunicipalityDeleteArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipality.
     * @param {MunicipalityUpdateArgs} args - Arguments to update one Municipality.
     * @example
     * // Update one Municipality
     * const municipality = await prisma.municipality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipalityUpdateArgs>(args: SelectSubset<T, MunicipalityUpdateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipalities.
     * @param {MunicipalityDeleteManyArgs} args - Arguments to filter Municipalities to delete.
     * @example
     * // Delete a few Municipalities
     * const { count } = await prisma.municipality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipalityDeleteManyArgs>(args?: SelectSubset<T, MunicipalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipalityUpdateManyArgs>(args: SelectSubset<T, MunicipalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipality.
     * @param {MunicipalityUpsertArgs} args - Arguments to update or create a Municipality.
     * @example
     * // Update or create a Municipality
     * const municipality = await prisma.municipality.upsert({
     *   create: {
     *     // ... data to create a Municipality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipality we want to update
     *   }
     * })
     */
    upsert<T extends MunicipalityUpsertArgs>(args: SelectSubset<T, MunicipalityUpsertArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityCountArgs} args - Arguments to filter Municipalities to count.
     * @example
     * // Count the number of Municipalities
     * const count = await prisma.municipality.count({
     *   where: {
     *     // ... the filter for the Municipalities we want to count
     *   }
     * })
    **/
    count<T extends MunicipalityCountArgs>(
      args?: Subset<T, MunicipalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalityAggregateArgs>(args: Subset<T, MunicipalityAggregateArgs>): Prisma.PrismaPromise<GetMunicipalityAggregateType<T>>

    /**
     * Group by Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipalityGroupByArgs['orderBy'] }
        : { orderBy?: MunicipalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipality model
   */
  readonly fields: MunicipalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Department<T extends Municipality$DepartmentArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$DepartmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    UserDetail<T extends Municipality$UserDetailArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$UserDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipality model
   */ 
  interface MunicipalityFieldRefs {
    readonly id: FieldRef<"Municipality", 'Int'>
    readonly name: FieldRef<"Municipality", 'String'>
    readonly departmentId: FieldRef<"Municipality", 'Int'>
    readonly createdAt: FieldRef<"Municipality", 'DateTime'>
    readonly updatedAt: FieldRef<"Municipality", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Municipality findUnique
   */
  export type MunicipalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findUniqueOrThrow
   */
  export type MunicipalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findFirst
   */
  export type MunicipalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findFirstOrThrow
   */
  export type MunicipalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findMany
   */
  export type MunicipalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipalities to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality create
   */
  export type MunicipalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipality.
     */
    data: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
  }

  /**
   * Municipality createMany
   */
  export type MunicipalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipality createManyAndReturn
   */
  export type MunicipalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Municipality update
   */
  export type MunicipalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipality.
     */
    data: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
    /**
     * Choose, which Municipality to update.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality updateMany
   */
  export type MunicipalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
  }

  /**
   * Municipality upsert
   */
  export type MunicipalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipality to update in case it exists.
     */
    where: MunicipalityWhereUniqueInput
    /**
     * In case the Municipality found by the `where` argument doesn't exist, create a new Municipality with this data.
     */
    create: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
    /**
     * In case the Municipality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
  }

  /**
   * Municipality delete
   */
  export type MunicipalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter which Municipality to delete.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality deleteMany
   */
  export type MunicipalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipalities to delete
     */
    where?: MunicipalityWhereInput
  }

  /**
   * Municipality.Department
   */
  export type Municipality$DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Municipality.UserDetail
   */
  export type Municipality$UserDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDetail
     */
    select?: UserDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDetailInclude<ExtArgs> | null
    where?: UserDetailWhereInput
    orderBy?: UserDetailOrderByWithRelationInput | UserDetailOrderByWithRelationInput[]
    cursor?: UserDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDetailScalarFieldEnum | UserDetailScalarFieldEnum[]
  }

  /**
   * Municipality without action
   */
  export type MunicipalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    publicationId: number
    body: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    publicationId: string
    body: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      VenturePublication: Prisma.$VenturePublicationPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      publicationId: string
      body: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VenturePublication<T extends VenturePublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublicationDefaultArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly publicationId: FieldRef<"Comment", 'String'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model EventCategory
   */

  export type AggregateEventCategory = {
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  export type EventCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategory to aggregate.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCategories
    **/
    _count?: true | EventCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCategoryMaxAggregateInputType
  }

  export type GetEventCategoryAggregateType<T extends EventCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCategory[P]>
      : GetScalarType<T[P], AggregateEventCategory[P]>
  }




  export type EventCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoryWhereInput
    orderBy?: EventCategoryOrderByWithAggregationInput | EventCategoryOrderByWithAggregationInput[]
    by: EventCategoryScalarFieldEnum[] | EventCategoryScalarFieldEnum
    having?: EventCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCategoryCountAggregateInputType | true
    _min?: EventCategoryMinAggregateInputType
    _max?: EventCategoryMaxAggregateInputType
  }

  export type EventCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  type GetEventCategoryGroupByPayload<T extends EventCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
        }
      >
    >


  export type EventCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    XEventCategory?: boolean | EventCategory$XEventCategoryArgs<ExtArgs>
    VentureEvent?: boolean | EventCategory$VentureEventArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategory"]>

  export type EventCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["eventCategory"]>

  export type EventCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    XEventCategory?: boolean | EventCategory$XEventCategoryArgs<ExtArgs>
    VentureEvent?: boolean | EventCategory$VentureEventArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCategory"
    objects: {
      XEventCategory: Prisma.$XEventCategoryPayload<ExtArgs>[]
      VentureEvent: Prisma.$VentureEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventCategory"]>
    composites: {}
  }

  type EventCategoryGetPayload<S extends boolean | null | undefined | EventCategoryDefaultArgs> = $Result.GetResult<Prisma.$EventCategoryPayload, S>

  type EventCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCategoryCountAggregateInputType | true
    }

  export interface EventCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCategory'], meta: { name: 'EventCategory' } }
    /**
     * Find zero or one EventCategory that matches the filter.
     * @param {EventCategoryFindUniqueArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCategoryFindUniqueArgs>(args: SelectSubset<T, EventCategoryFindUniqueArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventCategoryFindUniqueOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCategoryFindFirstArgs>(args?: SelectSubset<T, EventCategoryFindFirstArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCategories
     * const eventCategories = await prisma.eventCategory.findMany()
     * 
     * // Get first 10 EventCategories
     * const eventCategories = await prisma.eventCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCategoryWithIdOnly = await prisma.eventCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCategoryFindManyArgs>(args?: SelectSubset<T, EventCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventCategory.
     * @param {EventCategoryCreateArgs} args - Arguments to create a EventCategory.
     * @example
     * // Create one EventCategory
     * const EventCategory = await prisma.eventCategory.create({
     *   data: {
     *     // ... data to create a EventCategory
     *   }
     * })
     * 
     */
    create<T extends EventCategoryCreateArgs>(args: SelectSubset<T, EventCategoryCreateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventCategories.
     * @param {EventCategoryCreateManyArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategory = await prisma.eventCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCategoryCreateManyArgs>(args?: SelectSubset<T, EventCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventCategories and returns the data saved in the database.
     * @param {EventCategoryCreateManyAndReturnArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategory = await prisma.eventCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventCategories and only return the `id`
     * const eventCategoryWithIdOnly = await prisma.eventCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventCategory.
     * @param {EventCategoryDeleteArgs} args - Arguments to delete one EventCategory.
     * @example
     * // Delete one EventCategory
     * const EventCategory = await prisma.eventCategory.delete({
     *   where: {
     *     // ... filter to delete one EventCategory
     *   }
     * })
     * 
     */
    delete<T extends EventCategoryDeleteArgs>(args: SelectSubset<T, EventCategoryDeleteArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventCategory.
     * @param {EventCategoryUpdateArgs} args - Arguments to update one EventCategory.
     * @example
     * // Update one EventCategory
     * const eventCategory = await prisma.eventCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCategoryUpdateArgs>(args: SelectSubset<T, EventCategoryUpdateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventCategories.
     * @param {EventCategoryDeleteManyArgs} args - Arguments to filter EventCategories to delete.
     * @example
     * // Delete a few EventCategories
     * const { count } = await prisma.eventCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCategoryDeleteManyArgs>(args?: SelectSubset<T, EventCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCategories
     * const eventCategory = await prisma.eventCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCategoryUpdateManyArgs>(args: SelectSubset<T, EventCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventCategory.
     * @param {EventCategoryUpsertArgs} args - Arguments to update or create a EventCategory.
     * @example
     * // Update or create a EventCategory
     * const eventCategory = await prisma.eventCategory.upsert({
     *   create: {
     *     // ... data to create a EventCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCategory we want to update
     *   }
     * })
     */
    upsert<T extends EventCategoryUpsertArgs>(args: SelectSubset<T, EventCategoryUpsertArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryCountArgs} args - Arguments to filter EventCategories to count.
     * @example
     * // Count the number of EventCategories
     * const count = await prisma.eventCategory.count({
     *   where: {
     *     // ... the filter for the EventCategories we want to count
     *   }
     * })
    **/
    count<T extends EventCategoryCountArgs>(
      args?: Subset<T, EventCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCategoryAggregateArgs>(args: Subset<T, EventCategoryAggregateArgs>): Prisma.PrismaPromise<GetEventCategoryAggregateType<T>>

    /**
     * Group by EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCategoryGroupByArgs['orderBy'] }
        : { orderBy?: EventCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCategory model
   */
  readonly fields: EventCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    XEventCategory<T extends EventCategory$XEventCategoryArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$XEventCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    VentureEvent<T extends EventCategory$VentureEventArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$VentureEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCategory model
   */ 
  interface EventCategoryFieldRefs {
    readonly id: FieldRef<"EventCategory", 'String'>
    readonly name: FieldRef<"EventCategory", 'String'>
    readonly slug: FieldRef<"EventCategory", 'String'>
    readonly description: FieldRef<"EventCategory", 'String'>
    readonly createdAt: FieldRef<"EventCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"EventCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventCategory findUnique
   */
  export type EventCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findUniqueOrThrow
   */
  export type EventCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findFirst
   */
  export type EventCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findFirstOrThrow
   */
  export type EventCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findMany
   */
  export type EventCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory create
   */
  export type EventCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCategory.
     */
    data: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
  }

  /**
   * EventCategory createMany
   */
  export type EventCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoryCreateManyInput | EventCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCategory createManyAndReturn
   */
  export type EventCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoryCreateManyInput | EventCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCategory update
   */
  export type EventCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCategory.
     */
    data: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
    /**
     * Choose, which EventCategory to update.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory updateMany
   */
  export type EventCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCategories.
     */
    data: XOR<EventCategoryUpdateManyMutationInput, EventCategoryUncheckedUpdateManyInput>
    /**
     * Filter which EventCategories to update
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory upsert
   */
  export type EventCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCategory to update in case it exists.
     */
    where: EventCategoryWhereUniqueInput
    /**
     * In case the EventCategory found by the `where` argument doesn't exist, create a new EventCategory with this data.
     */
    create: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
    /**
     * In case the EventCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
  }

  /**
   * EventCategory delete
   */
  export type EventCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter which EventCategory to delete.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory deleteMany
   */
  export type EventCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategories to delete
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory.XEventCategory
   */
  export type EventCategory$XEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    where?: XEventCategoryWhereInput
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    cursor?: XEventCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XEventCategoryScalarFieldEnum | XEventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory.VentureEvent
   */
  export type EventCategory$VentureEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    where?: VentureEventWhereInput
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    cursor?: VentureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureEventScalarFieldEnum | VentureEventScalarFieldEnum[]
  }

  /**
   * EventCategory without action
   */
  export type EventCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
  }


  /**
   * Model EventDonation
   */

  export type AggregateEventDonation = {
    _count: EventDonationCountAggregateOutputType | null
    _avg: EventDonationAvgAggregateOutputType | null
    _sum: EventDonationSumAggregateOutputType | null
    _min: EventDonationMinAggregateOutputType | null
    _max: EventDonationMaxAggregateOutputType | null
  }

  export type EventDonationAvgAggregateOutputType = {
    amount: number | null
  }

  export type EventDonationSumAggregateOutputType = {
    amount: number | null
  }

  export type EventDonationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventId: string | null
    amount: number | null
    currency: string | null
    createdAt: Date | null
  }

  export type EventDonationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventId: string | null
    amount: number | null
    currency: string | null
    createdAt: Date | null
  }

  export type EventDonationCountAggregateOutputType = {
    id: number
    userId: number
    eventId: number
    amount: number
    currency: number
    createdAt: number
    _all: number
  }


  export type EventDonationAvgAggregateInputType = {
    amount?: true
  }

  export type EventDonationSumAggregateInputType = {
    amount?: true
  }

  export type EventDonationMinAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    amount?: true
    currency?: true
    createdAt?: true
  }

  export type EventDonationMaxAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    amount?: true
    currency?: true
    createdAt?: true
  }

  export type EventDonationCountAggregateInputType = {
    id?: true
    userId?: true
    eventId?: true
    amount?: true
    currency?: true
    createdAt?: true
    _all?: true
  }

  export type EventDonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventDonation to aggregate.
     */
    where?: EventDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDonations to fetch.
     */
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventDonations
    **/
    _count?: true | EventDonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventDonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventDonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventDonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventDonationMaxAggregateInputType
  }

  export type GetEventDonationAggregateType<T extends EventDonationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventDonation[P]>
      : GetScalarType<T[P], AggregateEventDonation[P]>
  }




  export type EventDonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventDonationWhereInput
    orderBy?: EventDonationOrderByWithAggregationInput | EventDonationOrderByWithAggregationInput[]
    by: EventDonationScalarFieldEnum[] | EventDonationScalarFieldEnum
    having?: EventDonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventDonationCountAggregateInputType | true
    _avg?: EventDonationAvgAggregateInputType
    _sum?: EventDonationSumAggregateInputType
    _min?: EventDonationMinAggregateInputType
    _max?: EventDonationMaxAggregateInputType
  }

  export type EventDonationGroupByOutputType = {
    id: string
    userId: string
    eventId: string
    amount: number
    currency: string
    createdAt: Date
    _count: EventDonationCountAggregateOutputType | null
    _avg: EventDonationAvgAggregateOutputType | null
    _sum: EventDonationSumAggregateOutputType | null
    _min: EventDonationMinAggregateOutputType | null
    _max: EventDonationMaxAggregateOutputType | null
  }

  type GetEventDonationGroupByPayload<T extends EventDonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventDonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventDonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventDonationGroupByOutputType[P]>
            : GetScalarType<T[P], EventDonationGroupByOutputType[P]>
        }
      >
    >


  export type EventDonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventDonation"]>

  export type EventDonationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventDonation"]>

  export type EventDonationSelectScalar = {
    id?: boolean
    userId?: boolean
    eventId?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
  }

  export type EventDonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventDonationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventDonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventDonation"
    objects: {
      VentureEvent: Prisma.$VentureEventPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventId: string
      amount: number
      currency: string
      createdAt: Date
    }, ExtArgs["result"]["eventDonation"]>
    composites: {}
  }

  type EventDonationGetPayload<S extends boolean | null | undefined | EventDonationDefaultArgs> = $Result.GetResult<Prisma.$EventDonationPayload, S>

  type EventDonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventDonationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventDonationCountAggregateInputType | true
    }

  export interface EventDonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventDonation'], meta: { name: 'EventDonation' } }
    /**
     * Find zero or one EventDonation that matches the filter.
     * @param {EventDonationFindUniqueArgs} args - Arguments to find a EventDonation
     * @example
     * // Get one EventDonation
     * const eventDonation = await prisma.eventDonation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventDonationFindUniqueArgs>(args: SelectSubset<T, EventDonationFindUniqueArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventDonation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventDonationFindUniqueOrThrowArgs} args - Arguments to find a EventDonation
     * @example
     * // Get one EventDonation
     * const eventDonation = await prisma.eventDonation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventDonationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventDonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventDonation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationFindFirstArgs} args - Arguments to find a EventDonation
     * @example
     * // Get one EventDonation
     * const eventDonation = await prisma.eventDonation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventDonationFindFirstArgs>(args?: SelectSubset<T, EventDonationFindFirstArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventDonation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationFindFirstOrThrowArgs} args - Arguments to find a EventDonation
     * @example
     * // Get one EventDonation
     * const eventDonation = await prisma.eventDonation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventDonationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventDonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventDonations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventDonations
     * const eventDonations = await prisma.eventDonation.findMany()
     * 
     * // Get first 10 EventDonations
     * const eventDonations = await prisma.eventDonation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventDonationWithIdOnly = await prisma.eventDonation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventDonationFindManyArgs>(args?: SelectSubset<T, EventDonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventDonation.
     * @param {EventDonationCreateArgs} args - Arguments to create a EventDonation.
     * @example
     * // Create one EventDonation
     * const EventDonation = await prisma.eventDonation.create({
     *   data: {
     *     // ... data to create a EventDonation
     *   }
     * })
     * 
     */
    create<T extends EventDonationCreateArgs>(args: SelectSubset<T, EventDonationCreateArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventDonations.
     * @param {EventDonationCreateManyArgs} args - Arguments to create many EventDonations.
     * @example
     * // Create many EventDonations
     * const eventDonation = await prisma.eventDonation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventDonationCreateManyArgs>(args?: SelectSubset<T, EventDonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventDonations and returns the data saved in the database.
     * @param {EventDonationCreateManyAndReturnArgs} args - Arguments to create many EventDonations.
     * @example
     * // Create many EventDonations
     * const eventDonation = await prisma.eventDonation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventDonations and only return the `id`
     * const eventDonationWithIdOnly = await prisma.eventDonation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventDonationCreateManyAndReturnArgs>(args?: SelectSubset<T, EventDonationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventDonation.
     * @param {EventDonationDeleteArgs} args - Arguments to delete one EventDonation.
     * @example
     * // Delete one EventDonation
     * const EventDonation = await prisma.eventDonation.delete({
     *   where: {
     *     // ... filter to delete one EventDonation
     *   }
     * })
     * 
     */
    delete<T extends EventDonationDeleteArgs>(args: SelectSubset<T, EventDonationDeleteArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventDonation.
     * @param {EventDonationUpdateArgs} args - Arguments to update one EventDonation.
     * @example
     * // Update one EventDonation
     * const eventDonation = await prisma.eventDonation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventDonationUpdateArgs>(args: SelectSubset<T, EventDonationUpdateArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventDonations.
     * @param {EventDonationDeleteManyArgs} args - Arguments to filter EventDonations to delete.
     * @example
     * // Delete a few EventDonations
     * const { count } = await prisma.eventDonation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDonationDeleteManyArgs>(args?: SelectSubset<T, EventDonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventDonations
     * const eventDonation = await prisma.eventDonation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventDonationUpdateManyArgs>(args: SelectSubset<T, EventDonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventDonation.
     * @param {EventDonationUpsertArgs} args - Arguments to update or create a EventDonation.
     * @example
     * // Update or create a EventDonation
     * const eventDonation = await prisma.eventDonation.upsert({
     *   create: {
     *     // ... data to create a EventDonation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventDonation we want to update
     *   }
     * })
     */
    upsert<T extends EventDonationUpsertArgs>(args: SelectSubset<T, EventDonationUpsertArgs<ExtArgs>>): Prisma__EventDonationClient<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationCountArgs} args - Arguments to filter EventDonations to count.
     * @example
     * // Count the number of EventDonations
     * const count = await prisma.eventDonation.count({
     *   where: {
     *     // ... the filter for the EventDonations we want to count
     *   }
     * })
    **/
    count<T extends EventDonationCountArgs>(
      args?: Subset<T, EventDonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventDonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventDonationAggregateArgs>(args: Subset<T, EventDonationAggregateArgs>): Prisma.PrismaPromise<GetEventDonationAggregateType<T>>

    /**
     * Group by EventDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventDonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventDonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventDonationGroupByArgs['orderBy'] }
        : { orderBy?: EventDonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventDonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventDonation model
   */
  readonly fields: EventDonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventDonation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventDonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VentureEvent<T extends VentureEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureEventDefaultArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventDonation model
   */ 
  interface EventDonationFieldRefs {
    readonly id: FieldRef<"EventDonation", 'String'>
    readonly userId: FieldRef<"EventDonation", 'String'>
    readonly eventId: FieldRef<"EventDonation", 'String'>
    readonly amount: FieldRef<"EventDonation", 'Float'>
    readonly currency: FieldRef<"EventDonation", 'String'>
    readonly createdAt: FieldRef<"EventDonation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventDonation findUnique
   */
  export type EventDonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter, which EventDonation to fetch.
     */
    where: EventDonationWhereUniqueInput
  }

  /**
   * EventDonation findUniqueOrThrow
   */
  export type EventDonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter, which EventDonation to fetch.
     */
    where: EventDonationWhereUniqueInput
  }

  /**
   * EventDonation findFirst
   */
  export type EventDonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter, which EventDonation to fetch.
     */
    where?: EventDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDonations to fetch.
     */
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventDonations.
     */
    cursor?: EventDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventDonations.
     */
    distinct?: EventDonationScalarFieldEnum | EventDonationScalarFieldEnum[]
  }

  /**
   * EventDonation findFirstOrThrow
   */
  export type EventDonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter, which EventDonation to fetch.
     */
    where?: EventDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDonations to fetch.
     */
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventDonations.
     */
    cursor?: EventDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventDonations.
     */
    distinct?: EventDonationScalarFieldEnum | EventDonationScalarFieldEnum[]
  }

  /**
   * EventDonation findMany
   */
  export type EventDonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter, which EventDonations to fetch.
     */
    where?: EventDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventDonations to fetch.
     */
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventDonations.
     */
    cursor?: EventDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventDonations.
     */
    skip?: number
    distinct?: EventDonationScalarFieldEnum | EventDonationScalarFieldEnum[]
  }

  /**
   * EventDonation create
   */
  export type EventDonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventDonation.
     */
    data: XOR<EventDonationCreateInput, EventDonationUncheckedCreateInput>
  }

  /**
   * EventDonation createMany
   */
  export type EventDonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventDonations.
     */
    data: EventDonationCreateManyInput | EventDonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventDonation createManyAndReturn
   */
  export type EventDonationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventDonations.
     */
    data: EventDonationCreateManyInput | EventDonationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventDonation update
   */
  export type EventDonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventDonation.
     */
    data: XOR<EventDonationUpdateInput, EventDonationUncheckedUpdateInput>
    /**
     * Choose, which EventDonation to update.
     */
    where: EventDonationWhereUniqueInput
  }

  /**
   * EventDonation updateMany
   */
  export type EventDonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventDonations.
     */
    data: XOR<EventDonationUpdateManyMutationInput, EventDonationUncheckedUpdateManyInput>
    /**
     * Filter which EventDonations to update
     */
    where?: EventDonationWhereInput
  }

  /**
   * EventDonation upsert
   */
  export type EventDonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventDonation to update in case it exists.
     */
    where: EventDonationWhereUniqueInput
    /**
     * In case the EventDonation found by the `where` argument doesn't exist, create a new EventDonation with this data.
     */
    create: XOR<EventDonationCreateInput, EventDonationUncheckedCreateInput>
    /**
     * In case the EventDonation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventDonationUpdateInput, EventDonationUncheckedUpdateInput>
  }

  /**
   * EventDonation delete
   */
  export type EventDonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    /**
     * Filter which EventDonation to delete.
     */
    where: EventDonationWhereUniqueInput
  }

  /**
   * EventDonation deleteMany
   */
  export type EventDonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventDonations to delete
     */
    where?: EventDonationWhereInput
  }

  /**
   * EventDonation without action
   */
  export type EventDonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type LocationSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    ventureEventId: string | null
    lat: number | null
    lng: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    ventureEventId: string | null
    lat: number | null
    lng: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    ventureEventId: number
    lat: number
    lng: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type LocationSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    ventureEventId?: true
    lat?: true
    lng?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    ventureEventId?: true
    lat?: true
    lng?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    ventureEventId?: true
    lat?: true
    lng?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    ventureEventId: string
    lat: number | null
    lng: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ventureEventId?: boolean
    lat?: boolean
    lng?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ventureEventId?: boolean
    lat?: boolean
    lng?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    ventureEventId?: boolean
    lat?: boolean
    lng?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      VentureEvent: Prisma.$VentureEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ventureEventId: string
      lat: number | null
      lng: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VentureEvent<T extends VentureEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureEventDefaultArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly ventureEventId: FieldRef<"Location", 'String'>
    readonly lat: FieldRef<"Location", 'Float'>
    readonly lng: FieldRef<"Location", 'Float'>
    readonly description: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    userId: number
    type: number
    status: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    userId: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      userId: string
      type: $Enums.NotificationType
      status: $Enums.NotificationStatus
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly description: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PublicationClap
   */

  export type AggregatePublicationClap = {
    _count: PublicationClapCountAggregateOutputType | null
    _min: PublicationClapMinAggregateOutputType | null
    _max: PublicationClapMaxAggregateOutputType | null
  }

  export type PublicationClapMinAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    createdAt: Date | null
  }

  export type PublicationClapMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    createdAt: Date | null
  }

  export type PublicationClapCountAggregateOutputType = {
    id: number
    userId: number
    publicationId: number
    createdAt: number
    _all: number
  }


  export type PublicationClapMinAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
  }

  export type PublicationClapMaxAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
  }

  export type PublicationClapCountAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
    _all?: true
  }

  export type PublicationClapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicationClap to aggregate.
     */
    where?: PublicationClapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationClaps to fetch.
     */
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationClapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationClaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationClaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicationClaps
    **/
    _count?: true | PublicationClapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationClapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationClapMaxAggregateInputType
  }

  export type GetPublicationClapAggregateType<T extends PublicationClapAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicationClap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicationClap[P]>
      : GetScalarType<T[P], AggregatePublicationClap[P]>
  }




  export type PublicationClapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationClapWhereInput
    orderBy?: PublicationClapOrderByWithAggregationInput | PublicationClapOrderByWithAggregationInput[]
    by: PublicationClapScalarFieldEnum[] | PublicationClapScalarFieldEnum
    having?: PublicationClapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationClapCountAggregateInputType | true
    _min?: PublicationClapMinAggregateInputType
    _max?: PublicationClapMaxAggregateInputType
  }

  export type PublicationClapGroupByOutputType = {
    id: string
    userId: string
    publicationId: string
    createdAt: Date
    _count: PublicationClapCountAggregateOutputType | null
    _min: PublicationClapMinAggregateOutputType | null
    _max: PublicationClapMaxAggregateOutputType | null
  }

  type GetPublicationClapGroupByPayload<T extends PublicationClapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationClapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationClapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationClapGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationClapGroupByOutputType[P]>
        }
      >
    >


  export type PublicationClapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicationClap"]>

  export type PublicationClapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicationClap"]>

  export type PublicationClapSelectScalar = {
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
  }

  export type PublicationClapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PublicationClapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PublicationClapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicationClap"
    objects: {
      VenturePublication: Prisma.$VenturePublicationPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      publicationId: string
      createdAt: Date
    }, ExtArgs["result"]["publicationClap"]>
    composites: {}
  }

  type PublicationClapGetPayload<S extends boolean | null | undefined | PublicationClapDefaultArgs> = $Result.GetResult<Prisma.$PublicationClapPayload, S>

  type PublicationClapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicationClapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicationClapCountAggregateInputType | true
    }

  export interface PublicationClapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicationClap'], meta: { name: 'PublicationClap' } }
    /**
     * Find zero or one PublicationClap that matches the filter.
     * @param {PublicationClapFindUniqueArgs} args - Arguments to find a PublicationClap
     * @example
     * // Get one PublicationClap
     * const publicationClap = await prisma.publicationClap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationClapFindUniqueArgs>(args: SelectSubset<T, PublicationClapFindUniqueArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PublicationClap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PublicationClapFindUniqueOrThrowArgs} args - Arguments to find a PublicationClap
     * @example
     * // Get one PublicationClap
     * const publicationClap = await prisma.publicationClap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationClapFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationClapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PublicationClap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapFindFirstArgs} args - Arguments to find a PublicationClap
     * @example
     * // Get one PublicationClap
     * const publicationClap = await prisma.publicationClap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationClapFindFirstArgs>(args?: SelectSubset<T, PublicationClapFindFirstArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PublicationClap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapFindFirstOrThrowArgs} args - Arguments to find a PublicationClap
     * @example
     * // Get one PublicationClap
     * const publicationClap = await prisma.publicationClap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationClapFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationClapFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PublicationClaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicationClaps
     * const publicationClaps = await prisma.publicationClap.findMany()
     * 
     * // Get first 10 PublicationClaps
     * const publicationClaps = await prisma.publicationClap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationClapWithIdOnly = await prisma.publicationClap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicationClapFindManyArgs>(args?: SelectSubset<T, PublicationClapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PublicationClap.
     * @param {PublicationClapCreateArgs} args - Arguments to create a PublicationClap.
     * @example
     * // Create one PublicationClap
     * const PublicationClap = await prisma.publicationClap.create({
     *   data: {
     *     // ... data to create a PublicationClap
     *   }
     * })
     * 
     */
    create<T extends PublicationClapCreateArgs>(args: SelectSubset<T, PublicationClapCreateArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PublicationClaps.
     * @param {PublicationClapCreateManyArgs} args - Arguments to create many PublicationClaps.
     * @example
     * // Create many PublicationClaps
     * const publicationClap = await prisma.publicationClap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationClapCreateManyArgs>(args?: SelectSubset<T, PublicationClapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicationClaps and returns the data saved in the database.
     * @param {PublicationClapCreateManyAndReturnArgs} args - Arguments to create many PublicationClaps.
     * @example
     * // Create many PublicationClaps
     * const publicationClap = await prisma.publicationClap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicationClaps and only return the `id`
     * const publicationClapWithIdOnly = await prisma.publicationClap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicationClapCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicationClapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PublicationClap.
     * @param {PublicationClapDeleteArgs} args - Arguments to delete one PublicationClap.
     * @example
     * // Delete one PublicationClap
     * const PublicationClap = await prisma.publicationClap.delete({
     *   where: {
     *     // ... filter to delete one PublicationClap
     *   }
     * })
     * 
     */
    delete<T extends PublicationClapDeleteArgs>(args: SelectSubset<T, PublicationClapDeleteArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PublicationClap.
     * @param {PublicationClapUpdateArgs} args - Arguments to update one PublicationClap.
     * @example
     * // Update one PublicationClap
     * const publicationClap = await prisma.publicationClap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationClapUpdateArgs>(args: SelectSubset<T, PublicationClapUpdateArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PublicationClaps.
     * @param {PublicationClapDeleteManyArgs} args - Arguments to filter PublicationClaps to delete.
     * @example
     * // Delete a few PublicationClaps
     * const { count } = await prisma.publicationClap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationClapDeleteManyArgs>(args?: SelectSubset<T, PublicationClapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicationClaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicationClaps
     * const publicationClap = await prisma.publicationClap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationClapUpdateManyArgs>(args: SelectSubset<T, PublicationClapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PublicationClap.
     * @param {PublicationClapUpsertArgs} args - Arguments to update or create a PublicationClap.
     * @example
     * // Update or create a PublicationClap
     * const publicationClap = await prisma.publicationClap.upsert({
     *   create: {
     *     // ... data to create a PublicationClap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicationClap we want to update
     *   }
     * })
     */
    upsert<T extends PublicationClapUpsertArgs>(args: SelectSubset<T, PublicationClapUpsertArgs<ExtArgs>>): Prisma__PublicationClapClient<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PublicationClaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapCountArgs} args - Arguments to filter PublicationClaps to count.
     * @example
     * // Count the number of PublicationClaps
     * const count = await prisma.publicationClap.count({
     *   where: {
     *     // ... the filter for the PublicationClaps we want to count
     *   }
     * })
    **/
    count<T extends PublicationClapCountArgs>(
      args?: Subset<T, PublicationClapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationClapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicationClap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationClapAggregateArgs>(args: Subset<T, PublicationClapAggregateArgs>): Prisma.PrismaPromise<GetPublicationClapAggregateType<T>>

    /**
     * Group by PublicationClap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationClapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationClapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationClapGroupByArgs['orderBy'] }
        : { orderBy?: PublicationClapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationClapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationClapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicationClap model
   */
  readonly fields: PublicationClapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicationClap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VenturePublication<T extends VenturePublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublicationDefaultArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicationClap model
   */ 
  interface PublicationClapFieldRefs {
    readonly id: FieldRef<"PublicationClap", 'String'>
    readonly userId: FieldRef<"PublicationClap", 'String'>
    readonly publicationId: FieldRef<"PublicationClap", 'String'>
    readonly createdAt: FieldRef<"PublicationClap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicationClap findUnique
   */
  export type PublicationClapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter, which PublicationClap to fetch.
     */
    where: PublicationClapWhereUniqueInput
  }

  /**
   * PublicationClap findUniqueOrThrow
   */
  export type PublicationClapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter, which PublicationClap to fetch.
     */
    where: PublicationClapWhereUniqueInput
  }

  /**
   * PublicationClap findFirst
   */
  export type PublicationClapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter, which PublicationClap to fetch.
     */
    where?: PublicationClapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationClaps to fetch.
     */
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicationClaps.
     */
    cursor?: PublicationClapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationClaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationClaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicationClaps.
     */
    distinct?: PublicationClapScalarFieldEnum | PublicationClapScalarFieldEnum[]
  }

  /**
   * PublicationClap findFirstOrThrow
   */
  export type PublicationClapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter, which PublicationClap to fetch.
     */
    where?: PublicationClapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationClaps to fetch.
     */
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicationClaps.
     */
    cursor?: PublicationClapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationClaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationClaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicationClaps.
     */
    distinct?: PublicationClapScalarFieldEnum | PublicationClapScalarFieldEnum[]
  }

  /**
   * PublicationClap findMany
   */
  export type PublicationClapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter, which PublicationClaps to fetch.
     */
    where?: PublicationClapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationClaps to fetch.
     */
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicationClaps.
     */
    cursor?: PublicationClapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationClaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationClaps.
     */
    skip?: number
    distinct?: PublicationClapScalarFieldEnum | PublicationClapScalarFieldEnum[]
  }

  /**
   * PublicationClap create
   */
  export type PublicationClapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * The data needed to create a PublicationClap.
     */
    data: XOR<PublicationClapCreateInput, PublicationClapUncheckedCreateInput>
  }

  /**
   * PublicationClap createMany
   */
  export type PublicationClapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicationClaps.
     */
    data: PublicationClapCreateManyInput | PublicationClapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublicationClap createManyAndReturn
   */
  export type PublicationClapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PublicationClaps.
     */
    data: PublicationClapCreateManyInput | PublicationClapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicationClap update
   */
  export type PublicationClapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * The data needed to update a PublicationClap.
     */
    data: XOR<PublicationClapUpdateInput, PublicationClapUncheckedUpdateInput>
    /**
     * Choose, which PublicationClap to update.
     */
    where: PublicationClapWhereUniqueInput
  }

  /**
   * PublicationClap updateMany
   */
  export type PublicationClapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicationClaps.
     */
    data: XOR<PublicationClapUpdateManyMutationInput, PublicationClapUncheckedUpdateManyInput>
    /**
     * Filter which PublicationClaps to update
     */
    where?: PublicationClapWhereInput
  }

  /**
   * PublicationClap upsert
   */
  export type PublicationClapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * The filter to search for the PublicationClap to update in case it exists.
     */
    where: PublicationClapWhereUniqueInput
    /**
     * In case the PublicationClap found by the `where` argument doesn't exist, create a new PublicationClap with this data.
     */
    create: XOR<PublicationClapCreateInput, PublicationClapUncheckedCreateInput>
    /**
     * In case the PublicationClap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationClapUpdateInput, PublicationClapUncheckedUpdateInput>
  }

  /**
   * PublicationClap delete
   */
  export type PublicationClapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    /**
     * Filter which PublicationClap to delete.
     */
    where: PublicationClapWhereUniqueInput
  }

  /**
   * PublicationClap deleteMany
   */
  export type PublicationClapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicationClaps to delete
     */
    where?: PublicationClapWhereInput
  }

  /**
   * PublicationClap without action
   */
  export type PublicationClapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
  }


  /**
   * Model PublicationContent
   */

  export type AggregatePublicationContent = {
    _count: PublicationContentCountAggregateOutputType | null
    _min: PublicationContentMinAggregateOutputType | null
    _max: PublicationContentMaxAggregateOutputType | null
  }

  export type PublicationContentMinAggregateOutputType = {
    id: string | null
    type: $Enums.ContentType | null
    content: string | null
    publicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationContentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ContentType | null
    content: string | null
    publicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationContentCountAggregateOutputType = {
    id: number
    type: number
    content: number
    publicationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicationContentMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    publicationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationContentMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    publicationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationContentCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    publicationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicationContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicationContent to aggregate.
     */
    where?: PublicationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationContents to fetch.
     */
    orderBy?: PublicationContentOrderByWithRelationInput | PublicationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicationContents
    **/
    _count?: true | PublicationContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationContentMaxAggregateInputType
  }

  export type GetPublicationContentAggregateType<T extends PublicationContentAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicationContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicationContent[P]>
      : GetScalarType<T[P], AggregatePublicationContent[P]>
  }




  export type PublicationContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationContentWhereInput
    orderBy?: PublicationContentOrderByWithAggregationInput | PublicationContentOrderByWithAggregationInput[]
    by: PublicationContentScalarFieldEnum[] | PublicationContentScalarFieldEnum
    having?: PublicationContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationContentCountAggregateInputType | true
    _min?: PublicationContentMinAggregateInputType
    _max?: PublicationContentMaxAggregateInputType
  }

  export type PublicationContentGroupByOutputType = {
    id: string
    type: $Enums.ContentType
    content: string
    publicationId: string
    createdAt: Date
    updatedAt: Date
    _count: PublicationContentCountAggregateOutputType | null
    _min: PublicationContentMinAggregateOutputType | null
    _max: PublicationContentMaxAggregateOutputType | null
  }

  type GetPublicationContentGroupByPayload<T extends PublicationContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationContentGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationContentGroupByOutputType[P]>
        }
      >
    >


  export type PublicationContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    publicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicationContent"]>

  export type PublicationContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    publicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicationContent"]>

  export type PublicationContentSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    publicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicationContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
  }
  export type PublicationContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VenturePublication?: boolean | VenturePublicationDefaultArgs<ExtArgs>
  }

  export type $PublicationContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicationContent"
    objects: {
      VenturePublication: Prisma.$VenturePublicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ContentType
      content: string
      publicationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publicationContent"]>
    composites: {}
  }

  type PublicationContentGetPayload<S extends boolean | null | undefined | PublicationContentDefaultArgs> = $Result.GetResult<Prisma.$PublicationContentPayload, S>

  type PublicationContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicationContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicationContentCountAggregateInputType | true
    }

  export interface PublicationContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicationContent'], meta: { name: 'PublicationContent' } }
    /**
     * Find zero or one PublicationContent that matches the filter.
     * @param {PublicationContentFindUniqueArgs} args - Arguments to find a PublicationContent
     * @example
     * // Get one PublicationContent
     * const publicationContent = await prisma.publicationContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationContentFindUniqueArgs>(args: SelectSubset<T, PublicationContentFindUniqueArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PublicationContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PublicationContentFindUniqueOrThrowArgs} args - Arguments to find a PublicationContent
     * @example
     * // Get one PublicationContent
     * const publicationContent = await prisma.publicationContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationContentFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PublicationContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentFindFirstArgs} args - Arguments to find a PublicationContent
     * @example
     * // Get one PublicationContent
     * const publicationContent = await prisma.publicationContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationContentFindFirstArgs>(args?: SelectSubset<T, PublicationContentFindFirstArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PublicationContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentFindFirstOrThrowArgs} args - Arguments to find a PublicationContent
     * @example
     * // Get one PublicationContent
     * const publicationContent = await prisma.publicationContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationContentFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PublicationContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicationContents
     * const publicationContents = await prisma.publicationContent.findMany()
     * 
     * // Get first 10 PublicationContents
     * const publicationContents = await prisma.publicationContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationContentWithIdOnly = await prisma.publicationContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicationContentFindManyArgs>(args?: SelectSubset<T, PublicationContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PublicationContent.
     * @param {PublicationContentCreateArgs} args - Arguments to create a PublicationContent.
     * @example
     * // Create one PublicationContent
     * const PublicationContent = await prisma.publicationContent.create({
     *   data: {
     *     // ... data to create a PublicationContent
     *   }
     * })
     * 
     */
    create<T extends PublicationContentCreateArgs>(args: SelectSubset<T, PublicationContentCreateArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PublicationContents.
     * @param {PublicationContentCreateManyArgs} args - Arguments to create many PublicationContents.
     * @example
     * // Create many PublicationContents
     * const publicationContent = await prisma.publicationContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationContentCreateManyArgs>(args?: SelectSubset<T, PublicationContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicationContents and returns the data saved in the database.
     * @param {PublicationContentCreateManyAndReturnArgs} args - Arguments to create many PublicationContents.
     * @example
     * // Create many PublicationContents
     * const publicationContent = await prisma.publicationContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicationContents and only return the `id`
     * const publicationContentWithIdOnly = await prisma.publicationContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicationContentCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicationContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PublicationContent.
     * @param {PublicationContentDeleteArgs} args - Arguments to delete one PublicationContent.
     * @example
     * // Delete one PublicationContent
     * const PublicationContent = await prisma.publicationContent.delete({
     *   where: {
     *     // ... filter to delete one PublicationContent
     *   }
     * })
     * 
     */
    delete<T extends PublicationContentDeleteArgs>(args: SelectSubset<T, PublicationContentDeleteArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PublicationContent.
     * @param {PublicationContentUpdateArgs} args - Arguments to update one PublicationContent.
     * @example
     * // Update one PublicationContent
     * const publicationContent = await prisma.publicationContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationContentUpdateArgs>(args: SelectSubset<T, PublicationContentUpdateArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PublicationContents.
     * @param {PublicationContentDeleteManyArgs} args - Arguments to filter PublicationContents to delete.
     * @example
     * // Delete a few PublicationContents
     * const { count } = await prisma.publicationContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationContentDeleteManyArgs>(args?: SelectSubset<T, PublicationContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicationContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicationContents
     * const publicationContent = await prisma.publicationContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationContentUpdateManyArgs>(args: SelectSubset<T, PublicationContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PublicationContent.
     * @param {PublicationContentUpsertArgs} args - Arguments to update or create a PublicationContent.
     * @example
     * // Update or create a PublicationContent
     * const publicationContent = await prisma.publicationContent.upsert({
     *   create: {
     *     // ... data to create a PublicationContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicationContent we want to update
     *   }
     * })
     */
    upsert<T extends PublicationContentUpsertArgs>(args: SelectSubset<T, PublicationContentUpsertArgs<ExtArgs>>): Prisma__PublicationContentClient<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PublicationContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentCountArgs} args - Arguments to filter PublicationContents to count.
     * @example
     * // Count the number of PublicationContents
     * const count = await prisma.publicationContent.count({
     *   where: {
     *     // ... the filter for the PublicationContents we want to count
     *   }
     * })
    **/
    count<T extends PublicationContentCountArgs>(
      args?: Subset<T, PublicationContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicationContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationContentAggregateArgs>(args: Subset<T, PublicationContentAggregateArgs>): Prisma.PrismaPromise<GetPublicationContentAggregateType<T>>

    /**
     * Group by PublicationContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationContentGroupByArgs['orderBy'] }
        : { orderBy?: PublicationContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicationContent model
   */
  readonly fields: PublicationContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicationContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VenturePublication<T extends VenturePublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublicationDefaultArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicationContent model
   */ 
  interface PublicationContentFieldRefs {
    readonly id: FieldRef<"PublicationContent", 'String'>
    readonly type: FieldRef<"PublicationContent", 'ContentType'>
    readonly content: FieldRef<"PublicationContent", 'String'>
    readonly publicationId: FieldRef<"PublicationContent", 'String'>
    readonly createdAt: FieldRef<"PublicationContent", 'DateTime'>
    readonly updatedAt: FieldRef<"PublicationContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicationContent findUnique
   */
  export type PublicationContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter, which PublicationContent to fetch.
     */
    where: PublicationContentWhereUniqueInput
  }

  /**
   * PublicationContent findUniqueOrThrow
   */
  export type PublicationContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter, which PublicationContent to fetch.
     */
    where: PublicationContentWhereUniqueInput
  }

  /**
   * PublicationContent findFirst
   */
  export type PublicationContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter, which PublicationContent to fetch.
     */
    where?: PublicationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationContents to fetch.
     */
    orderBy?: PublicationContentOrderByWithRelationInput | PublicationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicationContents.
     */
    cursor?: PublicationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicationContents.
     */
    distinct?: PublicationContentScalarFieldEnum | PublicationContentScalarFieldEnum[]
  }

  /**
   * PublicationContent findFirstOrThrow
   */
  export type PublicationContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter, which PublicationContent to fetch.
     */
    where?: PublicationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationContents to fetch.
     */
    orderBy?: PublicationContentOrderByWithRelationInput | PublicationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicationContents.
     */
    cursor?: PublicationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicationContents.
     */
    distinct?: PublicationContentScalarFieldEnum | PublicationContentScalarFieldEnum[]
  }

  /**
   * PublicationContent findMany
   */
  export type PublicationContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter, which PublicationContents to fetch.
     */
    where?: PublicationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicationContents to fetch.
     */
    orderBy?: PublicationContentOrderByWithRelationInput | PublicationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicationContents.
     */
    cursor?: PublicationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicationContents.
     */
    skip?: number
    distinct?: PublicationContentScalarFieldEnum | PublicationContentScalarFieldEnum[]
  }

  /**
   * PublicationContent create
   */
  export type PublicationContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * The data needed to create a PublicationContent.
     */
    data: XOR<PublicationContentCreateInput, PublicationContentUncheckedCreateInput>
  }

  /**
   * PublicationContent createMany
   */
  export type PublicationContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicationContents.
     */
    data: PublicationContentCreateManyInput | PublicationContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublicationContent createManyAndReturn
   */
  export type PublicationContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PublicationContents.
     */
    data: PublicationContentCreateManyInput | PublicationContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicationContent update
   */
  export type PublicationContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * The data needed to update a PublicationContent.
     */
    data: XOR<PublicationContentUpdateInput, PublicationContentUncheckedUpdateInput>
    /**
     * Choose, which PublicationContent to update.
     */
    where: PublicationContentWhereUniqueInput
  }

  /**
   * PublicationContent updateMany
   */
  export type PublicationContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicationContents.
     */
    data: XOR<PublicationContentUpdateManyMutationInput, PublicationContentUncheckedUpdateManyInput>
    /**
     * Filter which PublicationContents to update
     */
    where?: PublicationContentWhereInput
  }

  /**
   * PublicationContent upsert
   */
  export type PublicationContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * The filter to search for the PublicationContent to update in case it exists.
     */
    where: PublicationContentWhereUniqueInput
    /**
     * In case the PublicationContent found by the `where` argument doesn't exist, create a new PublicationContent with this data.
     */
    create: XOR<PublicationContentCreateInput, PublicationContentUncheckedCreateInput>
    /**
     * In case the PublicationContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationContentUpdateInput, PublicationContentUncheckedUpdateInput>
  }

  /**
   * PublicationContent delete
   */
  export type PublicationContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    /**
     * Filter which PublicationContent to delete.
     */
    where: PublicationContentWhereUniqueInput
  }

  /**
   * PublicationContent deleteMany
   */
  export type PublicationContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicationContents to delete
     */
    where?: PublicationContentWhereInput
  }

  /**
   * PublicationContent without action
   */
  export type PublicationContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: $Enums.AppRole | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: $Enums.AppRole | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: $Enums.AppRole
    label: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    XUserRoles?: boolean | Role$XUserRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    XUserRoles?: boolean | Role$XUserRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      XUserRoles: Prisma.$XUserRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: $Enums.AppRole
      label: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    XUserRoles<T extends Role$XUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$XUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'AppRole'>
    readonly label: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.XUserRoles
   */
  export type Role$XUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    where?: XUserRolesWhereInput
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    cursor?: XUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XUserRolesScalarFieldEnum | XUserRolesScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Venture
   */

  export type AggregateVenture = {
    _count: VentureCountAggregateOutputType | null
    _min: VentureMinAggregateOutputType | null
    _max: VentureMaxAggregateOutputType | null
  }

  export type VentureMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    coverPhoto: string | null
    description: string | null
    ownerId: string | null
    active: boolean | null
    verified: boolean | null
    detailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    coverPhoto: string | null
    description: string | null
    ownerId: string | null
    active: boolean | null
    verified: boolean | null
    detailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    coverPhoto: number
    description: number
    ownerId: number
    active: number
    verified: number
    detailId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VentureMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    coverPhoto?: true
    description?: true
    ownerId?: true
    active?: true
    verified?: true
    detailId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    coverPhoto?: true
    description?: true
    ownerId?: true
    active?: true
    verified?: true
    detailId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    coverPhoto?: true
    description?: true
    ownerId?: true
    active?: true
    verified?: true
    detailId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VentureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venture to aggregate.
     */
    where?: VentureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventures to fetch.
     */
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventures
    **/
    _count?: true | VentureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureMaxAggregateInputType
  }

  export type GetVentureAggregateType<T extends VentureAggregateArgs> = {
        [P in keyof T & keyof AggregateVenture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenture[P]>
      : GetScalarType<T[P], AggregateVenture[P]>
  }




  export type VentureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureWhereInput
    orderBy?: VentureOrderByWithAggregationInput | VentureOrderByWithAggregationInput[]
    by: VentureScalarFieldEnum[] | VentureScalarFieldEnum
    having?: VentureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureCountAggregateInputType | true
    _min?: VentureMinAggregateInputType
    _max?: VentureMaxAggregateInputType
  }

  export type VentureGroupByOutputType = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active: boolean
    verified: boolean
    detailId: string
    createdAt: Date
    updatedAt: Date
    _count: VentureCountAggregateOutputType | null
    _min: VentureMinAggregateOutputType | null
    _max: VentureMaxAggregateOutputType | null
  }

  type GetVentureGroupByPayload<T extends VentureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureGroupByOutputType[P]>
            : GetScalarType<T[P], VentureGroupByOutputType[P]>
        }
      >
    >


  export type VentureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    coverPhoto?: boolean
    description?: boolean
    ownerId?: boolean
    active?: boolean
    verified?: boolean
    detailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    categories?: boolean | Venture$categoriesArgs<ExtArgs>
    XVentureVencureCategory?: boolean | Venture$XVentureVencureCategoryArgs<ExtArgs>
    _count?: boolean | VentureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venture"]>

  export type VentureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    coverPhoto?: boolean
    description?: boolean
    ownerId?: boolean
    active?: boolean
    verified?: boolean
    detailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venture"]>

  export type VentureSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    coverPhoto?: boolean
    description?: boolean
    ownerId?: boolean
    active?: boolean
    verified?: boolean
    detailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VentureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    categories?: boolean | Venture$categoriesArgs<ExtArgs>
    XVentureVencureCategory?: boolean | Venture$XVentureVencureCategoryArgs<ExtArgs>
    _count?: boolean | VentureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VentureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VenturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venture"
    objects: {
      detail: Prisma.$VentureDetailPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      categories: Prisma.$VentureCategoryPayload<ExtArgs>[]
      XVentureVencureCategory: Prisma.$XVentureVencureCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      coverPhoto: string
      description: string
      ownerId: string
      active: boolean
      verified: boolean
      detailId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venture"]>
    composites: {}
  }

  type VentureGetPayload<S extends boolean | null | undefined | VentureDefaultArgs> = $Result.GetResult<Prisma.$VenturePayload, S>

  type VentureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureCountAggregateInputType | true
    }

  export interface VentureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venture'], meta: { name: 'Venture' } }
    /**
     * Find zero or one Venture that matches the filter.
     * @param {VentureFindUniqueArgs} args - Arguments to find a Venture
     * @example
     * // Get one Venture
     * const venture = await prisma.venture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureFindUniqueArgs>(args: SelectSubset<T, VentureFindUniqueArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Venture that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureFindUniqueOrThrowArgs} args - Arguments to find a Venture
     * @example
     * // Get one Venture
     * const venture = await prisma.venture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Venture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureFindFirstArgs} args - Arguments to find a Venture
     * @example
     * // Get one Venture
     * const venture = await prisma.venture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureFindFirstArgs>(args?: SelectSubset<T, VentureFindFirstArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Venture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureFindFirstOrThrowArgs} args - Arguments to find a Venture
     * @example
     * // Get one Venture
     * const venture = await prisma.venture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ventures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventures
     * const ventures = await prisma.venture.findMany()
     * 
     * // Get first 10 Ventures
     * const ventures = await prisma.venture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureWithIdOnly = await prisma.venture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureFindManyArgs>(args?: SelectSubset<T, VentureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Venture.
     * @param {VentureCreateArgs} args - Arguments to create a Venture.
     * @example
     * // Create one Venture
     * const Venture = await prisma.venture.create({
     *   data: {
     *     // ... data to create a Venture
     *   }
     * })
     * 
     */
    create<T extends VentureCreateArgs>(args: SelectSubset<T, VentureCreateArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ventures.
     * @param {VentureCreateManyArgs} args - Arguments to create many Ventures.
     * @example
     * // Create many Ventures
     * const venture = await prisma.venture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureCreateManyArgs>(args?: SelectSubset<T, VentureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ventures and returns the data saved in the database.
     * @param {VentureCreateManyAndReturnArgs} args - Arguments to create many Ventures.
     * @example
     * // Create many Ventures
     * const venture = await prisma.venture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ventures and only return the `id`
     * const ventureWithIdOnly = await prisma.venture.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Venture.
     * @param {VentureDeleteArgs} args - Arguments to delete one Venture.
     * @example
     * // Delete one Venture
     * const Venture = await prisma.venture.delete({
     *   where: {
     *     // ... filter to delete one Venture
     *   }
     * })
     * 
     */
    delete<T extends VentureDeleteArgs>(args: SelectSubset<T, VentureDeleteArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Venture.
     * @param {VentureUpdateArgs} args - Arguments to update one Venture.
     * @example
     * // Update one Venture
     * const venture = await prisma.venture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureUpdateArgs>(args: SelectSubset<T, VentureUpdateArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ventures.
     * @param {VentureDeleteManyArgs} args - Arguments to filter Ventures to delete.
     * @example
     * // Delete a few Ventures
     * const { count } = await prisma.venture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureDeleteManyArgs>(args?: SelectSubset<T, VentureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventures
     * const venture = await prisma.venture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureUpdateManyArgs>(args: SelectSubset<T, VentureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venture.
     * @param {VentureUpsertArgs} args - Arguments to update or create a Venture.
     * @example
     * // Update or create a Venture
     * const venture = await prisma.venture.upsert({
     *   create: {
     *     // ... data to create a Venture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venture we want to update
     *   }
     * })
     */
    upsert<T extends VentureUpsertArgs>(args: SelectSubset<T, VentureUpsertArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCountArgs} args - Arguments to filter Ventures to count.
     * @example
     * // Count the number of Ventures
     * const count = await prisma.venture.count({
     *   where: {
     *     // ... the filter for the Ventures we want to count
     *   }
     * })
    **/
    count<T extends VentureCountArgs>(
      args?: Subset<T, VentureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureAggregateArgs>(args: Subset<T, VentureAggregateArgs>): Prisma.PrismaPromise<GetVentureAggregateType<T>>

    /**
     * Group by Venture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureGroupByArgs['orderBy'] }
        : { orderBy?: VentureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venture model
   */
  readonly fields: VentureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detail<T extends VentureDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetailDefaultArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categories<T extends Venture$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Venture$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    XVentureVencureCategory<T extends Venture$XVentureVencureCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Venture$XVentureVencureCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venture model
   */ 
  interface VentureFieldRefs {
    readonly id: FieldRef<"Venture", 'String'>
    readonly name: FieldRef<"Venture", 'String'>
    readonly slug: FieldRef<"Venture", 'String'>
    readonly coverPhoto: FieldRef<"Venture", 'String'>
    readonly description: FieldRef<"Venture", 'String'>
    readonly ownerId: FieldRef<"Venture", 'String'>
    readonly active: FieldRef<"Venture", 'Boolean'>
    readonly verified: FieldRef<"Venture", 'Boolean'>
    readonly detailId: FieldRef<"Venture", 'String'>
    readonly createdAt: FieldRef<"Venture", 'DateTime'>
    readonly updatedAt: FieldRef<"Venture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venture findUnique
   */
  export type VentureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter, which Venture to fetch.
     */
    where: VentureWhereUniqueInput
  }

  /**
   * Venture findUniqueOrThrow
   */
  export type VentureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter, which Venture to fetch.
     */
    where: VentureWhereUniqueInput
  }

  /**
   * Venture findFirst
   */
  export type VentureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter, which Venture to fetch.
     */
    where?: VentureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventures to fetch.
     */
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventures.
     */
    cursor?: VentureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventures.
     */
    distinct?: VentureScalarFieldEnum | VentureScalarFieldEnum[]
  }

  /**
   * Venture findFirstOrThrow
   */
  export type VentureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter, which Venture to fetch.
     */
    where?: VentureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventures to fetch.
     */
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventures.
     */
    cursor?: VentureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventures.
     */
    distinct?: VentureScalarFieldEnum | VentureScalarFieldEnum[]
  }

  /**
   * Venture findMany
   */
  export type VentureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter, which Ventures to fetch.
     */
    where?: VentureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventures to fetch.
     */
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventures.
     */
    cursor?: VentureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventures.
     */
    skip?: number
    distinct?: VentureScalarFieldEnum | VentureScalarFieldEnum[]
  }

  /**
   * Venture create
   */
  export type VentureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * The data needed to create a Venture.
     */
    data: XOR<VentureCreateInput, VentureUncheckedCreateInput>
  }

  /**
   * Venture createMany
   */
  export type VentureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ventures.
     */
    data: VentureCreateManyInput | VentureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venture createManyAndReturn
   */
  export type VentureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ventures.
     */
    data: VentureCreateManyInput | VentureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venture update
   */
  export type VentureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * The data needed to update a Venture.
     */
    data: XOR<VentureUpdateInput, VentureUncheckedUpdateInput>
    /**
     * Choose, which Venture to update.
     */
    where: VentureWhereUniqueInput
  }

  /**
   * Venture updateMany
   */
  export type VentureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ventures.
     */
    data: XOR<VentureUpdateManyMutationInput, VentureUncheckedUpdateManyInput>
    /**
     * Filter which Ventures to update
     */
    where?: VentureWhereInput
  }

  /**
   * Venture upsert
   */
  export type VentureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * The filter to search for the Venture to update in case it exists.
     */
    where: VentureWhereUniqueInput
    /**
     * In case the Venture found by the `where` argument doesn't exist, create a new Venture with this data.
     */
    create: XOR<VentureCreateInput, VentureUncheckedCreateInput>
    /**
     * In case the Venture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureUpdateInput, VentureUncheckedUpdateInput>
  }

  /**
   * Venture delete
   */
  export type VentureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    /**
     * Filter which Venture to delete.
     */
    where: VentureWhereUniqueInput
  }

  /**
   * Venture deleteMany
   */
  export type VentureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventures to delete
     */
    where?: VentureWhereInput
  }

  /**
   * Venture.categories
   */
  export type Venture$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    where?: VentureCategoryWhereInput
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    cursor?: VentureCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureCategoryScalarFieldEnum | VentureCategoryScalarFieldEnum[]
  }

  /**
   * Venture.XVentureVencureCategory
   */
  export type Venture$XVentureVencureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    where?: XVentureVencureCategoryWhereInput
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    cursor?: XVentureVencureCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XVentureVencureCategoryScalarFieldEnum | XVentureVencureCategoryScalarFieldEnum[]
  }

  /**
   * Venture without action
   */
  export type VentureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
  }


  /**
   * Model XVentureVencureCategory
   */

  export type AggregateXVentureVencureCategory = {
    _count: XVentureVencureCategoryCountAggregateOutputType | null
    _min: XVentureVencureCategoryMinAggregateOutputType | null
    _max: XVentureVencureCategoryMaxAggregateOutputType | null
  }

  export type XVentureVencureCategoryMinAggregateOutputType = {
    ventureId: string | null
    categoryId: string | null
  }

  export type XVentureVencureCategoryMaxAggregateOutputType = {
    ventureId: string | null
    categoryId: string | null
  }

  export type XVentureVencureCategoryCountAggregateOutputType = {
    ventureId: number
    categoryId: number
    _all: number
  }


  export type XVentureVencureCategoryMinAggregateInputType = {
    ventureId?: true
    categoryId?: true
  }

  export type XVentureVencureCategoryMaxAggregateInputType = {
    ventureId?: true
    categoryId?: true
  }

  export type XVentureVencureCategoryCountAggregateInputType = {
    ventureId?: true
    categoryId?: true
    _all?: true
  }

  export type XVentureVencureCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XVentureVencureCategory to aggregate.
     */
    where?: XVentureVencureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XVentureVencureCategories to fetch.
     */
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XVentureVencureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XVentureVencureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XVentureVencureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XVentureVencureCategories
    **/
    _count?: true | XVentureVencureCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XVentureVencureCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XVentureVencureCategoryMaxAggregateInputType
  }

  export type GetXVentureVencureCategoryAggregateType<T extends XVentureVencureCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateXVentureVencureCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXVentureVencureCategory[P]>
      : GetScalarType<T[P], AggregateXVentureVencureCategory[P]>
  }




  export type XVentureVencureCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XVentureVencureCategoryWhereInput
    orderBy?: XVentureVencureCategoryOrderByWithAggregationInput | XVentureVencureCategoryOrderByWithAggregationInput[]
    by: XVentureVencureCategoryScalarFieldEnum[] | XVentureVencureCategoryScalarFieldEnum
    having?: XVentureVencureCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XVentureVencureCategoryCountAggregateInputType | true
    _min?: XVentureVencureCategoryMinAggregateInputType
    _max?: XVentureVencureCategoryMaxAggregateInputType
  }

  export type XVentureVencureCategoryGroupByOutputType = {
    ventureId: string
    categoryId: string
    _count: XVentureVencureCategoryCountAggregateOutputType | null
    _min: XVentureVencureCategoryMinAggregateOutputType | null
    _max: XVentureVencureCategoryMaxAggregateOutputType | null
  }

  type GetXVentureVencureCategoryGroupByPayload<T extends XVentureVencureCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XVentureVencureCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XVentureVencureCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XVentureVencureCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], XVentureVencureCategoryGroupByOutputType[P]>
        }
      >
    >


  export type XVentureVencureCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ventureId?: boolean
    categoryId?: boolean
    Venture?: boolean | VentureDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xVentureVencureCategory"]>

  export type XVentureVencureCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ventureId?: boolean
    categoryId?: boolean
    Venture?: boolean | VentureDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xVentureVencureCategory"]>

  export type XVentureVencureCategorySelectScalar = {
    ventureId?: boolean
    categoryId?: boolean
  }

  export type XVentureVencureCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venture?: boolean | VentureDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }
  export type XVentureVencureCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venture?: boolean | VentureDefaultArgs<ExtArgs>
    VentureCategory?: boolean | VentureCategoryDefaultArgs<ExtArgs>
  }

  export type $XVentureVencureCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XVentureVencureCategory"
    objects: {
      Venture: Prisma.$VenturePayload<ExtArgs>
      VentureCategory: Prisma.$VentureCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ventureId: string
      categoryId: string
    }, ExtArgs["result"]["xVentureVencureCategory"]>
    composites: {}
  }

  type XVentureVencureCategoryGetPayload<S extends boolean | null | undefined | XVentureVencureCategoryDefaultArgs> = $Result.GetResult<Prisma.$XVentureVencureCategoryPayload, S>

  type XVentureVencureCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XVentureVencureCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XVentureVencureCategoryCountAggregateInputType | true
    }

  export interface XVentureVencureCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XVentureVencureCategory'], meta: { name: 'XVentureVencureCategory' } }
    /**
     * Find zero or one XVentureVencureCategory that matches the filter.
     * @param {XVentureVencureCategoryFindUniqueArgs} args - Arguments to find a XVentureVencureCategory
     * @example
     * // Get one XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XVentureVencureCategoryFindUniqueArgs>(args: SelectSubset<T, XVentureVencureCategoryFindUniqueArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XVentureVencureCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XVentureVencureCategoryFindUniqueOrThrowArgs} args - Arguments to find a XVentureVencureCategory
     * @example
     * // Get one XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XVentureVencureCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, XVentureVencureCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XVentureVencureCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryFindFirstArgs} args - Arguments to find a XVentureVencureCategory
     * @example
     * // Get one XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XVentureVencureCategoryFindFirstArgs>(args?: SelectSubset<T, XVentureVencureCategoryFindFirstArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XVentureVencureCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryFindFirstOrThrowArgs} args - Arguments to find a XVentureVencureCategory
     * @example
     * // Get one XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XVentureVencureCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, XVentureVencureCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XVentureVencureCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XVentureVencureCategories
     * const xVentureVencureCategories = await prisma.xVentureVencureCategory.findMany()
     * 
     * // Get first 10 XVentureVencureCategories
     * const xVentureVencureCategories = await prisma.xVentureVencureCategory.findMany({ take: 10 })
     * 
     * // Only select the `ventureId`
     * const xVentureVencureCategoryWithVentureIdOnly = await prisma.xVentureVencureCategory.findMany({ select: { ventureId: true } })
     * 
     */
    findMany<T extends XVentureVencureCategoryFindManyArgs>(args?: SelectSubset<T, XVentureVencureCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XVentureVencureCategory.
     * @param {XVentureVencureCategoryCreateArgs} args - Arguments to create a XVentureVencureCategory.
     * @example
     * // Create one XVentureVencureCategory
     * const XVentureVencureCategory = await prisma.xVentureVencureCategory.create({
     *   data: {
     *     // ... data to create a XVentureVencureCategory
     *   }
     * })
     * 
     */
    create<T extends XVentureVencureCategoryCreateArgs>(args: SelectSubset<T, XVentureVencureCategoryCreateArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XVentureVencureCategories.
     * @param {XVentureVencureCategoryCreateManyArgs} args - Arguments to create many XVentureVencureCategories.
     * @example
     * // Create many XVentureVencureCategories
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XVentureVencureCategoryCreateManyArgs>(args?: SelectSubset<T, XVentureVencureCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XVentureVencureCategories and returns the data saved in the database.
     * @param {XVentureVencureCategoryCreateManyAndReturnArgs} args - Arguments to create many XVentureVencureCategories.
     * @example
     * // Create many XVentureVencureCategories
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XVentureVencureCategories and only return the `ventureId`
     * const xVentureVencureCategoryWithVentureIdOnly = await prisma.xVentureVencureCategory.createManyAndReturn({ 
     *   select: { ventureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XVentureVencureCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, XVentureVencureCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XVentureVencureCategory.
     * @param {XVentureVencureCategoryDeleteArgs} args - Arguments to delete one XVentureVencureCategory.
     * @example
     * // Delete one XVentureVencureCategory
     * const XVentureVencureCategory = await prisma.xVentureVencureCategory.delete({
     *   where: {
     *     // ... filter to delete one XVentureVencureCategory
     *   }
     * })
     * 
     */
    delete<T extends XVentureVencureCategoryDeleteArgs>(args: SelectSubset<T, XVentureVencureCategoryDeleteArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XVentureVencureCategory.
     * @param {XVentureVencureCategoryUpdateArgs} args - Arguments to update one XVentureVencureCategory.
     * @example
     * // Update one XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XVentureVencureCategoryUpdateArgs>(args: SelectSubset<T, XVentureVencureCategoryUpdateArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XVentureVencureCategories.
     * @param {XVentureVencureCategoryDeleteManyArgs} args - Arguments to filter XVentureVencureCategories to delete.
     * @example
     * // Delete a few XVentureVencureCategories
     * const { count } = await prisma.xVentureVencureCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XVentureVencureCategoryDeleteManyArgs>(args?: SelectSubset<T, XVentureVencureCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XVentureVencureCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XVentureVencureCategories
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XVentureVencureCategoryUpdateManyArgs>(args: SelectSubset<T, XVentureVencureCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XVentureVencureCategory.
     * @param {XVentureVencureCategoryUpsertArgs} args - Arguments to update or create a XVentureVencureCategory.
     * @example
     * // Update or create a XVentureVencureCategory
     * const xVentureVencureCategory = await prisma.xVentureVencureCategory.upsert({
     *   create: {
     *     // ... data to create a XVentureVencureCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XVentureVencureCategory we want to update
     *   }
     * })
     */
    upsert<T extends XVentureVencureCategoryUpsertArgs>(args: SelectSubset<T, XVentureVencureCategoryUpsertArgs<ExtArgs>>): Prisma__XVentureVencureCategoryClient<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XVentureVencureCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryCountArgs} args - Arguments to filter XVentureVencureCategories to count.
     * @example
     * // Count the number of XVentureVencureCategories
     * const count = await prisma.xVentureVencureCategory.count({
     *   where: {
     *     // ... the filter for the XVentureVencureCategories we want to count
     *   }
     * })
    **/
    count<T extends XVentureVencureCategoryCountArgs>(
      args?: Subset<T, XVentureVencureCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XVentureVencureCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XVentureVencureCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XVentureVencureCategoryAggregateArgs>(args: Subset<T, XVentureVencureCategoryAggregateArgs>): Prisma.PrismaPromise<GetXVentureVencureCategoryAggregateType<T>>

    /**
     * Group by XVentureVencureCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XVentureVencureCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XVentureVencureCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XVentureVencureCategoryGroupByArgs['orderBy'] }
        : { orderBy?: XVentureVencureCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XVentureVencureCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXVentureVencureCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XVentureVencureCategory model
   */
  readonly fields: XVentureVencureCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XVentureVencureCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XVentureVencureCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Venture<T extends VentureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDefaultArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VentureCategory<T extends VentureCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategoryDefaultArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XVentureVencureCategory model
   */ 
  interface XVentureVencureCategoryFieldRefs {
    readonly ventureId: FieldRef<"XVentureVencureCategory", 'String'>
    readonly categoryId: FieldRef<"XVentureVencureCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * XVentureVencureCategory findUnique
   */
  export type XVentureVencureCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XVentureVencureCategory to fetch.
     */
    where: XVentureVencureCategoryWhereUniqueInput
  }

  /**
   * XVentureVencureCategory findUniqueOrThrow
   */
  export type XVentureVencureCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XVentureVencureCategory to fetch.
     */
    where: XVentureVencureCategoryWhereUniqueInput
  }

  /**
   * XVentureVencureCategory findFirst
   */
  export type XVentureVencureCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XVentureVencureCategory to fetch.
     */
    where?: XVentureVencureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XVentureVencureCategories to fetch.
     */
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XVentureVencureCategories.
     */
    cursor?: XVentureVencureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XVentureVencureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XVentureVencureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XVentureVencureCategories.
     */
    distinct?: XVentureVencureCategoryScalarFieldEnum | XVentureVencureCategoryScalarFieldEnum[]
  }

  /**
   * XVentureVencureCategory findFirstOrThrow
   */
  export type XVentureVencureCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XVentureVencureCategory to fetch.
     */
    where?: XVentureVencureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XVentureVencureCategories to fetch.
     */
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XVentureVencureCategories.
     */
    cursor?: XVentureVencureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XVentureVencureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XVentureVencureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XVentureVencureCategories.
     */
    distinct?: XVentureVencureCategoryScalarFieldEnum | XVentureVencureCategoryScalarFieldEnum[]
  }

  /**
   * XVentureVencureCategory findMany
   */
  export type XVentureVencureCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XVentureVencureCategories to fetch.
     */
    where?: XVentureVencureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XVentureVencureCategories to fetch.
     */
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XVentureVencureCategories.
     */
    cursor?: XVentureVencureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XVentureVencureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XVentureVencureCategories.
     */
    skip?: number
    distinct?: XVentureVencureCategoryScalarFieldEnum | XVentureVencureCategoryScalarFieldEnum[]
  }

  /**
   * XVentureVencureCategory create
   */
  export type XVentureVencureCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a XVentureVencureCategory.
     */
    data: XOR<XVentureVencureCategoryCreateInput, XVentureVencureCategoryUncheckedCreateInput>
  }

  /**
   * XVentureVencureCategory createMany
   */
  export type XVentureVencureCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XVentureVencureCategories.
     */
    data: XVentureVencureCategoryCreateManyInput | XVentureVencureCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XVentureVencureCategory createManyAndReturn
   */
  export type XVentureVencureCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XVentureVencureCategories.
     */
    data: XVentureVencureCategoryCreateManyInput | XVentureVencureCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XVentureVencureCategory update
   */
  export type XVentureVencureCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a XVentureVencureCategory.
     */
    data: XOR<XVentureVencureCategoryUpdateInput, XVentureVencureCategoryUncheckedUpdateInput>
    /**
     * Choose, which XVentureVencureCategory to update.
     */
    where: XVentureVencureCategoryWhereUniqueInput
  }

  /**
   * XVentureVencureCategory updateMany
   */
  export type XVentureVencureCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XVentureVencureCategories.
     */
    data: XOR<XVentureVencureCategoryUpdateManyMutationInput, XVentureVencureCategoryUncheckedUpdateManyInput>
    /**
     * Filter which XVentureVencureCategories to update
     */
    where?: XVentureVencureCategoryWhereInput
  }

  /**
   * XVentureVencureCategory upsert
   */
  export type XVentureVencureCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the XVentureVencureCategory to update in case it exists.
     */
    where: XVentureVencureCategoryWhereUniqueInput
    /**
     * In case the XVentureVencureCategory found by the `where` argument doesn't exist, create a new XVentureVencureCategory with this data.
     */
    create: XOR<XVentureVencureCategoryCreateInput, XVentureVencureCategoryUncheckedCreateInput>
    /**
     * In case the XVentureVencureCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XVentureVencureCategoryUpdateInput, XVentureVencureCategoryUncheckedUpdateInput>
  }

  /**
   * XVentureVencureCategory delete
   */
  export type XVentureVencureCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    /**
     * Filter which XVentureVencureCategory to delete.
     */
    where: XVentureVencureCategoryWhereUniqueInput
  }

  /**
   * XVentureVencureCategory deleteMany
   */
  export type XVentureVencureCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XVentureVencureCategories to delete
     */
    where?: XVentureVencureCategoryWhereInput
  }

  /**
   * XVentureVencureCategory without action
   */
  export type XVentureVencureCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
  }


  /**
   * Model VentureCategory
   */

  export type AggregateVentureCategory = {
    _count: VentureCategoryCountAggregateOutputType | null
    _min: VentureCategoryMinAggregateOutputType | null
    _max: VentureCategoryMaxAggregateOutputType | null
  }

  export type VentureCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VentureCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VentureCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureCategory to aggregate.
     */
    where?: VentureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureCategories to fetch.
     */
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VentureCategories
    **/
    _count?: true | VentureCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureCategoryMaxAggregateInputType
  }

  export type GetVentureCategoryAggregateType<T extends VentureCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVentureCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentureCategory[P]>
      : GetScalarType<T[P], AggregateVentureCategory[P]>
  }




  export type VentureCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureCategoryWhereInput
    orderBy?: VentureCategoryOrderByWithAggregationInput | VentureCategoryOrderByWithAggregationInput[]
    by: VentureCategoryScalarFieldEnum[] | VentureCategoryScalarFieldEnum
    having?: VentureCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureCategoryCountAggregateInputType | true
    _min?: VentureCategoryMinAggregateInputType
    _max?: VentureCategoryMaxAggregateInputType
  }

  export type VentureCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: VentureCategoryCountAggregateOutputType | null
    _min: VentureCategoryMinAggregateOutputType | null
    _max: VentureCategoryMaxAggregateOutputType | null
  }

  type GetVentureCategoryGroupByPayload<T extends VentureCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], VentureCategoryGroupByOutputType[P]>
        }
      >
    >


  export type VentureCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | VentureCategory$usersArgs<ExtArgs>
    XUserPreferences?: boolean | VentureCategory$XUserPreferencesArgs<ExtArgs>
    ventures?: boolean | VentureCategory$venturesArgs<ExtArgs>
    XVentureVencureCategory?: boolean | VentureCategory$XVentureVencureCategoryArgs<ExtArgs>
    _count?: boolean | VentureCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureCategory"]>

  export type VentureCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ventureCategory"]>

  export type VentureCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VentureCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | VentureCategory$usersArgs<ExtArgs>
    XUserPreferences?: boolean | VentureCategory$XUserPreferencesArgs<ExtArgs>
    ventures?: boolean | VentureCategory$venturesArgs<ExtArgs>
    XVentureVencureCategory?: boolean | VentureCategory$XVentureVencureCategoryArgs<ExtArgs>
    _count?: boolean | VentureCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VentureCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VentureCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VentureCategory"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      XUserPreferences: Prisma.$XUserPreferencesPayload<ExtArgs>[]
      ventures: Prisma.$VenturePayload<ExtArgs>[]
      XVentureVencureCategory: Prisma.$XVentureVencureCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ventureCategory"]>
    composites: {}
  }

  type VentureCategoryGetPayload<S extends boolean | null | undefined | VentureCategoryDefaultArgs> = $Result.GetResult<Prisma.$VentureCategoryPayload, S>

  type VentureCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureCategoryCountAggregateInputType | true
    }

  export interface VentureCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VentureCategory'], meta: { name: 'VentureCategory' } }
    /**
     * Find zero or one VentureCategory that matches the filter.
     * @param {VentureCategoryFindUniqueArgs} args - Arguments to find a VentureCategory
     * @example
     * // Get one VentureCategory
     * const ventureCategory = await prisma.ventureCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureCategoryFindUniqueArgs>(args: SelectSubset<T, VentureCategoryFindUniqueArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VentureCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureCategoryFindUniqueOrThrowArgs} args - Arguments to find a VentureCategory
     * @example
     * // Get one VentureCategory
     * const ventureCategory = await prisma.ventureCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VentureCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryFindFirstArgs} args - Arguments to find a VentureCategory
     * @example
     * // Get one VentureCategory
     * const ventureCategory = await prisma.ventureCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureCategoryFindFirstArgs>(args?: SelectSubset<T, VentureCategoryFindFirstArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VentureCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryFindFirstOrThrowArgs} args - Arguments to find a VentureCategory
     * @example
     * // Get one VentureCategory
     * const ventureCategory = await prisma.ventureCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VentureCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VentureCategories
     * const ventureCategories = await prisma.ventureCategory.findMany()
     * 
     * // Get first 10 VentureCategories
     * const ventureCategories = await prisma.ventureCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureCategoryWithIdOnly = await prisma.ventureCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureCategoryFindManyArgs>(args?: SelectSubset<T, VentureCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VentureCategory.
     * @param {VentureCategoryCreateArgs} args - Arguments to create a VentureCategory.
     * @example
     * // Create one VentureCategory
     * const VentureCategory = await prisma.ventureCategory.create({
     *   data: {
     *     // ... data to create a VentureCategory
     *   }
     * })
     * 
     */
    create<T extends VentureCategoryCreateArgs>(args: SelectSubset<T, VentureCategoryCreateArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VentureCategories.
     * @param {VentureCategoryCreateManyArgs} args - Arguments to create many VentureCategories.
     * @example
     * // Create many VentureCategories
     * const ventureCategory = await prisma.ventureCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureCategoryCreateManyArgs>(args?: SelectSubset<T, VentureCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VentureCategories and returns the data saved in the database.
     * @param {VentureCategoryCreateManyAndReturnArgs} args - Arguments to create many VentureCategories.
     * @example
     * // Create many VentureCategories
     * const ventureCategory = await prisma.ventureCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VentureCategories and only return the `id`
     * const ventureCategoryWithIdOnly = await prisma.ventureCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VentureCategory.
     * @param {VentureCategoryDeleteArgs} args - Arguments to delete one VentureCategory.
     * @example
     * // Delete one VentureCategory
     * const VentureCategory = await prisma.ventureCategory.delete({
     *   where: {
     *     // ... filter to delete one VentureCategory
     *   }
     * })
     * 
     */
    delete<T extends VentureCategoryDeleteArgs>(args: SelectSubset<T, VentureCategoryDeleteArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VentureCategory.
     * @param {VentureCategoryUpdateArgs} args - Arguments to update one VentureCategory.
     * @example
     * // Update one VentureCategory
     * const ventureCategory = await prisma.ventureCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureCategoryUpdateArgs>(args: SelectSubset<T, VentureCategoryUpdateArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VentureCategories.
     * @param {VentureCategoryDeleteManyArgs} args - Arguments to filter VentureCategories to delete.
     * @example
     * // Delete a few VentureCategories
     * const { count } = await prisma.ventureCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureCategoryDeleteManyArgs>(args?: SelectSubset<T, VentureCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VentureCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VentureCategories
     * const ventureCategory = await prisma.ventureCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureCategoryUpdateManyArgs>(args: SelectSubset<T, VentureCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VentureCategory.
     * @param {VentureCategoryUpsertArgs} args - Arguments to update or create a VentureCategory.
     * @example
     * // Update or create a VentureCategory
     * const ventureCategory = await prisma.ventureCategory.upsert({
     *   create: {
     *     // ... data to create a VentureCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VentureCategory we want to update
     *   }
     * })
     */
    upsert<T extends VentureCategoryUpsertArgs>(args: SelectSubset<T, VentureCategoryUpsertArgs<ExtArgs>>): Prisma__VentureCategoryClient<$Result.GetResult<Prisma.$VentureCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VentureCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryCountArgs} args - Arguments to filter VentureCategories to count.
     * @example
     * // Count the number of VentureCategories
     * const count = await prisma.ventureCategory.count({
     *   where: {
     *     // ... the filter for the VentureCategories we want to count
     *   }
     * })
    **/
    count<T extends VentureCategoryCountArgs>(
      args?: Subset<T, VentureCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VentureCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureCategoryAggregateArgs>(args: Subset<T, VentureCategoryAggregateArgs>): Prisma.PrismaPromise<GetVentureCategoryAggregateType<T>>

    /**
     * Group by VentureCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureCategoryGroupByArgs['orderBy'] }
        : { orderBy?: VentureCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VentureCategory model
   */
  readonly fields: VentureCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VentureCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends VentureCategory$usersArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategory$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    XUserPreferences<T extends VentureCategory$XUserPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategory$XUserPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserPreferencesPayload<ExtArgs>, T, "findMany"> | Null>
    ventures<T extends VentureCategory$venturesArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategory$venturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findMany"> | Null>
    XVentureVencureCategory<T extends VentureCategory$XVentureVencureCategoryArgs<ExtArgs> = {}>(args?: Subset<T, VentureCategory$XVentureVencureCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XVentureVencureCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VentureCategory model
   */ 
  interface VentureCategoryFieldRefs {
    readonly id: FieldRef<"VentureCategory", 'String'>
    readonly name: FieldRef<"VentureCategory", 'String'>
    readonly slug: FieldRef<"VentureCategory", 'String'>
    readonly description: FieldRef<"VentureCategory", 'String'>
    readonly createdAt: FieldRef<"VentureCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"VentureCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VentureCategory findUnique
   */
  export type VentureCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VentureCategory to fetch.
     */
    where: VentureCategoryWhereUniqueInput
  }

  /**
   * VentureCategory findUniqueOrThrow
   */
  export type VentureCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VentureCategory to fetch.
     */
    where: VentureCategoryWhereUniqueInput
  }

  /**
   * VentureCategory findFirst
   */
  export type VentureCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VentureCategory to fetch.
     */
    where?: VentureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureCategories to fetch.
     */
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureCategories.
     */
    cursor?: VentureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureCategories.
     */
    distinct?: VentureCategoryScalarFieldEnum | VentureCategoryScalarFieldEnum[]
  }

  /**
   * VentureCategory findFirstOrThrow
   */
  export type VentureCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VentureCategory to fetch.
     */
    where?: VentureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureCategories to fetch.
     */
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureCategories.
     */
    cursor?: VentureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureCategories.
     */
    distinct?: VentureCategoryScalarFieldEnum | VentureCategoryScalarFieldEnum[]
  }

  /**
   * VentureCategory findMany
   */
  export type VentureCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter, which VentureCategories to fetch.
     */
    where?: VentureCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureCategories to fetch.
     */
    orderBy?: VentureCategoryOrderByWithRelationInput | VentureCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VentureCategories.
     */
    cursor?: VentureCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureCategories.
     */
    skip?: number
    distinct?: VentureCategoryScalarFieldEnum | VentureCategoryScalarFieldEnum[]
  }

  /**
   * VentureCategory create
   */
  export type VentureCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VentureCategory.
     */
    data: XOR<VentureCategoryCreateInput, VentureCategoryUncheckedCreateInput>
  }

  /**
   * VentureCategory createMany
   */
  export type VentureCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VentureCategories.
     */
    data: VentureCategoryCreateManyInput | VentureCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureCategory createManyAndReturn
   */
  export type VentureCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VentureCategories.
     */
    data: VentureCategoryCreateManyInput | VentureCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureCategory update
   */
  export type VentureCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VentureCategory.
     */
    data: XOR<VentureCategoryUpdateInput, VentureCategoryUncheckedUpdateInput>
    /**
     * Choose, which VentureCategory to update.
     */
    where: VentureCategoryWhereUniqueInput
  }

  /**
   * VentureCategory updateMany
   */
  export type VentureCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VentureCategories.
     */
    data: XOR<VentureCategoryUpdateManyMutationInput, VentureCategoryUncheckedUpdateManyInput>
    /**
     * Filter which VentureCategories to update
     */
    where?: VentureCategoryWhereInput
  }

  /**
   * VentureCategory upsert
   */
  export type VentureCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VentureCategory to update in case it exists.
     */
    where: VentureCategoryWhereUniqueInput
    /**
     * In case the VentureCategory found by the `where` argument doesn't exist, create a new VentureCategory with this data.
     */
    create: XOR<VentureCategoryCreateInput, VentureCategoryUncheckedCreateInput>
    /**
     * In case the VentureCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureCategoryUpdateInput, VentureCategoryUncheckedUpdateInput>
  }

  /**
   * VentureCategory delete
   */
  export type VentureCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
    /**
     * Filter which VentureCategory to delete.
     */
    where: VentureCategoryWhereUniqueInput
  }

  /**
   * VentureCategory deleteMany
   */
  export type VentureCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureCategories to delete
     */
    where?: VentureCategoryWhereInput
  }

  /**
   * VentureCategory.users
   */
  export type VentureCategory$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * VentureCategory.XUserPreferences
   */
  export type VentureCategory$XUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserPreferences
     */
    select?: XUserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserPreferencesInclude<ExtArgs> | null
    where?: XUserPreferencesWhereInput
    orderBy?: XUserPreferencesOrderByWithRelationInput | XUserPreferencesOrderByWithRelationInput[]
    cursor?: XUserPreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XUserPreferencesScalarFieldEnum | XUserPreferencesScalarFieldEnum[]
  }

  /**
   * VentureCategory.ventures
   */
  export type VentureCategory$venturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    where?: VentureWhereInput
    orderBy?: VentureOrderByWithRelationInput | VentureOrderByWithRelationInput[]
    cursor?: VentureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureScalarFieldEnum | VentureScalarFieldEnum[]
  }

  /**
   * VentureCategory.XVentureVencureCategory
   */
  export type VentureCategory$XVentureVencureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XVentureVencureCategory
     */
    select?: XVentureVencureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XVentureVencureCategoryInclude<ExtArgs> | null
    where?: XVentureVencureCategoryWhereInput
    orderBy?: XVentureVencureCategoryOrderByWithRelationInput | XVentureVencureCategoryOrderByWithRelationInput[]
    cursor?: XVentureVencureCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XVentureVencureCategoryScalarFieldEnum | XVentureVencureCategoryScalarFieldEnum[]
  }

  /**
   * VentureCategory without action
   */
  export type VentureCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureCategory
     */
    select?: VentureCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureCategoryInclude<ExtArgs> | null
  }


  /**
   * Model VentureDetail
   */

  export type AggregateVentureDetail = {
    _count: VentureDetailCountAggregateOutputType | null
    _min: VentureDetailMinAggregateOutputType | null
    _max: VentureDetailMaxAggregateOutputType | null
  }

  export type VentureDetailMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureDetailMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureDetailCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VentureDetailMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureDetailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureDetailCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VentureDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureDetail to aggregate.
     */
    where?: VentureDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureDetails to fetch.
     */
    orderBy?: VentureDetailOrderByWithRelationInput | VentureDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VentureDetails
    **/
    _count?: true | VentureDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureDetailMaxAggregateInputType
  }

  export type GetVentureDetailAggregateType<T extends VentureDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateVentureDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentureDetail[P]>
      : GetScalarType<T[P], AggregateVentureDetail[P]>
  }




  export type VentureDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureDetailWhereInput
    orderBy?: VentureDetailOrderByWithAggregationInput | VentureDetailOrderByWithAggregationInput[]
    by: VentureDetailScalarFieldEnum[] | VentureDetailScalarFieldEnum
    having?: VentureDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureDetailCountAggregateInputType | true
    _min?: VentureDetailMinAggregateInputType
    _max?: VentureDetailMaxAggregateInputType
  }

  export type VentureDetailGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: VentureDetailCountAggregateOutputType | null
    _min: VentureDetailMinAggregateOutputType | null
    _max: VentureDetailMaxAggregateOutputType | null
  }

  type GetVentureDetailGroupByPayload<T extends VentureDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureDetailGroupByOutputType[P]>
            : GetScalarType<T[P], VentureDetailGroupByOutputType[P]>
        }
      >
    >


  export type VentureDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Venture?: boolean | VentureDetail$VentureArgs<ExtArgs>
    event?: boolean | VentureDetail$eventArgs<ExtArgs>
    publications?: boolean | VentureDetail$publicationsArgs<ExtArgs>
    sponsorship?: boolean | VentureDetail$sponsorshipArgs<ExtArgs>
    subscription?: boolean | VentureDetail$subscriptionArgs<ExtArgs>
    _count?: boolean | VentureDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureDetail"]>

  export type VentureDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ventureDetail"]>

  export type VentureDetailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VentureDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venture?: boolean | VentureDetail$VentureArgs<ExtArgs>
    event?: boolean | VentureDetail$eventArgs<ExtArgs>
    publications?: boolean | VentureDetail$publicationsArgs<ExtArgs>
    sponsorship?: boolean | VentureDetail$sponsorshipArgs<ExtArgs>
    subscription?: boolean | VentureDetail$subscriptionArgs<ExtArgs>
    _count?: boolean | VentureDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VentureDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VentureDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VentureDetail"
    objects: {
      Venture: Prisma.$VenturePayload<ExtArgs> | null
      event: Prisma.$VentureEventPayload<ExtArgs>[]
      publications: Prisma.$VenturePublicationPayload<ExtArgs>[]
      sponsorship: Prisma.$VentureSponsorshipPayload<ExtArgs>[]
      subscription: Prisma.$VentureSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ventureDetail"]>
    composites: {}
  }

  type VentureDetailGetPayload<S extends boolean | null | undefined | VentureDetailDefaultArgs> = $Result.GetResult<Prisma.$VentureDetailPayload, S>

  type VentureDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureDetailCountAggregateInputType | true
    }

  export interface VentureDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VentureDetail'], meta: { name: 'VentureDetail' } }
    /**
     * Find zero or one VentureDetail that matches the filter.
     * @param {VentureDetailFindUniqueArgs} args - Arguments to find a VentureDetail
     * @example
     * // Get one VentureDetail
     * const ventureDetail = await prisma.ventureDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureDetailFindUniqueArgs>(args: SelectSubset<T, VentureDetailFindUniqueArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VentureDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureDetailFindUniqueOrThrowArgs} args - Arguments to find a VentureDetail
     * @example
     * // Get one VentureDetail
     * const ventureDetail = await prisma.ventureDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VentureDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailFindFirstArgs} args - Arguments to find a VentureDetail
     * @example
     * // Get one VentureDetail
     * const ventureDetail = await prisma.ventureDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureDetailFindFirstArgs>(args?: SelectSubset<T, VentureDetailFindFirstArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VentureDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailFindFirstOrThrowArgs} args - Arguments to find a VentureDetail
     * @example
     * // Get one VentureDetail
     * const ventureDetail = await prisma.ventureDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VentureDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VentureDetails
     * const ventureDetails = await prisma.ventureDetail.findMany()
     * 
     * // Get first 10 VentureDetails
     * const ventureDetails = await prisma.ventureDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureDetailWithIdOnly = await prisma.ventureDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureDetailFindManyArgs>(args?: SelectSubset<T, VentureDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VentureDetail.
     * @param {VentureDetailCreateArgs} args - Arguments to create a VentureDetail.
     * @example
     * // Create one VentureDetail
     * const VentureDetail = await prisma.ventureDetail.create({
     *   data: {
     *     // ... data to create a VentureDetail
     *   }
     * })
     * 
     */
    create<T extends VentureDetailCreateArgs>(args: SelectSubset<T, VentureDetailCreateArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VentureDetails.
     * @param {VentureDetailCreateManyArgs} args - Arguments to create many VentureDetails.
     * @example
     * // Create many VentureDetails
     * const ventureDetail = await prisma.ventureDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureDetailCreateManyArgs>(args?: SelectSubset<T, VentureDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VentureDetails and returns the data saved in the database.
     * @param {VentureDetailCreateManyAndReturnArgs} args - Arguments to create many VentureDetails.
     * @example
     * // Create many VentureDetails
     * const ventureDetail = await prisma.ventureDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VentureDetails and only return the `id`
     * const ventureDetailWithIdOnly = await prisma.ventureDetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VentureDetail.
     * @param {VentureDetailDeleteArgs} args - Arguments to delete one VentureDetail.
     * @example
     * // Delete one VentureDetail
     * const VentureDetail = await prisma.ventureDetail.delete({
     *   where: {
     *     // ... filter to delete one VentureDetail
     *   }
     * })
     * 
     */
    delete<T extends VentureDetailDeleteArgs>(args: SelectSubset<T, VentureDetailDeleteArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VentureDetail.
     * @param {VentureDetailUpdateArgs} args - Arguments to update one VentureDetail.
     * @example
     * // Update one VentureDetail
     * const ventureDetail = await prisma.ventureDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureDetailUpdateArgs>(args: SelectSubset<T, VentureDetailUpdateArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VentureDetails.
     * @param {VentureDetailDeleteManyArgs} args - Arguments to filter VentureDetails to delete.
     * @example
     * // Delete a few VentureDetails
     * const { count } = await prisma.ventureDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureDetailDeleteManyArgs>(args?: SelectSubset<T, VentureDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VentureDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VentureDetails
     * const ventureDetail = await prisma.ventureDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureDetailUpdateManyArgs>(args: SelectSubset<T, VentureDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VentureDetail.
     * @param {VentureDetailUpsertArgs} args - Arguments to update or create a VentureDetail.
     * @example
     * // Update or create a VentureDetail
     * const ventureDetail = await prisma.ventureDetail.upsert({
     *   create: {
     *     // ... data to create a VentureDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VentureDetail we want to update
     *   }
     * })
     */
    upsert<T extends VentureDetailUpsertArgs>(args: SelectSubset<T, VentureDetailUpsertArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VentureDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailCountArgs} args - Arguments to filter VentureDetails to count.
     * @example
     * // Count the number of VentureDetails
     * const count = await prisma.ventureDetail.count({
     *   where: {
     *     // ... the filter for the VentureDetails we want to count
     *   }
     * })
    **/
    count<T extends VentureDetailCountArgs>(
      args?: Subset<T, VentureDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VentureDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureDetailAggregateArgs>(args: Subset<T, VentureDetailAggregateArgs>): Prisma.PrismaPromise<GetVentureDetailAggregateType<T>>

    /**
     * Group by VentureDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureDetailGroupByArgs['orderBy'] }
        : { orderBy?: VentureDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VentureDetail model
   */
  readonly fields: VentureDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VentureDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Venture<T extends VentureDetail$VentureArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetail$VentureArgs<ExtArgs>>): Prisma__VentureClient<$Result.GetResult<Prisma.$VenturePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    event<T extends VentureDetail$eventArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetail$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findMany"> | Null>
    publications<T extends VentureDetail$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetail$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findMany"> | Null>
    sponsorship<T extends VentureDetail$sponsorshipArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetail$sponsorshipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends VentureDetail$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetail$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VentureDetail model
   */ 
  interface VentureDetailFieldRefs {
    readonly id: FieldRef<"VentureDetail", 'String'>
    readonly createdAt: FieldRef<"VentureDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"VentureDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VentureDetail findUnique
   */
  export type VentureDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter, which VentureDetail to fetch.
     */
    where: VentureDetailWhereUniqueInput
  }

  /**
   * VentureDetail findUniqueOrThrow
   */
  export type VentureDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter, which VentureDetail to fetch.
     */
    where: VentureDetailWhereUniqueInput
  }

  /**
   * VentureDetail findFirst
   */
  export type VentureDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter, which VentureDetail to fetch.
     */
    where?: VentureDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureDetails to fetch.
     */
    orderBy?: VentureDetailOrderByWithRelationInput | VentureDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureDetails.
     */
    cursor?: VentureDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureDetails.
     */
    distinct?: VentureDetailScalarFieldEnum | VentureDetailScalarFieldEnum[]
  }

  /**
   * VentureDetail findFirstOrThrow
   */
  export type VentureDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter, which VentureDetail to fetch.
     */
    where?: VentureDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureDetails to fetch.
     */
    orderBy?: VentureDetailOrderByWithRelationInput | VentureDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureDetails.
     */
    cursor?: VentureDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureDetails.
     */
    distinct?: VentureDetailScalarFieldEnum | VentureDetailScalarFieldEnum[]
  }

  /**
   * VentureDetail findMany
   */
  export type VentureDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter, which VentureDetails to fetch.
     */
    where?: VentureDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureDetails to fetch.
     */
    orderBy?: VentureDetailOrderByWithRelationInput | VentureDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VentureDetails.
     */
    cursor?: VentureDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureDetails.
     */
    skip?: number
    distinct?: VentureDetailScalarFieldEnum | VentureDetailScalarFieldEnum[]
  }

  /**
   * VentureDetail create
   */
  export type VentureDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a VentureDetail.
     */
    data: XOR<VentureDetailCreateInput, VentureDetailUncheckedCreateInput>
  }

  /**
   * VentureDetail createMany
   */
  export type VentureDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VentureDetails.
     */
    data: VentureDetailCreateManyInput | VentureDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureDetail createManyAndReturn
   */
  export type VentureDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VentureDetails.
     */
    data: VentureDetailCreateManyInput | VentureDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureDetail update
   */
  export type VentureDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a VentureDetail.
     */
    data: XOR<VentureDetailUpdateInput, VentureDetailUncheckedUpdateInput>
    /**
     * Choose, which VentureDetail to update.
     */
    where: VentureDetailWhereUniqueInput
  }

  /**
   * VentureDetail updateMany
   */
  export type VentureDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VentureDetails.
     */
    data: XOR<VentureDetailUpdateManyMutationInput, VentureDetailUncheckedUpdateManyInput>
    /**
     * Filter which VentureDetails to update
     */
    where?: VentureDetailWhereInput
  }

  /**
   * VentureDetail upsert
   */
  export type VentureDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the VentureDetail to update in case it exists.
     */
    where: VentureDetailWhereUniqueInput
    /**
     * In case the VentureDetail found by the `where` argument doesn't exist, create a new VentureDetail with this data.
     */
    create: XOR<VentureDetailCreateInput, VentureDetailUncheckedCreateInput>
    /**
     * In case the VentureDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureDetailUpdateInput, VentureDetailUncheckedUpdateInput>
  }

  /**
   * VentureDetail delete
   */
  export type VentureDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
    /**
     * Filter which VentureDetail to delete.
     */
    where: VentureDetailWhereUniqueInput
  }

  /**
   * VentureDetail deleteMany
   */
  export type VentureDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureDetails to delete
     */
    where?: VentureDetailWhereInput
  }

  /**
   * VentureDetail.Venture
   */
  export type VentureDetail$VentureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venture
     */
    select?: VentureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureInclude<ExtArgs> | null
    where?: VentureWhereInput
  }

  /**
   * VentureDetail.event
   */
  export type VentureDetail$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    where?: VentureEventWhereInput
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    cursor?: VentureEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureEventScalarFieldEnum | VentureEventScalarFieldEnum[]
  }

  /**
   * VentureDetail.publications
   */
  export type VentureDetail$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    where?: VenturePublicationWhereInput
    orderBy?: VenturePublicationOrderByWithRelationInput | VenturePublicationOrderByWithRelationInput[]
    cursor?: VenturePublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenturePublicationScalarFieldEnum | VenturePublicationScalarFieldEnum[]
  }

  /**
   * VentureDetail.sponsorship
   */
  export type VentureDetail$sponsorshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    where?: VentureSponsorshipWhereInput
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    cursor?: VentureSponsorshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureSponsorshipScalarFieldEnum | VentureSponsorshipScalarFieldEnum[]
  }

  /**
   * VentureDetail.subscription
   */
  export type VentureDetail$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    where?: VentureSubscriptionWhereInput
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    cursor?: VentureSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VentureSubscriptionScalarFieldEnum | VentureSubscriptionScalarFieldEnum[]
  }

  /**
   * VentureDetail without action
   */
  export type VentureDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureDetail
     */
    select?: VentureDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureDetailInclude<ExtArgs> | null
  }


  /**
   * Model VentureEvent
   */

  export type AggregateVentureEvent = {
    _count: VentureEventCountAggregateOutputType | null
    _min: VentureEventMinAggregateOutputType | null
    _max: VentureEventMaxAggregateOutputType | null
  }

  export type VentureEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coverPhoto: string | null
    ventureId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coverPhoto: string | null
    ventureId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    coverPhoto: number
    ventureId: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VentureEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverPhoto?: true
    ventureId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverPhoto?: true
    ventureId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverPhoto?: true
    ventureId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VentureEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureEvent to aggregate.
     */
    where?: VentureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureEvents to fetch.
     */
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VentureEvents
    **/
    _count?: true | VentureEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureEventMaxAggregateInputType
  }

  export type GetVentureEventAggregateType<T extends VentureEventAggregateArgs> = {
        [P in keyof T & keyof AggregateVentureEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentureEvent[P]>
      : GetScalarType<T[P], AggregateVentureEvent[P]>
  }




  export type VentureEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureEventWhereInput
    orderBy?: VentureEventOrderByWithAggregationInput | VentureEventOrderByWithAggregationInput[]
    by: VentureEventScalarFieldEnum[] | VentureEventScalarFieldEnum
    having?: VentureEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureEventCountAggregateInputType | true
    _min?: VentureEventMinAggregateInputType
    _max?: VentureEventMaxAggregateInputType
  }

  export type VentureEventGroupByOutputType = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: VentureEventCountAggregateOutputType | null
    _min: VentureEventMinAggregateOutputType | null
    _max: VentureEventMaxAggregateOutputType | null
  }

  type GetVentureEventGroupByPayload<T extends VentureEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureEventGroupByOutputType[P]>
            : GetScalarType<T[P], VentureEventGroupByOutputType[P]>
        }
      >
    >


  export type VentureEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coverPhoto?: boolean
    ventureId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    EventDonation?: boolean | VentureEvent$EventDonationArgs<ExtArgs>
    Location?: boolean | VentureEvent$LocationArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    XEventCategory?: boolean | VentureEvent$XEventCategoryArgs<ExtArgs>
    EventCategory?: boolean | VentureEvent$EventCategoryArgs<ExtArgs>
    _count?: boolean | VentureEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureEvent"]>

  export type VentureEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coverPhoto?: boolean
    ventureId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureEvent"]>

  export type VentureEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    coverPhoto?: boolean
    ventureId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VentureEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventDonation?: boolean | VentureEvent$EventDonationArgs<ExtArgs>
    Location?: boolean | VentureEvent$LocationArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    XEventCategory?: boolean | VentureEvent$XEventCategoryArgs<ExtArgs>
    EventCategory?: boolean | VentureEvent$EventCategoryArgs<ExtArgs>
    _count?: boolean | VentureEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VentureEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }

  export type $VentureEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VentureEvent"
    objects: {
      EventDonation: Prisma.$EventDonationPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
      VentureDetail: Prisma.$VentureDetailPayload<ExtArgs>
      XEventCategory: Prisma.$XEventCategoryPayload<ExtArgs>[]
      EventCategory: Prisma.$EventCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      coverPhoto: string
      ventureId: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ventureEvent"]>
    composites: {}
  }

  type VentureEventGetPayload<S extends boolean | null | undefined | VentureEventDefaultArgs> = $Result.GetResult<Prisma.$VentureEventPayload, S>

  type VentureEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureEventCountAggregateInputType | true
    }

  export interface VentureEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VentureEvent'], meta: { name: 'VentureEvent' } }
    /**
     * Find zero or one VentureEvent that matches the filter.
     * @param {VentureEventFindUniqueArgs} args - Arguments to find a VentureEvent
     * @example
     * // Get one VentureEvent
     * const ventureEvent = await prisma.ventureEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureEventFindUniqueArgs>(args: SelectSubset<T, VentureEventFindUniqueArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VentureEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureEventFindUniqueOrThrowArgs} args - Arguments to find a VentureEvent
     * @example
     * // Get one VentureEvent
     * const ventureEvent = await prisma.ventureEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureEventFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VentureEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventFindFirstArgs} args - Arguments to find a VentureEvent
     * @example
     * // Get one VentureEvent
     * const ventureEvent = await prisma.ventureEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureEventFindFirstArgs>(args?: SelectSubset<T, VentureEventFindFirstArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VentureEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventFindFirstOrThrowArgs} args - Arguments to find a VentureEvent
     * @example
     * // Get one VentureEvent
     * const ventureEvent = await prisma.ventureEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureEventFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VentureEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VentureEvents
     * const ventureEvents = await prisma.ventureEvent.findMany()
     * 
     * // Get first 10 VentureEvents
     * const ventureEvents = await prisma.ventureEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureEventWithIdOnly = await prisma.ventureEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureEventFindManyArgs>(args?: SelectSubset<T, VentureEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VentureEvent.
     * @param {VentureEventCreateArgs} args - Arguments to create a VentureEvent.
     * @example
     * // Create one VentureEvent
     * const VentureEvent = await prisma.ventureEvent.create({
     *   data: {
     *     // ... data to create a VentureEvent
     *   }
     * })
     * 
     */
    create<T extends VentureEventCreateArgs>(args: SelectSubset<T, VentureEventCreateArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VentureEvents.
     * @param {VentureEventCreateManyArgs} args - Arguments to create many VentureEvents.
     * @example
     * // Create many VentureEvents
     * const ventureEvent = await prisma.ventureEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureEventCreateManyArgs>(args?: SelectSubset<T, VentureEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VentureEvents and returns the data saved in the database.
     * @param {VentureEventCreateManyAndReturnArgs} args - Arguments to create many VentureEvents.
     * @example
     * // Create many VentureEvents
     * const ventureEvent = await prisma.ventureEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VentureEvents and only return the `id`
     * const ventureEventWithIdOnly = await prisma.ventureEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureEventCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VentureEvent.
     * @param {VentureEventDeleteArgs} args - Arguments to delete one VentureEvent.
     * @example
     * // Delete one VentureEvent
     * const VentureEvent = await prisma.ventureEvent.delete({
     *   where: {
     *     // ... filter to delete one VentureEvent
     *   }
     * })
     * 
     */
    delete<T extends VentureEventDeleteArgs>(args: SelectSubset<T, VentureEventDeleteArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VentureEvent.
     * @param {VentureEventUpdateArgs} args - Arguments to update one VentureEvent.
     * @example
     * // Update one VentureEvent
     * const ventureEvent = await prisma.ventureEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureEventUpdateArgs>(args: SelectSubset<T, VentureEventUpdateArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VentureEvents.
     * @param {VentureEventDeleteManyArgs} args - Arguments to filter VentureEvents to delete.
     * @example
     * // Delete a few VentureEvents
     * const { count } = await prisma.ventureEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureEventDeleteManyArgs>(args?: SelectSubset<T, VentureEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VentureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VentureEvents
     * const ventureEvent = await prisma.ventureEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureEventUpdateManyArgs>(args: SelectSubset<T, VentureEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VentureEvent.
     * @param {VentureEventUpsertArgs} args - Arguments to update or create a VentureEvent.
     * @example
     * // Update or create a VentureEvent
     * const ventureEvent = await prisma.ventureEvent.upsert({
     *   create: {
     *     // ... data to create a VentureEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VentureEvent we want to update
     *   }
     * })
     */
    upsert<T extends VentureEventUpsertArgs>(args: SelectSubset<T, VentureEventUpsertArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VentureEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventCountArgs} args - Arguments to filter VentureEvents to count.
     * @example
     * // Count the number of VentureEvents
     * const count = await prisma.ventureEvent.count({
     *   where: {
     *     // ... the filter for the VentureEvents we want to count
     *   }
     * })
    **/
    count<T extends VentureEventCountArgs>(
      args?: Subset<T, VentureEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VentureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureEventAggregateArgs>(args: Subset<T, VentureEventAggregateArgs>): Prisma.PrismaPromise<GetVentureEventAggregateType<T>>

    /**
     * Group by VentureEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureEventGroupByArgs['orderBy'] }
        : { orderBy?: VentureEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VentureEvent model
   */
  readonly fields: VentureEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VentureEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EventDonation<T extends VentureEvent$EventDonationArgs<ExtArgs> = {}>(args?: Subset<T, VentureEvent$EventDonationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventDonationPayload<ExtArgs>, T, "findMany"> | Null>
    Location<T extends VentureEvent$LocationArgs<ExtArgs> = {}>(args?: Subset<T, VentureEvent$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    VentureDetail<T extends VentureDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetailDefaultArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    XEventCategory<T extends VentureEvent$XEventCategoryArgs<ExtArgs> = {}>(args?: Subset<T, VentureEvent$XEventCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    EventCategory<T extends VentureEvent$EventCategoryArgs<ExtArgs> = {}>(args?: Subset<T, VentureEvent$EventCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VentureEvent model
   */ 
  interface VentureEventFieldRefs {
    readonly id: FieldRef<"VentureEvent", 'String'>
    readonly title: FieldRef<"VentureEvent", 'String'>
    readonly description: FieldRef<"VentureEvent", 'String'>
    readonly coverPhoto: FieldRef<"VentureEvent", 'String'>
    readonly ventureId: FieldRef<"VentureEvent", 'String'>
    readonly startDate: FieldRef<"VentureEvent", 'DateTime'>
    readonly endDate: FieldRef<"VentureEvent", 'DateTime'>
    readonly createdAt: FieldRef<"VentureEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"VentureEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VentureEvent findUnique
   */
  export type VentureEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter, which VentureEvent to fetch.
     */
    where: VentureEventWhereUniqueInput
  }

  /**
   * VentureEvent findUniqueOrThrow
   */
  export type VentureEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter, which VentureEvent to fetch.
     */
    where: VentureEventWhereUniqueInput
  }

  /**
   * VentureEvent findFirst
   */
  export type VentureEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter, which VentureEvent to fetch.
     */
    where?: VentureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureEvents to fetch.
     */
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureEvents.
     */
    cursor?: VentureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureEvents.
     */
    distinct?: VentureEventScalarFieldEnum | VentureEventScalarFieldEnum[]
  }

  /**
   * VentureEvent findFirstOrThrow
   */
  export type VentureEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter, which VentureEvent to fetch.
     */
    where?: VentureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureEvents to fetch.
     */
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureEvents.
     */
    cursor?: VentureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureEvents.
     */
    distinct?: VentureEventScalarFieldEnum | VentureEventScalarFieldEnum[]
  }

  /**
   * VentureEvent findMany
   */
  export type VentureEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter, which VentureEvents to fetch.
     */
    where?: VentureEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureEvents to fetch.
     */
    orderBy?: VentureEventOrderByWithRelationInput | VentureEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VentureEvents.
     */
    cursor?: VentureEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureEvents.
     */
    skip?: number
    distinct?: VentureEventScalarFieldEnum | VentureEventScalarFieldEnum[]
  }

  /**
   * VentureEvent create
   */
  export type VentureEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * The data needed to create a VentureEvent.
     */
    data: XOR<VentureEventCreateInput, VentureEventUncheckedCreateInput>
  }

  /**
   * VentureEvent createMany
   */
  export type VentureEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VentureEvents.
     */
    data: VentureEventCreateManyInput | VentureEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureEvent createManyAndReturn
   */
  export type VentureEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VentureEvents.
     */
    data: VentureEventCreateManyInput | VentureEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VentureEvent update
   */
  export type VentureEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * The data needed to update a VentureEvent.
     */
    data: XOR<VentureEventUpdateInput, VentureEventUncheckedUpdateInput>
    /**
     * Choose, which VentureEvent to update.
     */
    where: VentureEventWhereUniqueInput
  }

  /**
   * VentureEvent updateMany
   */
  export type VentureEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VentureEvents.
     */
    data: XOR<VentureEventUpdateManyMutationInput, VentureEventUncheckedUpdateManyInput>
    /**
     * Filter which VentureEvents to update
     */
    where?: VentureEventWhereInput
  }

  /**
   * VentureEvent upsert
   */
  export type VentureEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * The filter to search for the VentureEvent to update in case it exists.
     */
    where: VentureEventWhereUniqueInput
    /**
     * In case the VentureEvent found by the `where` argument doesn't exist, create a new VentureEvent with this data.
     */
    create: XOR<VentureEventCreateInput, VentureEventUncheckedCreateInput>
    /**
     * In case the VentureEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureEventUpdateInput, VentureEventUncheckedUpdateInput>
  }

  /**
   * VentureEvent delete
   */
  export type VentureEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
    /**
     * Filter which VentureEvent to delete.
     */
    where: VentureEventWhereUniqueInput
  }

  /**
   * VentureEvent deleteMany
   */
  export type VentureEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureEvents to delete
     */
    where?: VentureEventWhereInput
  }

  /**
   * VentureEvent.EventDonation
   */
  export type VentureEvent$EventDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventDonation
     */
    select?: EventDonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventDonationInclude<ExtArgs> | null
    where?: EventDonationWhereInput
    orderBy?: EventDonationOrderByWithRelationInput | EventDonationOrderByWithRelationInput[]
    cursor?: EventDonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventDonationScalarFieldEnum | EventDonationScalarFieldEnum[]
  }

  /**
   * VentureEvent.Location
   */
  export type VentureEvent$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * VentureEvent.XEventCategory
   */
  export type VentureEvent$XEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    where?: XEventCategoryWhereInput
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    cursor?: XEventCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XEventCategoryScalarFieldEnum | XEventCategoryScalarFieldEnum[]
  }

  /**
   * VentureEvent.EventCategory
   */
  export type VentureEvent$EventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    where?: EventCategoryWhereInput
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    cursor?: EventCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * VentureEvent without action
   */
  export type VentureEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureEvent
     */
    select?: VentureEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureEventInclude<ExtArgs> | null
  }


  /**
   * Model VenturePublication
   */

  export type AggregateVenturePublication = {
    _count: VenturePublicationCountAggregateOutputType | null
    _avg: VenturePublicationAvgAggregateOutputType | null
    _sum: VenturePublicationSumAggregateOutputType | null
    _min: VenturePublicationMinAggregateOutputType | null
    _max: VenturePublicationMaxAggregateOutputType | null
  }

  export type VenturePublicationAvgAggregateOutputType = {
    clapsCount: number | null
  }

  export type VenturePublicationSumAggregateOutputType = {
    clapsCount: number | null
  }

  export type VenturePublicationMinAggregateOutputType = {
    id: string | null
    description: string | null
    detailId: string | null
    type: $Enums.PublicationType | null
    clapsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenturePublicationMaxAggregateOutputType = {
    id: string | null
    description: string | null
    detailId: string | null
    type: $Enums.PublicationType | null
    clapsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenturePublicationCountAggregateOutputType = {
    id: number
    description: number
    detailId: number
    type: number
    clapsCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenturePublicationAvgAggregateInputType = {
    clapsCount?: true
  }

  export type VenturePublicationSumAggregateInputType = {
    clapsCount?: true
  }

  export type VenturePublicationMinAggregateInputType = {
    id?: true
    description?: true
    detailId?: true
    type?: true
    clapsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenturePublicationMaxAggregateInputType = {
    id?: true
    description?: true
    detailId?: true
    type?: true
    clapsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenturePublicationCountAggregateInputType = {
    id?: true
    description?: true
    detailId?: true
    type?: true
    clapsCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenturePublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenturePublication to aggregate.
     */
    where?: VenturePublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenturePublications to fetch.
     */
    orderBy?: VenturePublicationOrderByWithRelationInput | VenturePublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenturePublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenturePublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenturePublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VenturePublications
    **/
    _count?: true | VenturePublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenturePublicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenturePublicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenturePublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenturePublicationMaxAggregateInputType
  }

  export type GetVenturePublicationAggregateType<T extends VenturePublicationAggregateArgs> = {
        [P in keyof T & keyof AggregateVenturePublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenturePublication[P]>
      : GetScalarType<T[P], AggregateVenturePublication[P]>
  }




  export type VenturePublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenturePublicationWhereInput
    orderBy?: VenturePublicationOrderByWithAggregationInput | VenturePublicationOrderByWithAggregationInput[]
    by: VenturePublicationScalarFieldEnum[] | VenturePublicationScalarFieldEnum
    having?: VenturePublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenturePublicationCountAggregateInputType | true
    _avg?: VenturePublicationAvgAggregateInputType
    _sum?: VenturePublicationSumAggregateInputType
    _min?: VenturePublicationMinAggregateInputType
    _max?: VenturePublicationMaxAggregateInputType
  }

  export type VenturePublicationGroupByOutputType = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt: Date
    updatedAt: Date
    _count: VenturePublicationCountAggregateOutputType | null
    _avg: VenturePublicationAvgAggregateOutputType | null
    _sum: VenturePublicationSumAggregateOutputType | null
    _min: VenturePublicationMinAggregateOutputType | null
    _max: VenturePublicationMaxAggregateOutputType | null
  }

  type GetVenturePublicationGroupByPayload<T extends VenturePublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenturePublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenturePublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenturePublicationGroupByOutputType[P]>
            : GetScalarType<T[P], VenturePublicationGroupByOutputType[P]>
        }
      >
    >


  export type VenturePublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    detailId?: boolean
    type?: boolean
    clapsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Comment?: boolean | VenturePublication$CommentArgs<ExtArgs>
    PublicationClap?: boolean | VenturePublication$PublicationClapArgs<ExtArgs>
    PublicationContent?: boolean | VenturePublication$PublicationContentArgs<ExtArgs>
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    _count?: boolean | VenturePublicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venturePublication"]>

  export type VenturePublicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    detailId?: boolean
    type?: boolean
    clapsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venturePublication"]>

  export type VenturePublicationSelectScalar = {
    id?: boolean
    description?: boolean
    detailId?: boolean
    type?: boolean
    clapsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenturePublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | VenturePublication$CommentArgs<ExtArgs>
    PublicationClap?: boolean | VenturePublication$PublicationClapArgs<ExtArgs>
    PublicationContent?: boolean | VenturePublication$PublicationContentArgs<ExtArgs>
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
    _count?: boolean | VenturePublicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenturePublicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }

  export type $VenturePublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VenturePublication"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      PublicationClap: Prisma.$PublicationClapPayload<ExtArgs>[]
      PublicationContent: Prisma.$PublicationContentPayload<ExtArgs>[]
      detail: Prisma.$VentureDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      detailId: string
      type: $Enums.PublicationType
      clapsCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venturePublication"]>
    composites: {}
  }

  type VenturePublicationGetPayload<S extends boolean | null | undefined | VenturePublicationDefaultArgs> = $Result.GetResult<Prisma.$VenturePublicationPayload, S>

  type VenturePublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenturePublicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenturePublicationCountAggregateInputType | true
    }

  export interface VenturePublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VenturePublication'], meta: { name: 'VenturePublication' } }
    /**
     * Find zero or one VenturePublication that matches the filter.
     * @param {VenturePublicationFindUniqueArgs} args - Arguments to find a VenturePublication
     * @example
     * // Get one VenturePublication
     * const venturePublication = await prisma.venturePublication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenturePublicationFindUniqueArgs>(args: SelectSubset<T, VenturePublicationFindUniqueArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VenturePublication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenturePublicationFindUniqueOrThrowArgs} args - Arguments to find a VenturePublication
     * @example
     * // Get one VenturePublication
     * const venturePublication = await prisma.venturePublication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenturePublicationFindUniqueOrThrowArgs>(args: SelectSubset<T, VenturePublicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VenturePublication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationFindFirstArgs} args - Arguments to find a VenturePublication
     * @example
     * // Get one VenturePublication
     * const venturePublication = await prisma.venturePublication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenturePublicationFindFirstArgs>(args?: SelectSubset<T, VenturePublicationFindFirstArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VenturePublication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationFindFirstOrThrowArgs} args - Arguments to find a VenturePublication
     * @example
     * // Get one VenturePublication
     * const venturePublication = await prisma.venturePublication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenturePublicationFindFirstOrThrowArgs>(args?: SelectSubset<T, VenturePublicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VenturePublications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VenturePublications
     * const venturePublications = await prisma.venturePublication.findMany()
     * 
     * // Get first 10 VenturePublications
     * const venturePublications = await prisma.venturePublication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venturePublicationWithIdOnly = await prisma.venturePublication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenturePublicationFindManyArgs>(args?: SelectSubset<T, VenturePublicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VenturePublication.
     * @param {VenturePublicationCreateArgs} args - Arguments to create a VenturePublication.
     * @example
     * // Create one VenturePublication
     * const VenturePublication = await prisma.venturePublication.create({
     *   data: {
     *     // ... data to create a VenturePublication
     *   }
     * })
     * 
     */
    create<T extends VenturePublicationCreateArgs>(args: SelectSubset<T, VenturePublicationCreateArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VenturePublications.
     * @param {VenturePublicationCreateManyArgs} args - Arguments to create many VenturePublications.
     * @example
     * // Create many VenturePublications
     * const venturePublication = await prisma.venturePublication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenturePublicationCreateManyArgs>(args?: SelectSubset<T, VenturePublicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VenturePublications and returns the data saved in the database.
     * @param {VenturePublicationCreateManyAndReturnArgs} args - Arguments to create many VenturePublications.
     * @example
     * // Create many VenturePublications
     * const venturePublication = await prisma.venturePublication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VenturePublications and only return the `id`
     * const venturePublicationWithIdOnly = await prisma.venturePublication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenturePublicationCreateManyAndReturnArgs>(args?: SelectSubset<T, VenturePublicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VenturePublication.
     * @param {VenturePublicationDeleteArgs} args - Arguments to delete one VenturePublication.
     * @example
     * // Delete one VenturePublication
     * const VenturePublication = await prisma.venturePublication.delete({
     *   where: {
     *     // ... filter to delete one VenturePublication
     *   }
     * })
     * 
     */
    delete<T extends VenturePublicationDeleteArgs>(args: SelectSubset<T, VenturePublicationDeleteArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VenturePublication.
     * @param {VenturePublicationUpdateArgs} args - Arguments to update one VenturePublication.
     * @example
     * // Update one VenturePublication
     * const venturePublication = await prisma.venturePublication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenturePublicationUpdateArgs>(args: SelectSubset<T, VenturePublicationUpdateArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VenturePublications.
     * @param {VenturePublicationDeleteManyArgs} args - Arguments to filter VenturePublications to delete.
     * @example
     * // Delete a few VenturePublications
     * const { count } = await prisma.venturePublication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenturePublicationDeleteManyArgs>(args?: SelectSubset<T, VenturePublicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenturePublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VenturePublications
     * const venturePublication = await prisma.venturePublication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenturePublicationUpdateManyArgs>(args: SelectSubset<T, VenturePublicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VenturePublication.
     * @param {VenturePublicationUpsertArgs} args - Arguments to update or create a VenturePublication.
     * @example
     * // Update or create a VenturePublication
     * const venturePublication = await prisma.venturePublication.upsert({
     *   create: {
     *     // ... data to create a VenturePublication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VenturePublication we want to update
     *   }
     * })
     */
    upsert<T extends VenturePublicationUpsertArgs>(args: SelectSubset<T, VenturePublicationUpsertArgs<ExtArgs>>): Prisma__VenturePublicationClient<$Result.GetResult<Prisma.$VenturePublicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VenturePublications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationCountArgs} args - Arguments to filter VenturePublications to count.
     * @example
     * // Count the number of VenturePublications
     * const count = await prisma.venturePublication.count({
     *   where: {
     *     // ... the filter for the VenturePublications we want to count
     *   }
     * })
    **/
    count<T extends VenturePublicationCountArgs>(
      args?: Subset<T, VenturePublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenturePublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VenturePublication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenturePublicationAggregateArgs>(args: Subset<T, VenturePublicationAggregateArgs>): Prisma.PrismaPromise<GetVenturePublicationAggregateType<T>>

    /**
     * Group by VenturePublication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenturePublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenturePublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenturePublicationGroupByArgs['orderBy'] }
        : { orderBy?: VenturePublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenturePublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenturePublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VenturePublication model
   */
  readonly fields: VenturePublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VenturePublication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenturePublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comment<T extends VenturePublication$CommentArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublication$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    PublicationClap<T extends VenturePublication$PublicationClapArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublication$PublicationClapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationClapPayload<ExtArgs>, T, "findMany"> | Null>
    PublicationContent<T extends VenturePublication$PublicationContentArgs<ExtArgs> = {}>(args?: Subset<T, VenturePublication$PublicationContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationContentPayload<ExtArgs>, T, "findMany"> | Null>
    detail<T extends VentureDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetailDefaultArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VenturePublication model
   */ 
  interface VenturePublicationFieldRefs {
    readonly id: FieldRef<"VenturePublication", 'String'>
    readonly description: FieldRef<"VenturePublication", 'String'>
    readonly detailId: FieldRef<"VenturePublication", 'String'>
    readonly type: FieldRef<"VenturePublication", 'PublicationType'>
    readonly clapsCount: FieldRef<"VenturePublication", 'Int'>
    readonly createdAt: FieldRef<"VenturePublication", 'DateTime'>
    readonly updatedAt: FieldRef<"VenturePublication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VenturePublication findUnique
   */
  export type VenturePublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter, which VenturePublication to fetch.
     */
    where: VenturePublicationWhereUniqueInput
  }

  /**
   * VenturePublication findUniqueOrThrow
   */
  export type VenturePublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter, which VenturePublication to fetch.
     */
    where: VenturePublicationWhereUniqueInput
  }

  /**
   * VenturePublication findFirst
   */
  export type VenturePublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter, which VenturePublication to fetch.
     */
    where?: VenturePublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenturePublications to fetch.
     */
    orderBy?: VenturePublicationOrderByWithRelationInput | VenturePublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenturePublications.
     */
    cursor?: VenturePublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenturePublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenturePublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenturePublications.
     */
    distinct?: VenturePublicationScalarFieldEnum | VenturePublicationScalarFieldEnum[]
  }

  /**
   * VenturePublication findFirstOrThrow
   */
  export type VenturePublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter, which VenturePublication to fetch.
     */
    where?: VenturePublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenturePublications to fetch.
     */
    orderBy?: VenturePublicationOrderByWithRelationInput | VenturePublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenturePublications.
     */
    cursor?: VenturePublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenturePublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenturePublications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenturePublications.
     */
    distinct?: VenturePublicationScalarFieldEnum | VenturePublicationScalarFieldEnum[]
  }

  /**
   * VenturePublication findMany
   */
  export type VenturePublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter, which VenturePublications to fetch.
     */
    where?: VenturePublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenturePublications to fetch.
     */
    orderBy?: VenturePublicationOrderByWithRelationInput | VenturePublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VenturePublications.
     */
    cursor?: VenturePublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenturePublications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenturePublications.
     */
    skip?: number
    distinct?: VenturePublicationScalarFieldEnum | VenturePublicationScalarFieldEnum[]
  }

  /**
   * VenturePublication create
   */
  export type VenturePublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a VenturePublication.
     */
    data: XOR<VenturePublicationCreateInput, VenturePublicationUncheckedCreateInput>
  }

  /**
   * VenturePublication createMany
   */
  export type VenturePublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VenturePublications.
     */
    data: VenturePublicationCreateManyInput | VenturePublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VenturePublication createManyAndReturn
   */
  export type VenturePublicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VenturePublications.
     */
    data: VenturePublicationCreateManyInput | VenturePublicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VenturePublication update
   */
  export type VenturePublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a VenturePublication.
     */
    data: XOR<VenturePublicationUpdateInput, VenturePublicationUncheckedUpdateInput>
    /**
     * Choose, which VenturePublication to update.
     */
    where: VenturePublicationWhereUniqueInput
  }

  /**
   * VenturePublication updateMany
   */
  export type VenturePublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VenturePublications.
     */
    data: XOR<VenturePublicationUpdateManyMutationInput, VenturePublicationUncheckedUpdateManyInput>
    /**
     * Filter which VenturePublications to update
     */
    where?: VenturePublicationWhereInput
  }

  /**
   * VenturePublication upsert
   */
  export type VenturePublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the VenturePublication to update in case it exists.
     */
    where: VenturePublicationWhereUniqueInput
    /**
     * In case the VenturePublication found by the `where` argument doesn't exist, create a new VenturePublication with this data.
     */
    create: XOR<VenturePublicationCreateInput, VenturePublicationUncheckedCreateInput>
    /**
     * In case the VenturePublication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenturePublicationUpdateInput, VenturePublicationUncheckedUpdateInput>
  }

  /**
   * VenturePublication delete
   */
  export type VenturePublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
    /**
     * Filter which VenturePublication to delete.
     */
    where: VenturePublicationWhereUniqueInput
  }

  /**
   * VenturePublication deleteMany
   */
  export type VenturePublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenturePublications to delete
     */
    where?: VenturePublicationWhereInput
  }

  /**
   * VenturePublication.Comment
   */
  export type VenturePublication$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * VenturePublication.PublicationClap
   */
  export type VenturePublication$PublicationClapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationClap
     */
    select?: PublicationClapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationClapInclude<ExtArgs> | null
    where?: PublicationClapWhereInput
    orderBy?: PublicationClapOrderByWithRelationInput | PublicationClapOrderByWithRelationInput[]
    cursor?: PublicationClapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationClapScalarFieldEnum | PublicationClapScalarFieldEnum[]
  }

  /**
   * VenturePublication.PublicationContent
   */
  export type VenturePublication$PublicationContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationContent
     */
    select?: PublicationContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationContentInclude<ExtArgs> | null
    where?: PublicationContentWhereInput
    orderBy?: PublicationContentOrderByWithRelationInput | PublicationContentOrderByWithRelationInput[]
    cursor?: PublicationContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationContentScalarFieldEnum | PublicationContentScalarFieldEnum[]
  }

  /**
   * VenturePublication without action
   */
  export type VenturePublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenturePublication
     */
    select?: VenturePublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenturePublicationInclude<ExtArgs> | null
  }


  /**
   * Model VentureSponsorship
   */

  export type AggregateVentureSponsorship = {
    _count: VentureSponsorshipCountAggregateOutputType | null
    _avg: VentureSponsorshipAvgAggregateOutputType | null
    _sum: VentureSponsorshipSumAggregateOutputType | null
    _min: VentureSponsorshipMinAggregateOutputType | null
    _max: VentureSponsorshipMaxAggregateOutputType | null
  }

  export type VentureSponsorshipAvgAggregateOutputType = {
    monthlyAmount: number | null
  }

  export type VentureSponsorshipSumAggregateOutputType = {
    monthlyAmount: number | null
  }

  export type VentureSponsorshipMinAggregateOutputType = {
    id: string | null
    sponsorId: string | null
    ventureDetailId: string | null
    monthlyAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureSponsorshipMaxAggregateOutputType = {
    id: string | null
    sponsorId: string | null
    ventureDetailId: string | null
    monthlyAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VentureSponsorshipCountAggregateOutputType = {
    id: number
    sponsorId: number
    ventureDetailId: number
    monthlyAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VentureSponsorshipAvgAggregateInputType = {
    monthlyAmount?: true
  }

  export type VentureSponsorshipSumAggregateInputType = {
    monthlyAmount?: true
  }

  export type VentureSponsorshipMinAggregateInputType = {
    id?: true
    sponsorId?: true
    ventureDetailId?: true
    monthlyAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureSponsorshipMaxAggregateInputType = {
    id?: true
    sponsorId?: true
    ventureDetailId?: true
    monthlyAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VentureSponsorshipCountAggregateInputType = {
    id?: true
    sponsorId?: true
    ventureDetailId?: true
    monthlyAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VentureSponsorshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureSponsorship to aggregate.
     */
    where?: VentureSponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSponsorships to fetch.
     */
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureSponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VentureSponsorships
    **/
    _count?: true | VentureSponsorshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VentureSponsorshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VentureSponsorshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureSponsorshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureSponsorshipMaxAggregateInputType
  }

  export type GetVentureSponsorshipAggregateType<T extends VentureSponsorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateVentureSponsorship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentureSponsorship[P]>
      : GetScalarType<T[P], AggregateVentureSponsorship[P]>
  }




  export type VentureSponsorshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSponsorshipWhereInput
    orderBy?: VentureSponsorshipOrderByWithAggregationInput | VentureSponsorshipOrderByWithAggregationInput[]
    by: VentureSponsorshipScalarFieldEnum[] | VentureSponsorshipScalarFieldEnum
    having?: VentureSponsorshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureSponsorshipCountAggregateInputType | true
    _avg?: VentureSponsorshipAvgAggregateInputType
    _sum?: VentureSponsorshipSumAggregateInputType
    _min?: VentureSponsorshipMinAggregateInputType
    _max?: VentureSponsorshipMaxAggregateInputType
  }

  export type VentureSponsorshipGroupByOutputType = {
    id: string
    sponsorId: string
    ventureDetailId: string
    monthlyAmount: number
    createdAt: Date
    updatedAt: Date
    _count: VentureSponsorshipCountAggregateOutputType | null
    _avg: VentureSponsorshipAvgAggregateOutputType | null
    _sum: VentureSponsorshipSumAggregateOutputType | null
    _min: VentureSponsorshipMinAggregateOutputType | null
    _max: VentureSponsorshipMaxAggregateOutputType | null
  }

  type GetVentureSponsorshipGroupByPayload<T extends VentureSponsorshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureSponsorshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureSponsorshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureSponsorshipGroupByOutputType[P]>
            : GetScalarType<T[P], VentureSponsorshipGroupByOutputType[P]>
        }
      >
    >


  export type VentureSponsorshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    ventureDetailId?: boolean
    monthlyAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureSponsorship"]>

  export type VentureSponsorshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    ventureDetailId?: boolean
    monthlyAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureSponsorship"]>

  export type VentureSponsorshipSelectScalar = {
    id?: boolean
    sponsorId?: boolean
    ventureDetailId?: boolean
    monthlyAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VentureSponsorshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }
  export type VentureSponsorshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }

  export type $VentureSponsorshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VentureSponsorship"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      VentureDetail: Prisma.$VentureDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sponsorId: string
      ventureDetailId: string
      monthlyAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ventureSponsorship"]>
    composites: {}
  }

  type VentureSponsorshipGetPayload<S extends boolean | null | undefined | VentureSponsorshipDefaultArgs> = $Result.GetResult<Prisma.$VentureSponsorshipPayload, S>

  type VentureSponsorshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureSponsorshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureSponsorshipCountAggregateInputType | true
    }

  export interface VentureSponsorshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VentureSponsorship'], meta: { name: 'VentureSponsorship' } }
    /**
     * Find zero or one VentureSponsorship that matches the filter.
     * @param {VentureSponsorshipFindUniqueArgs} args - Arguments to find a VentureSponsorship
     * @example
     * // Get one VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureSponsorshipFindUniqueArgs>(args: SelectSubset<T, VentureSponsorshipFindUniqueArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VentureSponsorship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureSponsorshipFindUniqueOrThrowArgs} args - Arguments to find a VentureSponsorship
     * @example
     * // Get one VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureSponsorshipFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureSponsorshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VentureSponsorship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipFindFirstArgs} args - Arguments to find a VentureSponsorship
     * @example
     * // Get one VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureSponsorshipFindFirstArgs>(args?: SelectSubset<T, VentureSponsorshipFindFirstArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VentureSponsorship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipFindFirstOrThrowArgs} args - Arguments to find a VentureSponsorship
     * @example
     * // Get one VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureSponsorshipFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureSponsorshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VentureSponsorships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VentureSponsorships
     * const ventureSponsorships = await prisma.ventureSponsorship.findMany()
     * 
     * // Get first 10 VentureSponsorships
     * const ventureSponsorships = await prisma.ventureSponsorship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureSponsorshipWithIdOnly = await prisma.ventureSponsorship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureSponsorshipFindManyArgs>(args?: SelectSubset<T, VentureSponsorshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VentureSponsorship.
     * @param {VentureSponsorshipCreateArgs} args - Arguments to create a VentureSponsorship.
     * @example
     * // Create one VentureSponsorship
     * const VentureSponsorship = await prisma.ventureSponsorship.create({
     *   data: {
     *     // ... data to create a VentureSponsorship
     *   }
     * })
     * 
     */
    create<T extends VentureSponsorshipCreateArgs>(args: SelectSubset<T, VentureSponsorshipCreateArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VentureSponsorships.
     * @param {VentureSponsorshipCreateManyArgs} args - Arguments to create many VentureSponsorships.
     * @example
     * // Create many VentureSponsorships
     * const ventureSponsorship = await prisma.ventureSponsorship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureSponsorshipCreateManyArgs>(args?: SelectSubset<T, VentureSponsorshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VentureSponsorships and returns the data saved in the database.
     * @param {VentureSponsorshipCreateManyAndReturnArgs} args - Arguments to create many VentureSponsorships.
     * @example
     * // Create many VentureSponsorships
     * const ventureSponsorship = await prisma.ventureSponsorship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VentureSponsorships and only return the `id`
     * const ventureSponsorshipWithIdOnly = await prisma.ventureSponsorship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureSponsorshipCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureSponsorshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VentureSponsorship.
     * @param {VentureSponsorshipDeleteArgs} args - Arguments to delete one VentureSponsorship.
     * @example
     * // Delete one VentureSponsorship
     * const VentureSponsorship = await prisma.ventureSponsorship.delete({
     *   where: {
     *     // ... filter to delete one VentureSponsorship
     *   }
     * })
     * 
     */
    delete<T extends VentureSponsorshipDeleteArgs>(args: SelectSubset<T, VentureSponsorshipDeleteArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VentureSponsorship.
     * @param {VentureSponsorshipUpdateArgs} args - Arguments to update one VentureSponsorship.
     * @example
     * // Update one VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureSponsorshipUpdateArgs>(args: SelectSubset<T, VentureSponsorshipUpdateArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VentureSponsorships.
     * @param {VentureSponsorshipDeleteManyArgs} args - Arguments to filter VentureSponsorships to delete.
     * @example
     * // Delete a few VentureSponsorships
     * const { count } = await prisma.ventureSponsorship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureSponsorshipDeleteManyArgs>(args?: SelectSubset<T, VentureSponsorshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VentureSponsorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VentureSponsorships
     * const ventureSponsorship = await prisma.ventureSponsorship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureSponsorshipUpdateManyArgs>(args: SelectSubset<T, VentureSponsorshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VentureSponsorship.
     * @param {VentureSponsorshipUpsertArgs} args - Arguments to update or create a VentureSponsorship.
     * @example
     * // Update or create a VentureSponsorship
     * const ventureSponsorship = await prisma.ventureSponsorship.upsert({
     *   create: {
     *     // ... data to create a VentureSponsorship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VentureSponsorship we want to update
     *   }
     * })
     */
    upsert<T extends VentureSponsorshipUpsertArgs>(args: SelectSubset<T, VentureSponsorshipUpsertArgs<ExtArgs>>): Prisma__VentureSponsorshipClient<$Result.GetResult<Prisma.$VentureSponsorshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VentureSponsorships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipCountArgs} args - Arguments to filter VentureSponsorships to count.
     * @example
     * // Count the number of VentureSponsorships
     * const count = await prisma.ventureSponsorship.count({
     *   where: {
     *     // ... the filter for the VentureSponsorships we want to count
     *   }
     * })
    **/
    count<T extends VentureSponsorshipCountArgs>(
      args?: Subset<T, VentureSponsorshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureSponsorshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VentureSponsorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureSponsorshipAggregateArgs>(args: Subset<T, VentureSponsorshipAggregateArgs>): Prisma.PrismaPromise<GetVentureSponsorshipAggregateType<T>>

    /**
     * Group by VentureSponsorship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSponsorshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureSponsorshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureSponsorshipGroupByArgs['orderBy'] }
        : { orderBy?: VentureSponsorshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureSponsorshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureSponsorshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VentureSponsorship model
   */
  readonly fields: VentureSponsorshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VentureSponsorship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureSponsorshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VentureDetail<T extends VentureDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetailDefaultArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VentureSponsorship model
   */ 
  interface VentureSponsorshipFieldRefs {
    readonly id: FieldRef<"VentureSponsorship", 'String'>
    readonly sponsorId: FieldRef<"VentureSponsorship", 'String'>
    readonly ventureDetailId: FieldRef<"VentureSponsorship", 'String'>
    readonly monthlyAmount: FieldRef<"VentureSponsorship", 'Float'>
    readonly createdAt: FieldRef<"VentureSponsorship", 'DateTime'>
    readonly updatedAt: FieldRef<"VentureSponsorship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VentureSponsorship findUnique
   */
  export type VentureSponsorshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which VentureSponsorship to fetch.
     */
    where: VentureSponsorshipWhereUniqueInput
  }

  /**
   * VentureSponsorship findUniqueOrThrow
   */
  export type VentureSponsorshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which VentureSponsorship to fetch.
     */
    where: VentureSponsorshipWhereUniqueInput
  }

  /**
   * VentureSponsorship findFirst
   */
  export type VentureSponsorshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which VentureSponsorship to fetch.
     */
    where?: VentureSponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSponsorships to fetch.
     */
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureSponsorships.
     */
    cursor?: VentureSponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureSponsorships.
     */
    distinct?: VentureSponsorshipScalarFieldEnum | VentureSponsorshipScalarFieldEnum[]
  }

  /**
   * VentureSponsorship findFirstOrThrow
   */
  export type VentureSponsorshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which VentureSponsorship to fetch.
     */
    where?: VentureSponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSponsorships to fetch.
     */
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureSponsorships.
     */
    cursor?: VentureSponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSponsorships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureSponsorships.
     */
    distinct?: VentureSponsorshipScalarFieldEnum | VentureSponsorshipScalarFieldEnum[]
  }

  /**
   * VentureSponsorship findMany
   */
  export type VentureSponsorshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter, which VentureSponsorships to fetch.
     */
    where?: VentureSponsorshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSponsorships to fetch.
     */
    orderBy?: VentureSponsorshipOrderByWithRelationInput | VentureSponsorshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VentureSponsorships.
     */
    cursor?: VentureSponsorshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSponsorships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSponsorships.
     */
    skip?: number
    distinct?: VentureSponsorshipScalarFieldEnum | VentureSponsorshipScalarFieldEnum[]
  }

  /**
   * VentureSponsorship create
   */
  export type VentureSponsorshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * The data needed to create a VentureSponsorship.
     */
    data: XOR<VentureSponsorshipCreateInput, VentureSponsorshipUncheckedCreateInput>
  }

  /**
   * VentureSponsorship createMany
   */
  export type VentureSponsorshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VentureSponsorships.
     */
    data: VentureSponsorshipCreateManyInput | VentureSponsorshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureSponsorship createManyAndReturn
   */
  export type VentureSponsorshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VentureSponsorships.
     */
    data: VentureSponsorshipCreateManyInput | VentureSponsorshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VentureSponsorship update
   */
  export type VentureSponsorshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * The data needed to update a VentureSponsorship.
     */
    data: XOR<VentureSponsorshipUpdateInput, VentureSponsorshipUncheckedUpdateInput>
    /**
     * Choose, which VentureSponsorship to update.
     */
    where: VentureSponsorshipWhereUniqueInput
  }

  /**
   * VentureSponsorship updateMany
   */
  export type VentureSponsorshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VentureSponsorships.
     */
    data: XOR<VentureSponsorshipUpdateManyMutationInput, VentureSponsorshipUncheckedUpdateManyInput>
    /**
     * Filter which VentureSponsorships to update
     */
    where?: VentureSponsorshipWhereInput
  }

  /**
   * VentureSponsorship upsert
   */
  export type VentureSponsorshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * The filter to search for the VentureSponsorship to update in case it exists.
     */
    where: VentureSponsorshipWhereUniqueInput
    /**
     * In case the VentureSponsorship found by the `where` argument doesn't exist, create a new VentureSponsorship with this data.
     */
    create: XOR<VentureSponsorshipCreateInput, VentureSponsorshipUncheckedCreateInput>
    /**
     * In case the VentureSponsorship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureSponsorshipUpdateInput, VentureSponsorshipUncheckedUpdateInput>
  }

  /**
   * VentureSponsorship delete
   */
  export type VentureSponsorshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
    /**
     * Filter which VentureSponsorship to delete.
     */
    where: VentureSponsorshipWhereUniqueInput
  }

  /**
   * VentureSponsorship deleteMany
   */
  export type VentureSponsorshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureSponsorships to delete
     */
    where?: VentureSponsorshipWhereInput
  }

  /**
   * VentureSponsorship without action
   */
  export type VentureSponsorshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSponsorship
     */
    select?: VentureSponsorshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSponsorshipInclude<ExtArgs> | null
  }


  /**
   * Model VentureSubscription
   */

  export type AggregateVentureSubscription = {
    _count: VentureSubscriptionCountAggregateOutputType | null
    _min: VentureSubscriptionMinAggregateOutputType | null
    _max: VentureSubscriptionMaxAggregateOutputType | null
  }

  export type VentureSubscriptionMinAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    ventureId: string | null
    createdAt: Date | null
  }

  export type VentureSubscriptionMaxAggregateOutputType = {
    id: string | null
    subscriberId: string | null
    ventureId: string | null
    createdAt: Date | null
  }

  export type VentureSubscriptionCountAggregateOutputType = {
    id: number
    subscriberId: number
    ventureId: number
    createdAt: number
    _all: number
  }


  export type VentureSubscriptionMinAggregateInputType = {
    id?: true
    subscriberId?: true
    ventureId?: true
    createdAt?: true
  }

  export type VentureSubscriptionMaxAggregateInputType = {
    id?: true
    subscriberId?: true
    ventureId?: true
    createdAt?: true
  }

  export type VentureSubscriptionCountAggregateInputType = {
    id?: true
    subscriberId?: true
    ventureId?: true
    createdAt?: true
    _all?: true
  }

  export type VentureSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureSubscription to aggregate.
     */
    where?: VentureSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSubscriptions to fetch.
     */
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VentureSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VentureSubscriptions
    **/
    _count?: true | VentureSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VentureSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VentureSubscriptionMaxAggregateInputType
  }

  export type GetVentureSubscriptionAggregateType<T extends VentureSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateVentureSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVentureSubscription[P]>
      : GetScalarType<T[P], AggregateVentureSubscription[P]>
  }




  export type VentureSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VentureSubscriptionWhereInput
    orderBy?: VentureSubscriptionOrderByWithAggregationInput | VentureSubscriptionOrderByWithAggregationInput[]
    by: VentureSubscriptionScalarFieldEnum[] | VentureSubscriptionScalarFieldEnum
    having?: VentureSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VentureSubscriptionCountAggregateInputType | true
    _min?: VentureSubscriptionMinAggregateInputType
    _max?: VentureSubscriptionMaxAggregateInputType
  }

  export type VentureSubscriptionGroupByOutputType = {
    id: string
    subscriberId: string
    ventureId: string
    createdAt: Date
    _count: VentureSubscriptionCountAggregateOutputType | null
    _min: VentureSubscriptionMinAggregateOutputType | null
    _max: VentureSubscriptionMaxAggregateOutputType | null
  }

  type GetVentureSubscriptionGroupByPayload<T extends VentureSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VentureSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VentureSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VentureSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], VentureSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type VentureSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    ventureId?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureSubscription"]>

  export type VentureSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriberId?: boolean
    ventureId?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ventureSubscription"]>

  export type VentureSubscriptionSelectScalar = {
    id?: boolean
    subscriberId?: boolean
    ventureId?: boolean
    createdAt?: boolean
  }

  export type VentureSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }
  export type VentureSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    VentureDetail?: boolean | VentureDetailDefaultArgs<ExtArgs>
  }

  export type $VentureSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VentureSubscription"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      VentureDetail: Prisma.$VentureDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriberId: string
      ventureId: string
      createdAt: Date
    }, ExtArgs["result"]["ventureSubscription"]>
    composites: {}
  }

  type VentureSubscriptionGetPayload<S extends boolean | null | undefined | VentureSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$VentureSubscriptionPayload, S>

  type VentureSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VentureSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VentureSubscriptionCountAggregateInputType | true
    }

  export interface VentureSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VentureSubscription'], meta: { name: 'VentureSubscription' } }
    /**
     * Find zero or one VentureSubscription that matches the filter.
     * @param {VentureSubscriptionFindUniqueArgs} args - Arguments to find a VentureSubscription
     * @example
     * // Get one VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VentureSubscriptionFindUniqueArgs>(args: SelectSubset<T, VentureSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VentureSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VentureSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a VentureSubscription
     * @example
     * // Get one VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VentureSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, VentureSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VentureSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionFindFirstArgs} args - Arguments to find a VentureSubscription
     * @example
     * // Get one VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VentureSubscriptionFindFirstArgs>(args?: SelectSubset<T, VentureSubscriptionFindFirstArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VentureSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionFindFirstOrThrowArgs} args - Arguments to find a VentureSubscription
     * @example
     * // Get one VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VentureSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, VentureSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VentureSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VentureSubscriptions
     * const ventureSubscriptions = await prisma.ventureSubscription.findMany()
     * 
     * // Get first 10 VentureSubscriptions
     * const ventureSubscriptions = await prisma.ventureSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ventureSubscriptionWithIdOnly = await prisma.ventureSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VentureSubscriptionFindManyArgs>(args?: SelectSubset<T, VentureSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VentureSubscription.
     * @param {VentureSubscriptionCreateArgs} args - Arguments to create a VentureSubscription.
     * @example
     * // Create one VentureSubscription
     * const VentureSubscription = await prisma.ventureSubscription.create({
     *   data: {
     *     // ... data to create a VentureSubscription
     *   }
     * })
     * 
     */
    create<T extends VentureSubscriptionCreateArgs>(args: SelectSubset<T, VentureSubscriptionCreateArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VentureSubscriptions.
     * @param {VentureSubscriptionCreateManyArgs} args - Arguments to create many VentureSubscriptions.
     * @example
     * // Create many VentureSubscriptions
     * const ventureSubscription = await prisma.ventureSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VentureSubscriptionCreateManyArgs>(args?: SelectSubset<T, VentureSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VentureSubscriptions and returns the data saved in the database.
     * @param {VentureSubscriptionCreateManyAndReturnArgs} args - Arguments to create many VentureSubscriptions.
     * @example
     * // Create many VentureSubscriptions
     * const ventureSubscription = await prisma.ventureSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VentureSubscriptions and only return the `id`
     * const ventureSubscriptionWithIdOnly = await prisma.ventureSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VentureSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, VentureSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VentureSubscription.
     * @param {VentureSubscriptionDeleteArgs} args - Arguments to delete one VentureSubscription.
     * @example
     * // Delete one VentureSubscription
     * const VentureSubscription = await prisma.ventureSubscription.delete({
     *   where: {
     *     // ... filter to delete one VentureSubscription
     *   }
     * })
     * 
     */
    delete<T extends VentureSubscriptionDeleteArgs>(args: SelectSubset<T, VentureSubscriptionDeleteArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VentureSubscription.
     * @param {VentureSubscriptionUpdateArgs} args - Arguments to update one VentureSubscription.
     * @example
     * // Update one VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VentureSubscriptionUpdateArgs>(args: SelectSubset<T, VentureSubscriptionUpdateArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VentureSubscriptions.
     * @param {VentureSubscriptionDeleteManyArgs} args - Arguments to filter VentureSubscriptions to delete.
     * @example
     * // Delete a few VentureSubscriptions
     * const { count } = await prisma.ventureSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VentureSubscriptionDeleteManyArgs>(args?: SelectSubset<T, VentureSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VentureSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VentureSubscriptions
     * const ventureSubscription = await prisma.ventureSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VentureSubscriptionUpdateManyArgs>(args: SelectSubset<T, VentureSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VentureSubscription.
     * @param {VentureSubscriptionUpsertArgs} args - Arguments to update or create a VentureSubscription.
     * @example
     * // Update or create a VentureSubscription
     * const ventureSubscription = await prisma.ventureSubscription.upsert({
     *   create: {
     *     // ... data to create a VentureSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VentureSubscription we want to update
     *   }
     * })
     */
    upsert<T extends VentureSubscriptionUpsertArgs>(args: SelectSubset<T, VentureSubscriptionUpsertArgs<ExtArgs>>): Prisma__VentureSubscriptionClient<$Result.GetResult<Prisma.$VentureSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VentureSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionCountArgs} args - Arguments to filter VentureSubscriptions to count.
     * @example
     * // Count the number of VentureSubscriptions
     * const count = await prisma.ventureSubscription.count({
     *   where: {
     *     // ... the filter for the VentureSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends VentureSubscriptionCountArgs>(
      args?: Subset<T, VentureSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VentureSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VentureSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VentureSubscriptionAggregateArgs>(args: Subset<T, VentureSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetVentureSubscriptionAggregateType<T>>

    /**
     * Group by VentureSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VentureSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VentureSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VentureSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: VentureSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VentureSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVentureSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VentureSubscription model
   */
  readonly fields: VentureSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VentureSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VentureSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VentureDetail<T extends VentureDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureDetailDefaultArgs<ExtArgs>>): Prisma__VentureDetailClient<$Result.GetResult<Prisma.$VentureDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VentureSubscription model
   */ 
  interface VentureSubscriptionFieldRefs {
    readonly id: FieldRef<"VentureSubscription", 'String'>
    readonly subscriberId: FieldRef<"VentureSubscription", 'String'>
    readonly ventureId: FieldRef<"VentureSubscription", 'String'>
    readonly createdAt: FieldRef<"VentureSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VentureSubscription findUnique
   */
  export type VentureSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which VentureSubscription to fetch.
     */
    where: VentureSubscriptionWhereUniqueInput
  }

  /**
   * VentureSubscription findUniqueOrThrow
   */
  export type VentureSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which VentureSubscription to fetch.
     */
    where: VentureSubscriptionWhereUniqueInput
  }

  /**
   * VentureSubscription findFirst
   */
  export type VentureSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which VentureSubscription to fetch.
     */
    where?: VentureSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSubscriptions to fetch.
     */
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureSubscriptions.
     */
    cursor?: VentureSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureSubscriptions.
     */
    distinct?: VentureSubscriptionScalarFieldEnum | VentureSubscriptionScalarFieldEnum[]
  }

  /**
   * VentureSubscription findFirstOrThrow
   */
  export type VentureSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which VentureSubscription to fetch.
     */
    where?: VentureSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSubscriptions to fetch.
     */
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VentureSubscriptions.
     */
    cursor?: VentureSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VentureSubscriptions.
     */
    distinct?: VentureSubscriptionScalarFieldEnum | VentureSubscriptionScalarFieldEnum[]
  }

  /**
   * VentureSubscription findMany
   */
  export type VentureSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which VentureSubscriptions to fetch.
     */
    where?: VentureSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VentureSubscriptions to fetch.
     */
    orderBy?: VentureSubscriptionOrderByWithRelationInput | VentureSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VentureSubscriptions.
     */
    cursor?: VentureSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VentureSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VentureSubscriptions.
     */
    skip?: number
    distinct?: VentureSubscriptionScalarFieldEnum | VentureSubscriptionScalarFieldEnum[]
  }

  /**
   * VentureSubscription create
   */
  export type VentureSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a VentureSubscription.
     */
    data: XOR<VentureSubscriptionCreateInput, VentureSubscriptionUncheckedCreateInput>
  }

  /**
   * VentureSubscription createMany
   */
  export type VentureSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VentureSubscriptions.
     */
    data: VentureSubscriptionCreateManyInput | VentureSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VentureSubscription createManyAndReturn
   */
  export type VentureSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VentureSubscriptions.
     */
    data: VentureSubscriptionCreateManyInput | VentureSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VentureSubscription update
   */
  export type VentureSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a VentureSubscription.
     */
    data: XOR<VentureSubscriptionUpdateInput, VentureSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which VentureSubscription to update.
     */
    where: VentureSubscriptionWhereUniqueInput
  }

  /**
   * VentureSubscription updateMany
   */
  export type VentureSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VentureSubscriptions.
     */
    data: XOR<VentureSubscriptionUpdateManyMutationInput, VentureSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which VentureSubscriptions to update
     */
    where?: VentureSubscriptionWhereInput
  }

  /**
   * VentureSubscription upsert
   */
  export type VentureSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the VentureSubscription to update in case it exists.
     */
    where: VentureSubscriptionWhereUniqueInput
    /**
     * In case the VentureSubscription found by the `where` argument doesn't exist, create a new VentureSubscription with this data.
     */
    create: XOR<VentureSubscriptionCreateInput, VentureSubscriptionUncheckedCreateInput>
    /**
     * In case the VentureSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VentureSubscriptionUpdateInput, VentureSubscriptionUncheckedUpdateInput>
  }

  /**
   * VentureSubscription delete
   */
  export type VentureSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which VentureSubscription to delete.
     */
    where: VentureSubscriptionWhereUniqueInput
  }

  /**
   * VentureSubscription deleteMany
   */
  export type VentureSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VentureSubscriptions to delete
     */
    where?: VentureSubscriptionWhereInput
  }

  /**
   * VentureSubscription without action
   */
  export type VentureSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VentureSubscription
     */
    select?: VentureSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VentureSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model XEventCategory
   */

  export type AggregateXEventCategory = {
    _count: XEventCategoryCountAggregateOutputType | null
    _min: XEventCategoryMinAggregateOutputType | null
    _max: XEventCategoryMaxAggregateOutputType | null
  }

  export type XEventCategoryMinAggregateOutputType = {
    eventId: string | null
    categoryId: string | null
  }

  export type XEventCategoryMaxAggregateOutputType = {
    eventId: string | null
    categoryId: string | null
  }

  export type XEventCategoryCountAggregateOutputType = {
    eventId: number
    categoryId: number
    _all: number
  }


  export type XEventCategoryMinAggregateInputType = {
    eventId?: true
    categoryId?: true
  }

  export type XEventCategoryMaxAggregateInputType = {
    eventId?: true
    categoryId?: true
  }

  export type XEventCategoryCountAggregateInputType = {
    eventId?: true
    categoryId?: true
    _all?: true
  }

  export type XEventCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XEventCategory to aggregate.
     */
    where?: XEventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XEventCategories to fetch.
     */
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XEventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XEventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XEventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XEventCategories
    **/
    _count?: true | XEventCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XEventCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XEventCategoryMaxAggregateInputType
  }

  export type GetXEventCategoryAggregateType<T extends XEventCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateXEventCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXEventCategory[P]>
      : GetScalarType<T[P], AggregateXEventCategory[P]>
  }




  export type XEventCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XEventCategoryWhereInput
    orderBy?: XEventCategoryOrderByWithAggregationInput | XEventCategoryOrderByWithAggregationInput[]
    by: XEventCategoryScalarFieldEnum[] | XEventCategoryScalarFieldEnum
    having?: XEventCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XEventCategoryCountAggregateInputType | true
    _min?: XEventCategoryMinAggregateInputType
    _max?: XEventCategoryMaxAggregateInputType
  }

  export type XEventCategoryGroupByOutputType = {
    eventId: string
    categoryId: string
    _count: XEventCategoryCountAggregateOutputType | null
    _min: XEventCategoryMinAggregateOutputType | null
    _max: XEventCategoryMaxAggregateOutputType | null
  }

  type GetXEventCategoryGroupByPayload<T extends XEventCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XEventCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XEventCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XEventCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], XEventCategoryGroupByOutputType[P]>
        }
      >
    >


  export type XEventCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    categoryId?: boolean
    EventCategory?: boolean | EventCategoryDefaultArgs<ExtArgs>
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xEventCategory"]>

  export type XEventCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    categoryId?: boolean
    EventCategory?: boolean | EventCategoryDefaultArgs<ExtArgs>
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xEventCategory"]>

  export type XEventCategorySelectScalar = {
    eventId?: boolean
    categoryId?: boolean
  }

  export type XEventCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategory?: boolean | EventCategoryDefaultArgs<ExtArgs>
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }
  export type XEventCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategory?: boolean | EventCategoryDefaultArgs<ExtArgs>
    VentureEvent?: boolean | VentureEventDefaultArgs<ExtArgs>
  }

  export type $XEventCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XEventCategory"
    objects: {
      EventCategory: Prisma.$EventCategoryPayload<ExtArgs>
      VentureEvent: Prisma.$VentureEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      eventId: string
      categoryId: string
    }, ExtArgs["result"]["xEventCategory"]>
    composites: {}
  }

  type XEventCategoryGetPayload<S extends boolean | null | undefined | XEventCategoryDefaultArgs> = $Result.GetResult<Prisma.$XEventCategoryPayload, S>

  type XEventCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XEventCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XEventCategoryCountAggregateInputType | true
    }

  export interface XEventCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XEventCategory'], meta: { name: 'XEventCategory' } }
    /**
     * Find zero or one XEventCategory that matches the filter.
     * @param {XEventCategoryFindUniqueArgs} args - Arguments to find a XEventCategory
     * @example
     * // Get one XEventCategory
     * const xEventCategory = await prisma.xEventCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XEventCategoryFindUniqueArgs>(args: SelectSubset<T, XEventCategoryFindUniqueArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XEventCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XEventCategoryFindUniqueOrThrowArgs} args - Arguments to find a XEventCategory
     * @example
     * // Get one XEventCategory
     * const xEventCategory = await prisma.xEventCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XEventCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, XEventCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XEventCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryFindFirstArgs} args - Arguments to find a XEventCategory
     * @example
     * // Get one XEventCategory
     * const xEventCategory = await prisma.xEventCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XEventCategoryFindFirstArgs>(args?: SelectSubset<T, XEventCategoryFindFirstArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XEventCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryFindFirstOrThrowArgs} args - Arguments to find a XEventCategory
     * @example
     * // Get one XEventCategory
     * const xEventCategory = await prisma.xEventCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XEventCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, XEventCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XEventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XEventCategories
     * const xEventCategories = await prisma.xEventCategory.findMany()
     * 
     * // Get first 10 XEventCategories
     * const xEventCategories = await prisma.xEventCategory.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const xEventCategoryWithEventIdOnly = await prisma.xEventCategory.findMany({ select: { eventId: true } })
     * 
     */
    findMany<T extends XEventCategoryFindManyArgs>(args?: SelectSubset<T, XEventCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XEventCategory.
     * @param {XEventCategoryCreateArgs} args - Arguments to create a XEventCategory.
     * @example
     * // Create one XEventCategory
     * const XEventCategory = await prisma.xEventCategory.create({
     *   data: {
     *     // ... data to create a XEventCategory
     *   }
     * })
     * 
     */
    create<T extends XEventCategoryCreateArgs>(args: SelectSubset<T, XEventCategoryCreateArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XEventCategories.
     * @param {XEventCategoryCreateManyArgs} args - Arguments to create many XEventCategories.
     * @example
     * // Create many XEventCategories
     * const xEventCategory = await prisma.xEventCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XEventCategoryCreateManyArgs>(args?: SelectSubset<T, XEventCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XEventCategories and returns the data saved in the database.
     * @param {XEventCategoryCreateManyAndReturnArgs} args - Arguments to create many XEventCategories.
     * @example
     * // Create many XEventCategories
     * const xEventCategory = await prisma.xEventCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XEventCategories and only return the `eventId`
     * const xEventCategoryWithEventIdOnly = await prisma.xEventCategory.createManyAndReturn({ 
     *   select: { eventId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XEventCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, XEventCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XEventCategory.
     * @param {XEventCategoryDeleteArgs} args - Arguments to delete one XEventCategory.
     * @example
     * // Delete one XEventCategory
     * const XEventCategory = await prisma.xEventCategory.delete({
     *   where: {
     *     // ... filter to delete one XEventCategory
     *   }
     * })
     * 
     */
    delete<T extends XEventCategoryDeleteArgs>(args: SelectSubset<T, XEventCategoryDeleteArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XEventCategory.
     * @param {XEventCategoryUpdateArgs} args - Arguments to update one XEventCategory.
     * @example
     * // Update one XEventCategory
     * const xEventCategory = await prisma.xEventCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XEventCategoryUpdateArgs>(args: SelectSubset<T, XEventCategoryUpdateArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XEventCategories.
     * @param {XEventCategoryDeleteManyArgs} args - Arguments to filter XEventCategories to delete.
     * @example
     * // Delete a few XEventCategories
     * const { count } = await prisma.xEventCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XEventCategoryDeleteManyArgs>(args?: SelectSubset<T, XEventCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XEventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XEventCategories
     * const xEventCategory = await prisma.xEventCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XEventCategoryUpdateManyArgs>(args: SelectSubset<T, XEventCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XEventCategory.
     * @param {XEventCategoryUpsertArgs} args - Arguments to update or create a XEventCategory.
     * @example
     * // Update or create a XEventCategory
     * const xEventCategory = await prisma.xEventCategory.upsert({
     *   create: {
     *     // ... data to create a XEventCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XEventCategory we want to update
     *   }
     * })
     */
    upsert<T extends XEventCategoryUpsertArgs>(args: SelectSubset<T, XEventCategoryUpsertArgs<ExtArgs>>): Prisma__XEventCategoryClient<$Result.GetResult<Prisma.$XEventCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XEventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryCountArgs} args - Arguments to filter XEventCategories to count.
     * @example
     * // Count the number of XEventCategories
     * const count = await prisma.xEventCategory.count({
     *   where: {
     *     // ... the filter for the XEventCategories we want to count
     *   }
     * })
    **/
    count<T extends XEventCategoryCountArgs>(
      args?: Subset<T, XEventCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XEventCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XEventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XEventCategoryAggregateArgs>(args: Subset<T, XEventCategoryAggregateArgs>): Prisma.PrismaPromise<GetXEventCategoryAggregateType<T>>

    /**
     * Group by XEventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XEventCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XEventCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XEventCategoryGroupByArgs['orderBy'] }
        : { orderBy?: XEventCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XEventCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXEventCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XEventCategory model
   */
  readonly fields: XEventCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XEventCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XEventCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EventCategory<T extends EventCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventCategoryDefaultArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    VentureEvent<T extends VentureEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VentureEventDefaultArgs<ExtArgs>>): Prisma__VentureEventClient<$Result.GetResult<Prisma.$VentureEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XEventCategory model
   */ 
  interface XEventCategoryFieldRefs {
    readonly eventId: FieldRef<"XEventCategory", 'String'>
    readonly categoryId: FieldRef<"XEventCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * XEventCategory findUnique
   */
  export type XEventCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XEventCategory to fetch.
     */
    where: XEventCategoryWhereUniqueInput
  }

  /**
   * XEventCategory findUniqueOrThrow
   */
  export type XEventCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XEventCategory to fetch.
     */
    where: XEventCategoryWhereUniqueInput
  }

  /**
   * XEventCategory findFirst
   */
  export type XEventCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XEventCategory to fetch.
     */
    where?: XEventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XEventCategories to fetch.
     */
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XEventCategories.
     */
    cursor?: XEventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XEventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XEventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XEventCategories.
     */
    distinct?: XEventCategoryScalarFieldEnum | XEventCategoryScalarFieldEnum[]
  }

  /**
   * XEventCategory findFirstOrThrow
   */
  export type XEventCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XEventCategory to fetch.
     */
    where?: XEventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XEventCategories to fetch.
     */
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XEventCategories.
     */
    cursor?: XEventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XEventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XEventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XEventCategories.
     */
    distinct?: XEventCategoryScalarFieldEnum | XEventCategoryScalarFieldEnum[]
  }

  /**
   * XEventCategory findMany
   */
  export type XEventCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which XEventCategories to fetch.
     */
    where?: XEventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XEventCategories to fetch.
     */
    orderBy?: XEventCategoryOrderByWithRelationInput | XEventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XEventCategories.
     */
    cursor?: XEventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XEventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XEventCategories.
     */
    skip?: number
    distinct?: XEventCategoryScalarFieldEnum | XEventCategoryScalarFieldEnum[]
  }

  /**
   * XEventCategory create
   */
  export type XEventCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a XEventCategory.
     */
    data: XOR<XEventCategoryCreateInput, XEventCategoryUncheckedCreateInput>
  }

  /**
   * XEventCategory createMany
   */
  export type XEventCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XEventCategories.
     */
    data: XEventCategoryCreateManyInput | XEventCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XEventCategory createManyAndReturn
   */
  export type XEventCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XEventCategories.
     */
    data: XEventCategoryCreateManyInput | XEventCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XEventCategory update
   */
  export type XEventCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a XEventCategory.
     */
    data: XOR<XEventCategoryUpdateInput, XEventCategoryUncheckedUpdateInput>
    /**
     * Choose, which XEventCategory to update.
     */
    where: XEventCategoryWhereUniqueInput
  }

  /**
   * XEventCategory updateMany
   */
  export type XEventCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XEventCategories.
     */
    data: XOR<XEventCategoryUpdateManyMutationInput, XEventCategoryUncheckedUpdateManyInput>
    /**
     * Filter which XEventCategories to update
     */
    where?: XEventCategoryWhereInput
  }

  /**
   * XEventCategory upsert
   */
  export type XEventCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the XEventCategory to update in case it exists.
     */
    where: XEventCategoryWhereUniqueInput
    /**
     * In case the XEventCategory found by the `where` argument doesn't exist, create a new XEventCategory with this data.
     */
    create: XOR<XEventCategoryCreateInput, XEventCategoryUncheckedCreateInput>
    /**
     * In case the XEventCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XEventCategoryUpdateInput, XEventCategoryUncheckedUpdateInput>
  }

  /**
   * XEventCategory delete
   */
  export type XEventCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
    /**
     * Filter which XEventCategory to delete.
     */
    where: XEventCategoryWhereUniqueInput
  }

  /**
   * XEventCategory deleteMany
   */
  export type XEventCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XEventCategories to delete
     */
    where?: XEventCategoryWhereInput
  }

  /**
   * XEventCategory without action
   */
  export type XEventCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XEventCategory
     */
    select?: XEventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XEventCategoryInclude<ExtArgs> | null
  }


  /**
   * Model XUserRoles
   */

  export type AggregateXUserRoles = {
    _count: XUserRolesCountAggregateOutputType | null
    _min: XUserRolesMinAggregateOutputType | null
    _max: XUserRolesMaxAggregateOutputType | null
  }

  export type XUserRolesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type XUserRolesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type XUserRolesCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    _all: number
  }


  export type XUserRolesMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type XUserRolesMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type XUserRolesCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    _all?: true
  }

  export type XUserRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XUserRoles to aggregate.
     */
    where?: XUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserRoles to fetch.
     */
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XUserRoles
    **/
    _count?: true | XUserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XUserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XUserRolesMaxAggregateInputType
  }

  export type GetXUserRolesAggregateType<T extends XUserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateXUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXUserRoles[P]>
      : GetScalarType<T[P], AggregateXUserRoles[P]>
  }




  export type XUserRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XUserRolesWhereInput
    orderBy?: XUserRolesOrderByWithAggregationInput | XUserRolesOrderByWithAggregationInput[]
    by: XUserRolesScalarFieldEnum[] | XUserRolesScalarFieldEnum
    having?: XUserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XUserRolesCountAggregateInputType | true
    _min?: XUserRolesMinAggregateInputType
    _max?: XUserRolesMaxAggregateInputType
  }

  export type XUserRolesGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    createdAt: Date
    _count: XUserRolesCountAggregateOutputType | null
    _min: XUserRolesMinAggregateOutputType | null
    _max: XUserRolesMaxAggregateOutputType | null
  }

  type GetXUserRolesGroupByPayload<T extends XUserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XUserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XUserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XUserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], XUserRolesGroupByOutputType[P]>
        }
      >
    >


  export type XUserRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xUserRoles"]>

  export type XUserRolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xUserRoles"]>

  export type XUserRolesSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
  }

  export type XUserRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XUserRolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $XUserRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XUserRoles"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      createdAt: Date
    }, ExtArgs["result"]["xUserRoles"]>
    composites: {}
  }

  type XUserRolesGetPayload<S extends boolean | null | undefined | XUserRolesDefaultArgs> = $Result.GetResult<Prisma.$XUserRolesPayload, S>

  type XUserRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XUserRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XUserRolesCountAggregateInputType | true
    }

  export interface XUserRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XUserRoles'], meta: { name: 'XUserRoles' } }
    /**
     * Find zero or one XUserRoles that matches the filter.
     * @param {XUserRolesFindUniqueArgs} args - Arguments to find a XUserRoles
     * @example
     * // Get one XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XUserRolesFindUniqueArgs>(args: SelectSubset<T, XUserRolesFindUniqueArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XUserRoles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XUserRolesFindUniqueOrThrowArgs} args - Arguments to find a XUserRoles
     * @example
     * // Get one XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XUserRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, XUserRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesFindFirstArgs} args - Arguments to find a XUserRoles
     * @example
     * // Get one XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XUserRolesFindFirstArgs>(args?: SelectSubset<T, XUserRolesFindFirstArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XUserRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesFindFirstOrThrowArgs} args - Arguments to find a XUserRoles
     * @example
     * // Get one XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XUserRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, XUserRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findMany()
     * 
     * // Get first 10 XUserRoles
     * const xUserRoles = await prisma.xUserRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xUserRolesWithIdOnly = await prisma.xUserRoles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XUserRolesFindManyArgs>(args?: SelectSubset<T, XUserRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XUserRoles.
     * @param {XUserRolesCreateArgs} args - Arguments to create a XUserRoles.
     * @example
     * // Create one XUserRoles
     * const XUserRoles = await prisma.xUserRoles.create({
     *   data: {
     *     // ... data to create a XUserRoles
     *   }
     * })
     * 
     */
    create<T extends XUserRolesCreateArgs>(args: SelectSubset<T, XUserRolesCreateArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XUserRoles.
     * @param {XUserRolesCreateManyArgs} args - Arguments to create many XUserRoles.
     * @example
     * // Create many XUserRoles
     * const xUserRoles = await prisma.xUserRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XUserRolesCreateManyArgs>(args?: SelectSubset<T, XUserRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XUserRoles and returns the data saved in the database.
     * @param {XUserRolesCreateManyAndReturnArgs} args - Arguments to create many XUserRoles.
     * @example
     * // Create many XUserRoles
     * const xUserRoles = await prisma.xUserRoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XUserRoles and only return the `id`
     * const xUserRolesWithIdOnly = await prisma.xUserRoles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XUserRolesCreateManyAndReturnArgs>(args?: SelectSubset<T, XUserRolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XUserRoles.
     * @param {XUserRolesDeleteArgs} args - Arguments to delete one XUserRoles.
     * @example
     * // Delete one XUserRoles
     * const XUserRoles = await prisma.xUserRoles.delete({
     *   where: {
     *     // ... filter to delete one XUserRoles
     *   }
     * })
     * 
     */
    delete<T extends XUserRolesDeleteArgs>(args: SelectSubset<T, XUserRolesDeleteArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XUserRoles.
     * @param {XUserRolesUpdateArgs} args - Arguments to update one XUserRoles.
     * @example
     * // Update one XUserRoles
     * const xUserRoles = await prisma.xUserRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XUserRolesUpdateArgs>(args: SelectSubset<T, XUserRolesUpdateArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XUserRoles.
     * @param {XUserRolesDeleteManyArgs} args - Arguments to filter XUserRoles to delete.
     * @example
     * // Delete a few XUserRoles
     * const { count } = await prisma.xUserRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XUserRolesDeleteManyArgs>(args?: SelectSubset<T, XUserRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XUserRoles
     * const xUserRoles = await prisma.xUserRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XUserRolesUpdateManyArgs>(args: SelectSubset<T, XUserRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XUserRoles.
     * @param {XUserRolesUpsertArgs} args - Arguments to update or create a XUserRoles.
     * @example
     * // Update or create a XUserRoles
     * const xUserRoles = await prisma.xUserRoles.upsert({
     *   create: {
     *     // ... data to create a XUserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XUserRoles we want to update
     *   }
     * })
     */
    upsert<T extends XUserRolesUpsertArgs>(args: SelectSubset<T, XUserRolesUpsertArgs<ExtArgs>>): Prisma__XUserRolesClient<$Result.GetResult<Prisma.$XUserRolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesCountArgs} args - Arguments to filter XUserRoles to count.
     * @example
     * // Count the number of XUserRoles
     * const count = await prisma.xUserRoles.count({
     *   where: {
     *     // ... the filter for the XUserRoles we want to count
     *   }
     * })
    **/
    count<T extends XUserRolesCountArgs>(
      args?: Subset<T, XUserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XUserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XUserRolesAggregateArgs>(args: Subset<T, XUserRolesAggregateArgs>): Prisma.PrismaPromise<GetXUserRolesAggregateType<T>>

    /**
     * Group by XUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XUserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XUserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XUserRolesGroupByArgs['orderBy'] }
        : { orderBy?: XUserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XUserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XUserRoles model
   */
  readonly fields: XUserRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XUserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XUserRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XUserRoles model
   */ 
  interface XUserRolesFieldRefs {
    readonly id: FieldRef<"XUserRoles", 'String'>
    readonly userId: FieldRef<"XUserRoles", 'String'>
    readonly roleId: FieldRef<"XUserRoles", 'String'>
    readonly createdAt: FieldRef<"XUserRoles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XUserRoles findUnique
   */
  export type XUserRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which XUserRoles to fetch.
     */
    where: XUserRolesWhereUniqueInput
  }

  /**
   * XUserRoles findUniqueOrThrow
   */
  export type XUserRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which XUserRoles to fetch.
     */
    where: XUserRolesWhereUniqueInput
  }

  /**
   * XUserRoles findFirst
   */
  export type XUserRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which XUserRoles to fetch.
     */
    where?: XUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserRoles to fetch.
     */
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XUserRoles.
     */
    cursor?: XUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XUserRoles.
     */
    distinct?: XUserRolesScalarFieldEnum | XUserRolesScalarFieldEnum[]
  }

  /**
   * XUserRoles findFirstOrThrow
   */
  export type XUserRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which XUserRoles to fetch.
     */
    where?: XUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserRoles to fetch.
     */
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XUserRoles.
     */
    cursor?: XUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XUserRoles.
     */
    distinct?: XUserRolesScalarFieldEnum | XUserRolesScalarFieldEnum[]
  }

  /**
   * XUserRoles findMany
   */
  export type XUserRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which XUserRoles to fetch.
     */
    where?: XUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XUserRoles to fetch.
     */
    orderBy?: XUserRolesOrderByWithRelationInput | XUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XUserRoles.
     */
    cursor?: XUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XUserRoles.
     */
    skip?: number
    distinct?: XUserRolesScalarFieldEnum | XUserRolesScalarFieldEnum[]
  }

  /**
   * XUserRoles create
   */
  export type XUserRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a XUserRoles.
     */
    data: XOR<XUserRolesCreateInput, XUserRolesUncheckedCreateInput>
  }

  /**
   * XUserRoles createMany
   */
  export type XUserRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XUserRoles.
     */
    data: XUserRolesCreateManyInput | XUserRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XUserRoles createManyAndReturn
   */
  export type XUserRolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XUserRoles.
     */
    data: XUserRolesCreateManyInput | XUserRolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XUserRoles update
   */
  export type XUserRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a XUserRoles.
     */
    data: XOR<XUserRolesUpdateInput, XUserRolesUncheckedUpdateInput>
    /**
     * Choose, which XUserRoles to update.
     */
    where: XUserRolesWhereUniqueInput
  }

  /**
   * XUserRoles updateMany
   */
  export type XUserRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XUserRoles.
     */
    data: XOR<XUserRolesUpdateManyMutationInput, XUserRolesUncheckedUpdateManyInput>
    /**
     * Filter which XUserRoles to update
     */
    where?: XUserRolesWhereInput
  }

  /**
   * XUserRoles upsert
   */
  export type XUserRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the XUserRoles to update in case it exists.
     */
    where: XUserRolesWhereUniqueInput
    /**
     * In case the XUserRoles found by the `where` argument doesn't exist, create a new XUserRoles with this data.
     */
    create: XOR<XUserRolesCreateInput, XUserRolesUncheckedCreateInput>
    /**
     * In case the XUserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XUserRolesUpdateInput, XUserRolesUncheckedUpdateInput>
  }

  /**
   * XUserRoles delete
   */
  export type XUserRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
    /**
     * Filter which XUserRoles to delete.
     */
    where: XUserRolesWhereUniqueInput
  }

  /**
   * XUserRoles deleteMany
   */
  export type XUserRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XUserRoles to delete
     */
    where?: XUserRolesWhereInput
  }

  /**
   * XUserRoles without action
   */
  export type XUserRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XUserRoles
     */
    select?: XUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XUserRolesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    picture: 'picture',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    active: 'active',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    onboardingCompleted: 'onboardingCompleted',
    userDetailId: 'userDetailId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const XUserPreferencesScalarFieldEnum: {
    userId: 'userId',
    categoryId: 'categoryId'
  };

  export type XUserPreferencesScalarFieldEnum = (typeof XUserPreferencesScalarFieldEnum)[keyof typeof XUserPreferencesScalarFieldEnum]


  export const UserDetailScalarFieldEnum: {
    id: 'id',
    gender: 'gender',
    birthDate: 'birthDate',
    municipalityId: 'municipalityId'
  };

  export type UserDetailScalarFieldEnum = (typeof UserDetailScalarFieldEnum)[keyof typeof UserDetailScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const MunicipalityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MunicipalityScalarFieldEnum = (typeof MunicipalityScalarFieldEnum)[keyof typeof MunicipalityScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    publicationId: 'publicationId',
    body: 'body',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const EventCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventCategoryScalarFieldEnum = (typeof EventCategoryScalarFieldEnum)[keyof typeof EventCategoryScalarFieldEnum]


  export const EventDonationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventId: 'eventId',
    amount: 'amount',
    currency: 'currency',
    createdAt: 'createdAt'
  };

  export type EventDonationScalarFieldEnum = (typeof EventDonationScalarFieldEnum)[keyof typeof EventDonationScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    ventureEventId: 'ventureEventId',
    lat: 'lat',
    lng: 'lng',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    userId: 'userId',
    type: 'type',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PublicationClapScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    publicationId: 'publicationId',
    createdAt: 'createdAt'
  };

  export type PublicationClapScalarFieldEnum = (typeof PublicationClapScalarFieldEnum)[keyof typeof PublicationClapScalarFieldEnum]


  export const PublicationContentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    publicationId: 'publicationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicationContentScalarFieldEnum = (typeof PublicationContentScalarFieldEnum)[keyof typeof PublicationContentScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const VentureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    coverPhoto: 'coverPhoto',
    description: 'description',
    ownerId: 'ownerId',
    active: 'active',
    verified: 'verified',
    detailId: 'detailId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VentureScalarFieldEnum = (typeof VentureScalarFieldEnum)[keyof typeof VentureScalarFieldEnum]


  export const XVentureVencureCategoryScalarFieldEnum: {
    ventureId: 'ventureId',
    categoryId: 'categoryId'
  };

  export type XVentureVencureCategoryScalarFieldEnum = (typeof XVentureVencureCategoryScalarFieldEnum)[keyof typeof XVentureVencureCategoryScalarFieldEnum]


  export const VentureCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VentureCategoryScalarFieldEnum = (typeof VentureCategoryScalarFieldEnum)[keyof typeof VentureCategoryScalarFieldEnum]


  export const VentureDetailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VentureDetailScalarFieldEnum = (typeof VentureDetailScalarFieldEnum)[keyof typeof VentureDetailScalarFieldEnum]


  export const VentureEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    coverPhoto: 'coverPhoto',
    ventureId: 'ventureId',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VentureEventScalarFieldEnum = (typeof VentureEventScalarFieldEnum)[keyof typeof VentureEventScalarFieldEnum]


  export const VenturePublicationScalarFieldEnum: {
    id: 'id',
    description: 'description',
    detailId: 'detailId',
    type: 'type',
    clapsCount: 'clapsCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenturePublicationScalarFieldEnum = (typeof VenturePublicationScalarFieldEnum)[keyof typeof VenturePublicationScalarFieldEnum]


  export const VentureSponsorshipScalarFieldEnum: {
    id: 'id',
    sponsorId: 'sponsorId',
    ventureDetailId: 'ventureDetailId',
    monthlyAmount: 'monthlyAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VentureSponsorshipScalarFieldEnum = (typeof VentureSponsorshipScalarFieldEnum)[keyof typeof VentureSponsorshipScalarFieldEnum]


  export const VentureSubscriptionScalarFieldEnum: {
    id: 'id',
    subscriberId: 'subscriberId',
    ventureId: 'ventureId',
    createdAt: 'createdAt'
  };

  export type VentureSubscriptionScalarFieldEnum = (typeof VentureSubscriptionScalarFieldEnum)[keyof typeof VentureSubscriptionScalarFieldEnum]


  export const XEventCategoryScalarFieldEnum: {
    eventId: 'eventId',
    categoryId: 'categoryId'
  };

  export type XEventCategoryScalarFieldEnum = (typeof XEventCategoryScalarFieldEnum)[keyof typeof XEventCategoryScalarFieldEnum]


  export const XUserRolesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt'
  };

  export type XUserRolesScalarFieldEnum = (typeof XUserRolesScalarFieldEnum)[keyof typeof XUserRolesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'AppRole'
   */
  export type EnumAppRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppRole'>
    


  /**
   * Reference to a field of type 'AppRole[]'
   */
  export type ListEnumAppRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppRole[]'>
    


  /**
   * Reference to a field of type 'PublicationType'
   */
  export type EnumPublicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationType'>
    


  /**
   * Reference to a field of type 'PublicationType[]'
   */
  export type ListEnumPublicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    picture?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    verified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    onboardingCompleted?: BoolFilter<"User"> | boolean
    userDetailId?: StringNullableFilter<"User"> | string | null
    comments?: CommentListRelationFilter
    eventDonations?: EventDonationListRelationFilter
    notifications?: NotificationListRelationFilter
    publicationClaps?: PublicationClapListRelationFilter
    ventures?: VentureListRelationFilter
    ventureSponsorships?: VentureSponsorshipListRelationFilter
    ventureSubscriptions?: VentureSubscriptionListRelationFilter
    roles?: RoleListRelationFilter
    detail?: XOR<UserDetailNullableRelationFilter, UserDetailWhereInput> | null
    XUserRoles?: XUserRolesListRelationFilter
    preferences?: VentureCategoryListRelationFilter
    XUserPreferences?: XUserPreferencesListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    picture?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboardingCompleted?: SortOrder
    userDetailId?: SortOrderInput | SortOrder
    comments?: CommentOrderByRelationAggregateInput
    eventDonations?: EventDonationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    publicationClaps?: PublicationClapOrderByRelationAggregateInput
    ventures?: VentureOrderByRelationAggregateInput
    ventureSponsorships?: VentureSponsorshipOrderByRelationAggregateInput
    ventureSubscriptions?: VentureSubscriptionOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    detail?: UserDetailOrderByWithRelationInput
    XUserRoles?: XUserRolesOrderByRelationAggregateInput
    preferences?: VentureCategoryOrderByRelationAggregateInput
    XUserPreferences?: XUserPreferencesOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    userDetailId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    picture?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    verified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    onboardingCompleted?: BoolFilter<"User"> | boolean
    comments?: CommentListRelationFilter
    eventDonations?: EventDonationListRelationFilter
    notifications?: NotificationListRelationFilter
    publicationClaps?: PublicationClapListRelationFilter
    ventures?: VentureListRelationFilter
    ventureSponsorships?: VentureSponsorshipListRelationFilter
    ventureSubscriptions?: VentureSubscriptionListRelationFilter
    roles?: RoleListRelationFilter
    detail?: XOR<UserDetailNullableRelationFilter, UserDetailWhereInput> | null
    XUserRoles?: XUserRolesListRelationFilter
    preferences?: VentureCategoryListRelationFilter
    XUserPreferences?: XUserPreferencesListRelationFilter
  }, "id" | "email" | "userDetailId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    picture?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboardingCompleted?: SortOrder
    userDetailId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    picture?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    active?: BoolWithAggregatesFilter<"User"> | boolean
    verified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    onboardingCompleted?: BoolWithAggregatesFilter<"User"> | boolean
    userDetailId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type XUserPreferencesWhereInput = {
    AND?: XUserPreferencesWhereInput | XUserPreferencesWhereInput[]
    OR?: XUserPreferencesWhereInput[]
    NOT?: XUserPreferencesWhereInput | XUserPreferencesWhereInput[]
    userId?: StringFilter<"XUserPreferences"> | string
    categoryId?: StringFilter<"XUserPreferences"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureCategory?: XOR<VentureCategoryRelationFilter, VentureCategoryWhereInput>
  }

  export type XUserPreferencesOrderByWithRelationInput = {
    userId?: SortOrder
    categoryId?: SortOrder
    User?: UserOrderByWithRelationInput
    VentureCategory?: VentureCategoryOrderByWithRelationInput
  }

  export type XUserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    userId_categoryId?: XUserPreferencesUserIdCategoryIdCompoundUniqueInput
    AND?: XUserPreferencesWhereInput | XUserPreferencesWhereInput[]
    OR?: XUserPreferencesWhereInput[]
    NOT?: XUserPreferencesWhereInput | XUserPreferencesWhereInput[]
    userId?: StringFilter<"XUserPreferences"> | string
    categoryId?: StringFilter<"XUserPreferences"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureCategory?: XOR<VentureCategoryRelationFilter, VentureCategoryWhereInput>
  }, "userId_categoryId">

  export type XUserPreferencesOrderByWithAggregationInput = {
    userId?: SortOrder
    categoryId?: SortOrder
    _count?: XUserPreferencesCountOrderByAggregateInput
    _max?: XUserPreferencesMaxOrderByAggregateInput
    _min?: XUserPreferencesMinOrderByAggregateInput
  }

  export type XUserPreferencesScalarWhereWithAggregatesInput = {
    AND?: XUserPreferencesScalarWhereWithAggregatesInput | XUserPreferencesScalarWhereWithAggregatesInput[]
    OR?: XUserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: XUserPreferencesScalarWhereWithAggregatesInput | XUserPreferencesScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"XUserPreferences"> | string
    categoryId?: StringWithAggregatesFilter<"XUserPreferences"> | string
  }

  export type UserDetailWhereInput = {
    AND?: UserDetailWhereInput | UserDetailWhereInput[]
    OR?: UserDetailWhereInput[]
    NOT?: UserDetailWhereInput | UserDetailWhereInput[]
    id?: StringFilter<"UserDetail"> | string
    gender?: StringFilter<"UserDetail"> | string
    birthDate?: DateTimeFilter<"UserDetail"> | Date | string
    municipalityId?: IntFilter<"UserDetail"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    municipality?: XOR<MunicipalityRelationFilter, MunicipalityWhereInput>
  }

  export type UserDetailOrderByWithRelationInput = {
    id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    municipalityId?: SortOrder
    user?: UserOrderByWithRelationInput
    municipality?: MunicipalityOrderByWithRelationInput
  }

  export type UserDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserDetailWhereInput | UserDetailWhereInput[]
    OR?: UserDetailWhereInput[]
    NOT?: UserDetailWhereInput | UserDetailWhereInput[]
    gender?: StringFilter<"UserDetail"> | string
    birthDate?: DateTimeFilter<"UserDetail"> | Date | string
    municipalityId?: IntFilter<"UserDetail"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    municipality?: XOR<MunicipalityRelationFilter, MunicipalityWhereInput>
  }, "id">

  export type UserDetailOrderByWithAggregationInput = {
    id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    municipalityId?: SortOrder
    _count?: UserDetailCountOrderByAggregateInput
    _avg?: UserDetailAvgOrderByAggregateInput
    _max?: UserDetailMaxOrderByAggregateInput
    _min?: UserDetailMinOrderByAggregateInput
    _sum?: UserDetailSumOrderByAggregateInput
  }

  export type UserDetailScalarWhereWithAggregatesInput = {
    AND?: UserDetailScalarWhereWithAggregatesInput | UserDetailScalarWhereWithAggregatesInput[]
    OR?: UserDetailScalarWhereWithAggregatesInput[]
    NOT?: UserDetailScalarWhereWithAggregatesInput | UserDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDetail"> | string
    gender?: StringWithAggregatesFilter<"UserDetail"> | string
    birthDate?: DateTimeWithAggregatesFilter<"UserDetail"> | Date | string
    municipalityId?: IntWithAggregatesFilter<"UserDetail"> | number
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    municipalities?: MunicipalityListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    municipalities?: MunicipalityOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    municipalities?: MunicipalityListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type MunicipalityWhereInput = {
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    id?: IntFilter<"Municipality"> | number
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
    updatedAt?: DateTimeFilter<"Municipality"> | Date | string
    Department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    UserDetail?: UserDetailListRelationFilter
  }

  export type MunicipalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Department?: DepartmentOrderByWithRelationInput
    UserDetail?: UserDetailOrderByRelationAggregateInput
  }

  export type MunicipalityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
    updatedAt?: DateTimeFilter<"Municipality"> | Date | string
    Department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    UserDetail?: UserDetailListRelationFilter
  }, "id">

  export type MunicipalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MunicipalityCountOrderByAggregateInput
    _avg?: MunicipalityAvgOrderByAggregateInput
    _max?: MunicipalityMaxOrderByAggregateInput
    _min?: MunicipalityMinOrderByAggregateInput
    _sum?: MunicipalitySumOrderByAggregateInput
  }

  export type MunicipalityScalarWhereWithAggregatesInput = {
    AND?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    OR?: MunicipalityScalarWhereWithAggregatesInput[]
    NOT?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Municipality"> | number
    name?: StringWithAggregatesFilter<"Municipality"> | string
    departmentId?: IntWithAggregatesFilter<"Municipality"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Municipality"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Municipality"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    VenturePublication?: VenturePublicationOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    publicationId?: StringWithAggregatesFilter<"Comment"> | string
    body?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type EventCategoryWhereInput = {
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    id?: StringFilter<"EventCategory"> | string
    name?: StringFilter<"EventCategory"> | string
    slug?: StringFilter<"EventCategory"> | string
    description?: StringFilter<"EventCategory"> | string
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
    updatedAt?: DateTimeFilter<"EventCategory"> | Date | string
    XEventCategory?: XEventCategoryListRelationFilter
    VentureEvent?: VentureEventListRelationFilter
  }

  export type EventCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    XEventCategory?: XEventCategoryOrderByRelationAggregateInput
    VentureEvent?: VentureEventOrderByRelationAggregateInput
  }

  export type EventCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    description?: StringFilter<"EventCategory"> | string
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
    updatedAt?: DateTimeFilter<"EventCategory"> | Date | string
    XEventCategory?: XEventCategoryListRelationFilter
    VentureEvent?: VentureEventListRelationFilter
  }, "id" | "name" | "slug">

  export type EventCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCategoryCountOrderByAggregateInput
    _max?: EventCategoryMaxOrderByAggregateInput
    _min?: EventCategoryMinOrderByAggregateInput
  }

  export type EventCategoryScalarWhereWithAggregatesInput = {
    AND?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    OR?: EventCategoryScalarWhereWithAggregatesInput[]
    NOT?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventCategory"> | string
    name?: StringWithAggregatesFilter<"EventCategory"> | string
    slug?: StringWithAggregatesFilter<"EventCategory"> | string
    description?: StringWithAggregatesFilter<"EventCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventCategory"> | Date | string
  }

  export type EventDonationWhereInput = {
    AND?: EventDonationWhereInput | EventDonationWhereInput[]
    OR?: EventDonationWhereInput[]
    NOT?: EventDonationWhereInput | EventDonationWhereInput[]
    id?: StringFilter<"EventDonation"> | string
    userId?: StringFilter<"EventDonation"> | string
    eventId?: StringFilter<"EventDonation"> | string
    amount?: FloatFilter<"EventDonation"> | number
    currency?: StringFilter<"EventDonation"> | string
    createdAt?: DateTimeFilter<"EventDonation"> | Date | string
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventDonationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    VentureEvent?: VentureEventOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type EventDonationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventDonationWhereInput | EventDonationWhereInput[]
    OR?: EventDonationWhereInput[]
    NOT?: EventDonationWhereInput | EventDonationWhereInput[]
    userId?: StringFilter<"EventDonation"> | string
    eventId?: StringFilter<"EventDonation"> | string
    amount?: FloatFilter<"EventDonation"> | number
    currency?: StringFilter<"EventDonation"> | string
    createdAt?: DateTimeFilter<"EventDonation"> | Date | string
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EventDonationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    _count?: EventDonationCountOrderByAggregateInput
    _avg?: EventDonationAvgOrderByAggregateInput
    _max?: EventDonationMaxOrderByAggregateInput
    _min?: EventDonationMinOrderByAggregateInput
    _sum?: EventDonationSumOrderByAggregateInput
  }

  export type EventDonationScalarWhereWithAggregatesInput = {
    AND?: EventDonationScalarWhereWithAggregatesInput | EventDonationScalarWhereWithAggregatesInput[]
    OR?: EventDonationScalarWhereWithAggregatesInput[]
    NOT?: EventDonationScalarWhereWithAggregatesInput | EventDonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventDonation"> | string
    userId?: StringWithAggregatesFilter<"EventDonation"> | string
    eventId?: StringWithAggregatesFilter<"EventDonation"> | string
    amount?: FloatWithAggregatesFilter<"EventDonation"> | number
    currency?: StringWithAggregatesFilter<"EventDonation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventDonation"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    ventureEventId?: StringFilter<"Location"> | string
    lat?: FloatNullableFilter<"Location"> | number | null
    lng?: FloatNullableFilter<"Location"> | number | null
    description?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    ventureEventId?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    VentureEvent?: VentureEventOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    ventureEventId?: StringFilter<"Location"> | string
    lat?: FloatNullableFilter<"Location"> | number | null
    lng?: FloatNullableFilter<"Location"> | number | null
    description?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    ventureEventId?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    ventureEventId?: StringWithAggregatesFilter<"Location"> | string
    lat?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    description?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    description?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    description?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PublicationClapWhereInput = {
    AND?: PublicationClapWhereInput | PublicationClapWhereInput[]
    OR?: PublicationClapWhereInput[]
    NOT?: PublicationClapWhereInput | PublicationClapWhereInput[]
    id?: StringFilter<"PublicationClap"> | string
    userId?: StringFilter<"PublicationClap"> | string
    publicationId?: StringFilter<"PublicationClap"> | string
    createdAt?: DateTimeFilter<"PublicationClap"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PublicationClapOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    VenturePublication?: VenturePublicationOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type PublicationClapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicationClapWhereInput | PublicationClapWhereInput[]
    OR?: PublicationClapWhereInput[]
    NOT?: PublicationClapWhereInput | PublicationClapWhereInput[]
    userId?: StringFilter<"PublicationClap"> | string
    publicationId?: StringFilter<"PublicationClap"> | string
    createdAt?: DateTimeFilter<"PublicationClap"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PublicationClapOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    _count?: PublicationClapCountOrderByAggregateInput
    _max?: PublicationClapMaxOrderByAggregateInput
    _min?: PublicationClapMinOrderByAggregateInput
  }

  export type PublicationClapScalarWhereWithAggregatesInput = {
    AND?: PublicationClapScalarWhereWithAggregatesInput | PublicationClapScalarWhereWithAggregatesInput[]
    OR?: PublicationClapScalarWhereWithAggregatesInput[]
    NOT?: PublicationClapScalarWhereWithAggregatesInput | PublicationClapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicationClap"> | string
    userId?: StringWithAggregatesFilter<"PublicationClap"> | string
    publicationId?: StringWithAggregatesFilter<"PublicationClap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PublicationClap"> | Date | string
  }

  export type PublicationContentWhereInput = {
    AND?: PublicationContentWhereInput | PublicationContentWhereInput[]
    OR?: PublicationContentWhereInput[]
    NOT?: PublicationContentWhereInput | PublicationContentWhereInput[]
    id?: StringFilter<"PublicationContent"> | string
    type?: EnumContentTypeFilter<"PublicationContent"> | $Enums.ContentType
    content?: StringFilter<"PublicationContent"> | string
    publicationId?: StringFilter<"PublicationContent"> | string
    createdAt?: DateTimeFilter<"PublicationContent"> | Date | string
    updatedAt?: DateTimeFilter<"PublicationContent"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
  }

  export type PublicationContentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    VenturePublication?: VenturePublicationOrderByWithRelationInput
  }

  export type PublicationContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicationContentWhereInput | PublicationContentWhereInput[]
    OR?: PublicationContentWhereInput[]
    NOT?: PublicationContentWhereInput | PublicationContentWhereInput[]
    type?: EnumContentTypeFilter<"PublicationContent"> | $Enums.ContentType
    content?: StringFilter<"PublicationContent"> | string
    publicationId?: StringFilter<"PublicationContent"> | string
    createdAt?: DateTimeFilter<"PublicationContent"> | Date | string
    updatedAt?: DateTimeFilter<"PublicationContent"> | Date | string
    VenturePublication?: XOR<VenturePublicationRelationFilter, VenturePublicationWhereInput>
  }, "id">

  export type PublicationContentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicationContentCountOrderByAggregateInput
    _max?: PublicationContentMaxOrderByAggregateInput
    _min?: PublicationContentMinOrderByAggregateInput
  }

  export type PublicationContentScalarWhereWithAggregatesInput = {
    AND?: PublicationContentScalarWhereWithAggregatesInput | PublicationContentScalarWhereWithAggregatesInput[]
    OR?: PublicationContentScalarWhereWithAggregatesInput[]
    NOT?: PublicationContentScalarWhereWithAggregatesInput | PublicationContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicationContent"> | string
    type?: EnumContentTypeWithAggregatesFilter<"PublicationContent"> | $Enums.ContentType
    content?: StringWithAggregatesFilter<"PublicationContent"> | string
    publicationId?: StringWithAggregatesFilter<"PublicationContent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PublicationContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PublicationContent"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: EnumAppRoleFilter<"Role"> | $Enums.AppRole
    label?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    XUserRoles?: XUserRolesListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    XUserRoles?: XUserRolesOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: $Enums.AppRole
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    label?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    XUserRoles?: XUserRolesListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: EnumAppRoleWithAggregatesFilter<"Role"> | $Enums.AppRole
    label?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type VentureWhereInput = {
    AND?: VentureWhereInput | VentureWhereInput[]
    OR?: VentureWhereInput[]
    NOT?: VentureWhereInput | VentureWhereInput[]
    id?: StringFilter<"Venture"> | string
    name?: StringFilter<"Venture"> | string
    slug?: StringFilter<"Venture"> | string
    coverPhoto?: StringFilter<"Venture"> | string
    description?: StringFilter<"Venture"> | string
    ownerId?: StringFilter<"Venture"> | string
    active?: BoolFilter<"Venture"> | boolean
    verified?: BoolFilter<"Venture"> | boolean
    detailId?: StringFilter<"Venture"> | string
    createdAt?: DateTimeFilter<"Venture"> | Date | string
    updatedAt?: DateTimeFilter<"Venture"> | Date | string
    detail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    categories?: VentureCategoryListRelationFilter
    XVentureVencureCategory?: XVentureVencureCategoryListRelationFilter
  }

  export type VentureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    coverPhoto?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    detailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    detail?: VentureDetailOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    categories?: VentureCategoryOrderByRelationAggregateInput
    XVentureVencureCategory?: XVentureVencureCategoryOrderByRelationAggregateInput
  }

  export type VentureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    detailId?: string
    AND?: VentureWhereInput | VentureWhereInput[]
    OR?: VentureWhereInput[]
    NOT?: VentureWhereInput | VentureWhereInput[]
    name?: StringFilter<"Venture"> | string
    coverPhoto?: StringFilter<"Venture"> | string
    description?: StringFilter<"Venture"> | string
    ownerId?: StringFilter<"Venture"> | string
    active?: BoolFilter<"Venture"> | boolean
    verified?: BoolFilter<"Venture"> | boolean
    createdAt?: DateTimeFilter<"Venture"> | Date | string
    updatedAt?: DateTimeFilter<"Venture"> | Date | string
    detail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    categories?: VentureCategoryListRelationFilter
    XVentureVencureCategory?: XVentureVencureCategoryListRelationFilter
  }, "id" | "slug" | "detailId">

  export type VentureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    coverPhoto?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    detailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VentureCountOrderByAggregateInput
    _max?: VentureMaxOrderByAggregateInput
    _min?: VentureMinOrderByAggregateInput
  }

  export type VentureScalarWhereWithAggregatesInput = {
    AND?: VentureScalarWhereWithAggregatesInput | VentureScalarWhereWithAggregatesInput[]
    OR?: VentureScalarWhereWithAggregatesInput[]
    NOT?: VentureScalarWhereWithAggregatesInput | VentureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Venture"> | string
    name?: StringWithAggregatesFilter<"Venture"> | string
    slug?: StringWithAggregatesFilter<"Venture"> | string
    coverPhoto?: StringWithAggregatesFilter<"Venture"> | string
    description?: StringWithAggregatesFilter<"Venture"> | string
    ownerId?: StringWithAggregatesFilter<"Venture"> | string
    active?: BoolWithAggregatesFilter<"Venture"> | boolean
    verified?: BoolWithAggregatesFilter<"Venture"> | boolean
    detailId?: StringWithAggregatesFilter<"Venture"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Venture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venture"> | Date | string
  }

  export type XVentureVencureCategoryWhereInput = {
    AND?: XVentureVencureCategoryWhereInput | XVentureVencureCategoryWhereInput[]
    OR?: XVentureVencureCategoryWhereInput[]
    NOT?: XVentureVencureCategoryWhereInput | XVentureVencureCategoryWhereInput[]
    ventureId?: StringFilter<"XVentureVencureCategory"> | string
    categoryId?: StringFilter<"XVentureVencureCategory"> | string
    Venture?: XOR<VentureRelationFilter, VentureWhereInput>
    VentureCategory?: XOR<VentureCategoryRelationFilter, VentureCategoryWhereInput>
  }

  export type XVentureVencureCategoryOrderByWithRelationInput = {
    ventureId?: SortOrder
    categoryId?: SortOrder
    Venture?: VentureOrderByWithRelationInput
    VentureCategory?: VentureCategoryOrderByWithRelationInput
  }

  export type XVentureVencureCategoryWhereUniqueInput = Prisma.AtLeast<{
    ventureId_categoryId?: XVentureVencureCategoryVentureIdCategoryIdCompoundUniqueInput
    AND?: XVentureVencureCategoryWhereInput | XVentureVencureCategoryWhereInput[]
    OR?: XVentureVencureCategoryWhereInput[]
    NOT?: XVentureVencureCategoryWhereInput | XVentureVencureCategoryWhereInput[]
    ventureId?: StringFilter<"XVentureVencureCategory"> | string
    categoryId?: StringFilter<"XVentureVencureCategory"> | string
    Venture?: XOR<VentureRelationFilter, VentureWhereInput>
    VentureCategory?: XOR<VentureCategoryRelationFilter, VentureCategoryWhereInput>
  }, "ventureId_categoryId">

  export type XVentureVencureCategoryOrderByWithAggregationInput = {
    ventureId?: SortOrder
    categoryId?: SortOrder
    _count?: XVentureVencureCategoryCountOrderByAggregateInput
    _max?: XVentureVencureCategoryMaxOrderByAggregateInput
    _min?: XVentureVencureCategoryMinOrderByAggregateInput
  }

  export type XVentureVencureCategoryScalarWhereWithAggregatesInput = {
    AND?: XVentureVencureCategoryScalarWhereWithAggregatesInput | XVentureVencureCategoryScalarWhereWithAggregatesInput[]
    OR?: XVentureVencureCategoryScalarWhereWithAggregatesInput[]
    NOT?: XVentureVencureCategoryScalarWhereWithAggregatesInput | XVentureVencureCategoryScalarWhereWithAggregatesInput[]
    ventureId?: StringWithAggregatesFilter<"XVentureVencureCategory"> | string
    categoryId?: StringWithAggregatesFilter<"XVentureVencureCategory"> | string
  }

  export type VentureCategoryWhereInput = {
    AND?: VentureCategoryWhereInput | VentureCategoryWhereInput[]
    OR?: VentureCategoryWhereInput[]
    NOT?: VentureCategoryWhereInput | VentureCategoryWhereInput[]
    id?: StringFilter<"VentureCategory"> | string
    name?: StringFilter<"VentureCategory"> | string
    slug?: StringFilter<"VentureCategory"> | string
    description?: StringFilter<"VentureCategory"> | string
    createdAt?: DateTimeFilter<"VentureCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VentureCategory"> | Date | string
    users?: UserListRelationFilter
    XUserPreferences?: XUserPreferencesListRelationFilter
    ventures?: VentureListRelationFilter
    XVentureVencureCategory?: XVentureVencureCategoryListRelationFilter
  }

  export type VentureCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    XUserPreferences?: XUserPreferencesOrderByRelationAggregateInput
    ventures?: VentureOrderByRelationAggregateInput
    XVentureVencureCategory?: XVentureVencureCategoryOrderByRelationAggregateInput
  }

  export type VentureCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VentureCategoryWhereInput | VentureCategoryWhereInput[]
    OR?: VentureCategoryWhereInput[]
    NOT?: VentureCategoryWhereInput | VentureCategoryWhereInput[]
    name?: StringFilter<"VentureCategory"> | string
    description?: StringFilter<"VentureCategory"> | string
    createdAt?: DateTimeFilter<"VentureCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VentureCategory"> | Date | string
    users?: UserListRelationFilter
    XUserPreferences?: XUserPreferencesListRelationFilter
    ventures?: VentureListRelationFilter
    XVentureVencureCategory?: XVentureVencureCategoryListRelationFilter
  }, "id" | "slug">

  export type VentureCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VentureCategoryCountOrderByAggregateInput
    _max?: VentureCategoryMaxOrderByAggregateInput
    _min?: VentureCategoryMinOrderByAggregateInput
  }

  export type VentureCategoryScalarWhereWithAggregatesInput = {
    AND?: VentureCategoryScalarWhereWithAggregatesInput | VentureCategoryScalarWhereWithAggregatesInput[]
    OR?: VentureCategoryScalarWhereWithAggregatesInput[]
    NOT?: VentureCategoryScalarWhereWithAggregatesInput | VentureCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VentureCategory"> | string
    name?: StringWithAggregatesFilter<"VentureCategory"> | string
    slug?: StringWithAggregatesFilter<"VentureCategory"> | string
    description?: StringWithAggregatesFilter<"VentureCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VentureCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VentureCategory"> | Date | string
  }

  export type VentureDetailWhereInput = {
    AND?: VentureDetailWhereInput | VentureDetailWhereInput[]
    OR?: VentureDetailWhereInput[]
    NOT?: VentureDetailWhereInput | VentureDetailWhereInput[]
    id?: StringFilter<"VentureDetail"> | string
    createdAt?: DateTimeFilter<"VentureDetail"> | Date | string
    updatedAt?: DateTimeFilter<"VentureDetail"> | Date | string
    Venture?: XOR<VentureNullableRelationFilter, VentureWhereInput> | null
    event?: VentureEventListRelationFilter
    publications?: VenturePublicationListRelationFilter
    sponsorship?: VentureSponsorshipListRelationFilter
    subscription?: VentureSubscriptionListRelationFilter
  }

  export type VentureDetailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Venture?: VentureOrderByWithRelationInput
    event?: VentureEventOrderByRelationAggregateInput
    publications?: VenturePublicationOrderByRelationAggregateInput
    sponsorship?: VentureSponsorshipOrderByRelationAggregateInput
    subscription?: VentureSubscriptionOrderByRelationAggregateInput
  }

  export type VentureDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VentureDetailWhereInput | VentureDetailWhereInput[]
    OR?: VentureDetailWhereInput[]
    NOT?: VentureDetailWhereInput | VentureDetailWhereInput[]
    createdAt?: DateTimeFilter<"VentureDetail"> | Date | string
    updatedAt?: DateTimeFilter<"VentureDetail"> | Date | string
    Venture?: XOR<VentureNullableRelationFilter, VentureWhereInput> | null
    event?: VentureEventListRelationFilter
    publications?: VenturePublicationListRelationFilter
    sponsorship?: VentureSponsorshipListRelationFilter
    subscription?: VentureSubscriptionListRelationFilter
  }, "id">

  export type VentureDetailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VentureDetailCountOrderByAggregateInput
    _max?: VentureDetailMaxOrderByAggregateInput
    _min?: VentureDetailMinOrderByAggregateInput
  }

  export type VentureDetailScalarWhereWithAggregatesInput = {
    AND?: VentureDetailScalarWhereWithAggregatesInput | VentureDetailScalarWhereWithAggregatesInput[]
    OR?: VentureDetailScalarWhereWithAggregatesInput[]
    NOT?: VentureDetailScalarWhereWithAggregatesInput | VentureDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VentureDetail"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VentureDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VentureDetail"> | Date | string
  }

  export type VentureEventWhereInput = {
    AND?: VentureEventWhereInput | VentureEventWhereInput[]
    OR?: VentureEventWhereInput[]
    NOT?: VentureEventWhereInput | VentureEventWhereInput[]
    id?: StringFilter<"VentureEvent"> | string
    title?: StringFilter<"VentureEvent"> | string
    description?: StringFilter<"VentureEvent"> | string
    coverPhoto?: StringFilter<"VentureEvent"> | string
    ventureId?: StringFilter<"VentureEvent"> | string
    startDate?: DateTimeFilter<"VentureEvent"> | Date | string
    endDate?: DateTimeFilter<"VentureEvent"> | Date | string
    createdAt?: DateTimeFilter<"VentureEvent"> | Date | string
    updatedAt?: DateTimeFilter<"VentureEvent"> | Date | string
    EventDonation?: EventDonationListRelationFilter
    Location?: LocationListRelationFilter
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
    XEventCategory?: XEventCategoryListRelationFilter
    EventCategory?: EventCategoryListRelationFilter
  }

  export type VentureEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverPhoto?: SortOrder
    ventureId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    EventDonation?: EventDonationOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
    VentureDetail?: VentureDetailOrderByWithRelationInput
    XEventCategory?: XEventCategoryOrderByRelationAggregateInput
    EventCategory?: EventCategoryOrderByRelationAggregateInput
  }

  export type VentureEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VentureEventWhereInput | VentureEventWhereInput[]
    OR?: VentureEventWhereInput[]
    NOT?: VentureEventWhereInput | VentureEventWhereInput[]
    title?: StringFilter<"VentureEvent"> | string
    description?: StringFilter<"VentureEvent"> | string
    coverPhoto?: StringFilter<"VentureEvent"> | string
    ventureId?: StringFilter<"VentureEvent"> | string
    startDate?: DateTimeFilter<"VentureEvent"> | Date | string
    endDate?: DateTimeFilter<"VentureEvent"> | Date | string
    createdAt?: DateTimeFilter<"VentureEvent"> | Date | string
    updatedAt?: DateTimeFilter<"VentureEvent"> | Date | string
    EventDonation?: EventDonationListRelationFilter
    Location?: LocationListRelationFilter
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
    XEventCategory?: XEventCategoryListRelationFilter
    EventCategory?: EventCategoryListRelationFilter
  }, "id">

  export type VentureEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverPhoto?: SortOrder
    ventureId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VentureEventCountOrderByAggregateInput
    _max?: VentureEventMaxOrderByAggregateInput
    _min?: VentureEventMinOrderByAggregateInput
  }

  export type VentureEventScalarWhereWithAggregatesInput = {
    AND?: VentureEventScalarWhereWithAggregatesInput | VentureEventScalarWhereWithAggregatesInput[]
    OR?: VentureEventScalarWhereWithAggregatesInput[]
    NOT?: VentureEventScalarWhereWithAggregatesInput | VentureEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VentureEvent"> | string
    title?: StringWithAggregatesFilter<"VentureEvent"> | string
    description?: StringWithAggregatesFilter<"VentureEvent"> | string
    coverPhoto?: StringWithAggregatesFilter<"VentureEvent"> | string
    ventureId?: StringWithAggregatesFilter<"VentureEvent"> | string
    startDate?: DateTimeWithAggregatesFilter<"VentureEvent"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"VentureEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VentureEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VentureEvent"> | Date | string
  }

  export type VenturePublicationWhereInput = {
    AND?: VenturePublicationWhereInput | VenturePublicationWhereInput[]
    OR?: VenturePublicationWhereInput[]
    NOT?: VenturePublicationWhereInput | VenturePublicationWhereInput[]
    id?: StringFilter<"VenturePublication"> | string
    description?: StringFilter<"VenturePublication"> | string
    detailId?: StringFilter<"VenturePublication"> | string
    type?: EnumPublicationTypeFilter<"VenturePublication"> | $Enums.PublicationType
    clapsCount?: IntFilter<"VenturePublication"> | number
    createdAt?: DateTimeFilter<"VenturePublication"> | Date | string
    updatedAt?: DateTimeFilter<"VenturePublication"> | Date | string
    Comment?: CommentListRelationFilter
    PublicationClap?: PublicationClapListRelationFilter
    PublicationContent?: PublicationContentListRelationFilter
    detail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }

  export type VenturePublicationOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    detailId?: SortOrder
    type?: SortOrder
    clapsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Comment?: CommentOrderByRelationAggregateInput
    PublicationClap?: PublicationClapOrderByRelationAggregateInput
    PublicationContent?: PublicationContentOrderByRelationAggregateInput
    detail?: VentureDetailOrderByWithRelationInput
  }

  export type VenturePublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenturePublicationWhereInput | VenturePublicationWhereInput[]
    OR?: VenturePublicationWhereInput[]
    NOT?: VenturePublicationWhereInput | VenturePublicationWhereInput[]
    description?: StringFilter<"VenturePublication"> | string
    detailId?: StringFilter<"VenturePublication"> | string
    type?: EnumPublicationTypeFilter<"VenturePublication"> | $Enums.PublicationType
    clapsCount?: IntFilter<"VenturePublication"> | number
    createdAt?: DateTimeFilter<"VenturePublication"> | Date | string
    updatedAt?: DateTimeFilter<"VenturePublication"> | Date | string
    Comment?: CommentListRelationFilter
    PublicationClap?: PublicationClapListRelationFilter
    PublicationContent?: PublicationContentListRelationFilter
    detail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }, "id">

  export type VenturePublicationOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    detailId?: SortOrder
    type?: SortOrder
    clapsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenturePublicationCountOrderByAggregateInput
    _avg?: VenturePublicationAvgOrderByAggregateInput
    _max?: VenturePublicationMaxOrderByAggregateInput
    _min?: VenturePublicationMinOrderByAggregateInput
    _sum?: VenturePublicationSumOrderByAggregateInput
  }

  export type VenturePublicationScalarWhereWithAggregatesInput = {
    AND?: VenturePublicationScalarWhereWithAggregatesInput | VenturePublicationScalarWhereWithAggregatesInput[]
    OR?: VenturePublicationScalarWhereWithAggregatesInput[]
    NOT?: VenturePublicationScalarWhereWithAggregatesInput | VenturePublicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VenturePublication"> | string
    description?: StringWithAggregatesFilter<"VenturePublication"> | string
    detailId?: StringWithAggregatesFilter<"VenturePublication"> | string
    type?: EnumPublicationTypeWithAggregatesFilter<"VenturePublication"> | $Enums.PublicationType
    clapsCount?: IntWithAggregatesFilter<"VenturePublication"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VenturePublication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VenturePublication"> | Date | string
  }

  export type VentureSponsorshipWhereInput = {
    AND?: VentureSponsorshipWhereInput | VentureSponsorshipWhereInput[]
    OR?: VentureSponsorshipWhereInput[]
    NOT?: VentureSponsorshipWhereInput | VentureSponsorshipWhereInput[]
    id?: StringFilter<"VentureSponsorship"> | string
    sponsorId?: StringFilter<"VentureSponsorship"> | string
    ventureDetailId?: StringFilter<"VentureSponsorship"> | string
    monthlyAmount?: FloatFilter<"VentureSponsorship"> | number
    createdAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
    updatedAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }

  export type VentureSponsorshipOrderByWithRelationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    ventureDetailId?: SortOrder
    monthlyAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    VentureDetail?: VentureDetailOrderByWithRelationInput
  }

  export type VentureSponsorshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VentureSponsorshipWhereInput | VentureSponsorshipWhereInput[]
    OR?: VentureSponsorshipWhereInput[]
    NOT?: VentureSponsorshipWhereInput | VentureSponsorshipWhereInput[]
    sponsorId?: StringFilter<"VentureSponsorship"> | string
    ventureDetailId?: StringFilter<"VentureSponsorship"> | string
    monthlyAmount?: FloatFilter<"VentureSponsorship"> | number
    createdAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
    updatedAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }, "id">

  export type VentureSponsorshipOrderByWithAggregationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    ventureDetailId?: SortOrder
    monthlyAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VentureSponsorshipCountOrderByAggregateInput
    _avg?: VentureSponsorshipAvgOrderByAggregateInput
    _max?: VentureSponsorshipMaxOrderByAggregateInput
    _min?: VentureSponsorshipMinOrderByAggregateInput
    _sum?: VentureSponsorshipSumOrderByAggregateInput
  }

  export type VentureSponsorshipScalarWhereWithAggregatesInput = {
    AND?: VentureSponsorshipScalarWhereWithAggregatesInput | VentureSponsorshipScalarWhereWithAggregatesInput[]
    OR?: VentureSponsorshipScalarWhereWithAggregatesInput[]
    NOT?: VentureSponsorshipScalarWhereWithAggregatesInput | VentureSponsorshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VentureSponsorship"> | string
    sponsorId?: StringWithAggregatesFilter<"VentureSponsorship"> | string
    ventureDetailId?: StringWithAggregatesFilter<"VentureSponsorship"> | string
    monthlyAmount?: FloatWithAggregatesFilter<"VentureSponsorship"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VentureSponsorship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VentureSponsorship"> | Date | string
  }

  export type VentureSubscriptionWhereInput = {
    AND?: VentureSubscriptionWhereInput | VentureSubscriptionWhereInput[]
    OR?: VentureSubscriptionWhereInput[]
    NOT?: VentureSubscriptionWhereInput | VentureSubscriptionWhereInput[]
    id?: StringFilter<"VentureSubscription"> | string
    subscriberId?: StringFilter<"VentureSubscription"> | string
    ventureId?: StringFilter<"VentureSubscription"> | string
    createdAt?: DateTimeFilter<"VentureSubscription"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }

  export type VentureSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    ventureId?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    VentureDetail?: VentureDetailOrderByWithRelationInput
  }

  export type VentureSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VentureSubscriptionWhereInput | VentureSubscriptionWhereInput[]
    OR?: VentureSubscriptionWhereInput[]
    NOT?: VentureSubscriptionWhereInput | VentureSubscriptionWhereInput[]
    subscriberId?: StringFilter<"VentureSubscription"> | string
    ventureId?: StringFilter<"VentureSubscription"> | string
    createdAt?: DateTimeFilter<"VentureSubscription"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    VentureDetail?: XOR<VentureDetailRelationFilter, VentureDetailWhereInput>
  }, "id">

  export type VentureSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    ventureId?: SortOrder
    createdAt?: SortOrder
    _count?: VentureSubscriptionCountOrderByAggregateInput
    _max?: VentureSubscriptionMaxOrderByAggregateInput
    _min?: VentureSubscriptionMinOrderByAggregateInput
  }

  export type VentureSubscriptionScalarWhereWithAggregatesInput = {
    AND?: VentureSubscriptionScalarWhereWithAggregatesInput | VentureSubscriptionScalarWhereWithAggregatesInput[]
    OR?: VentureSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: VentureSubscriptionScalarWhereWithAggregatesInput | VentureSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VentureSubscription"> | string
    subscriberId?: StringWithAggregatesFilter<"VentureSubscription"> | string
    ventureId?: StringWithAggregatesFilter<"VentureSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VentureSubscription"> | Date | string
  }

  export type XEventCategoryWhereInput = {
    AND?: XEventCategoryWhereInput | XEventCategoryWhereInput[]
    OR?: XEventCategoryWhereInput[]
    NOT?: XEventCategoryWhereInput | XEventCategoryWhereInput[]
    eventId?: StringFilter<"XEventCategory"> | string
    categoryId?: StringFilter<"XEventCategory"> | string
    EventCategory?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
  }

  export type XEventCategoryOrderByWithRelationInput = {
    eventId?: SortOrder
    categoryId?: SortOrder
    EventCategory?: EventCategoryOrderByWithRelationInput
    VentureEvent?: VentureEventOrderByWithRelationInput
  }

  export type XEventCategoryWhereUniqueInput = Prisma.AtLeast<{
    eventId_categoryId?: XEventCategoryEventIdCategoryIdCompoundUniqueInput
    AND?: XEventCategoryWhereInput | XEventCategoryWhereInput[]
    OR?: XEventCategoryWhereInput[]
    NOT?: XEventCategoryWhereInput | XEventCategoryWhereInput[]
    eventId?: StringFilter<"XEventCategory"> | string
    categoryId?: StringFilter<"XEventCategory"> | string
    EventCategory?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    VentureEvent?: XOR<VentureEventRelationFilter, VentureEventWhereInput>
  }, "eventId_categoryId">

  export type XEventCategoryOrderByWithAggregationInput = {
    eventId?: SortOrder
    categoryId?: SortOrder
    _count?: XEventCategoryCountOrderByAggregateInput
    _max?: XEventCategoryMaxOrderByAggregateInput
    _min?: XEventCategoryMinOrderByAggregateInput
  }

  export type XEventCategoryScalarWhereWithAggregatesInput = {
    AND?: XEventCategoryScalarWhereWithAggregatesInput | XEventCategoryScalarWhereWithAggregatesInput[]
    OR?: XEventCategoryScalarWhereWithAggregatesInput[]
    NOT?: XEventCategoryScalarWhereWithAggregatesInput | XEventCategoryScalarWhereWithAggregatesInput[]
    eventId?: StringWithAggregatesFilter<"XEventCategory"> | string
    categoryId?: StringWithAggregatesFilter<"XEventCategory"> | string
  }

  export type XUserRolesWhereInput = {
    AND?: XUserRolesWhereInput | XUserRolesWhereInput[]
    OR?: XUserRolesWhereInput[]
    NOT?: XUserRolesWhereInput | XUserRolesWhereInput[]
    id?: StringFilter<"XUserRoles"> | string
    userId?: StringFilter<"XUserRoles"> | string
    roleId?: StringFilter<"XUserRoles"> | string
    createdAt?: DateTimeFilter<"XUserRoles"> | Date | string
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type XUserRolesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    Role?: RoleOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type XUserRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: XUserRolesWhereInput | XUserRolesWhereInput[]
    OR?: XUserRolesWhereInput[]
    NOT?: XUserRolesWhereInput | XUserRolesWhereInput[]
    userId?: StringFilter<"XUserRoles"> | string
    roleId?: StringFilter<"XUserRoles"> | string
    createdAt?: DateTimeFilter<"XUserRoles"> | Date | string
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type XUserRolesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    _count?: XUserRolesCountOrderByAggregateInput
    _max?: XUserRolesMaxOrderByAggregateInput
    _min?: XUserRolesMinOrderByAggregateInput
  }

  export type XUserRolesScalarWhereWithAggregatesInput = {
    AND?: XUserRolesScalarWhereWithAggregatesInput | XUserRolesScalarWhereWithAggregatesInput[]
    OR?: XUserRolesScalarWhereWithAggregatesInput[]
    NOT?: XUserRolesScalarWhereWithAggregatesInput | XUserRolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XUserRoles"> | string
    userId?: StringWithAggregatesFilter<"XUserRoles"> | string
    roleId?: StringWithAggregatesFilter<"XUserRoles"> | string
    createdAt?: DateTimeWithAggregatesFilter<"XUserRoles"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type XUserPreferencesCreateInput = {
    User: UserCreateNestedOneWithoutXUserPreferencesInput
    VentureCategory: VentureCategoryCreateNestedOneWithoutXUserPreferencesInput
  }

  export type XUserPreferencesUncheckedCreateInput = {
    userId: string
    categoryId: string
  }

  export type XUserPreferencesUpdateInput = {
    User?: UserUpdateOneRequiredWithoutXUserPreferencesNestedInput
    VentureCategory?: VentureCategoryUpdateOneRequiredWithoutXUserPreferencesNestedInput
  }

  export type XUserPreferencesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XUserPreferencesCreateManyInput = {
    userId: string
    categoryId: string
  }

  export type XUserPreferencesUpdateManyMutationInput = {

  }

  export type XUserPreferencesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type UserDetailCreateInput = {
    id?: string
    gender: string
    birthDate: Date | string
    user?: UserCreateNestedOneWithoutDetailInput
    municipality: MunicipalityCreateNestedOneWithoutUserDetailInput
  }

  export type UserDetailUncheckedCreateInput = {
    id?: string
    gender: string
    birthDate: Date | string
    municipalityId: number
    user?: UserUncheckedCreateNestedOneWithoutDetailInput
  }

  export type UserDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDetailNestedInput
    municipality?: MunicipalityUpdateOneRequiredWithoutUserDetailNestedInput
  }

  export type UserDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalityId?: IntFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutDetailNestedInput
  }

  export type UserDetailCreateManyInput = {
    id?: string
    gender: string
    birthDate: Date | string
    municipalityId: number
  }

  export type UserDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalityId?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    municipalities?: MunicipalityCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalities?: MunicipalityUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalities?: MunicipalityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Department?: DepartmentCreateNestedOneWithoutMunicipalitiesInput
    UserDetail?: UserDetailCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateInput = {
    id?: number
    name: string
    departmentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    UserDetail?: UserDetailUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Department?: DepartmentUpdateOneWithoutMunicipalitiesNestedInput
    UserDetail?: UserDetailUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDetail?: UserDetailUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityCreateManyInput = {
    id?: number
    name: string
    departmentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MunicipalityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    VenturePublication: VenturePublicationCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userId: string
    publicationId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VenturePublication?: VenturePublicationUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    userId: string
    publicationId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XEventCategory?: XEventCategoryCreateNestedManyWithoutEventCategoryInput
    VentureEvent?: VentureEventCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutEventCategoryInput
    VentureEvent?: VentureEventUncheckedCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XEventCategory?: XEventCategoryUpdateManyWithoutEventCategoryNestedInput
    VentureEvent?: VentureEventUpdateManyWithoutEventCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutEventCategoryNestedInput
    VentureEvent?: VentureEventUncheckedUpdateManyWithoutEventCategoryNestedInput
  }

  export type EventCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationCreateInput = {
    id?: string
    amount: number
    currency: string
    createdAt?: Date | string
    VentureEvent: VentureEventCreateNestedOneWithoutEventDonationInput
    User: UserCreateNestedOneWithoutEventDonationsInput
  }

  export type EventDonationUncheckedCreateInput = {
    id?: string
    userId: string
    eventId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type EventDonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureEvent?: VentureEventUpdateOneRequiredWithoutEventDonationNestedInput
    User?: UserUpdateOneRequiredWithoutEventDonationsNestedInput
  }

  export type EventDonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationCreateManyInput = {
    id?: string
    userId: string
    eventId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type EventDonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    VentureEvent: VentureEventCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    ventureEventId: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureEvent?: VentureEventUpdateOneRequiredWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureEventId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyInput = {
    id?: string
    ventureEventId: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureEventId?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    userId: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    userId: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapCreateInput = {
    id: string
    createdAt?: Date | string
    VenturePublication: VenturePublicationCreateNestedOneWithoutPublicationClapInput
    User: UserCreateNestedOneWithoutPublicationClapsInput
  }

  export type PublicationClapUncheckedCreateInput = {
    id: string
    userId: string
    publicationId: string
    createdAt?: Date | string
  }

  export type PublicationClapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VenturePublication?: VenturePublicationUpdateOneRequiredWithoutPublicationClapNestedInput
    User?: UserUpdateOneRequiredWithoutPublicationClapsNestedInput
  }

  export type PublicationClapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapCreateManyInput = {
    id: string
    userId: string
    publicationId: string
    createdAt?: Date | string
  }

  export type PublicationClapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentCreateInput = {
    id: string
    type: $Enums.ContentType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    VenturePublication: VenturePublicationCreateNestedOneWithoutPublicationContentInput
  }

  export type PublicationContentUncheckedCreateInput = {
    id: string
    type: $Enums.ContentType
    content: string
    publicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VenturePublication?: VenturePublicationUpdateOneRequiredWithoutPublicationContentNestedInput
  }

  export type PublicationContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentCreateManyInput = {
    id: string
    type: $Enums.ContentType
    content: string
    publicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRolesInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRolesNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureCreateInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    detail: VentureDetailCreateNestedOneWithoutVentureInput
    owner: UserCreateNestedOneWithoutVenturesInput
    categories?: VentureCategoryCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureInput
  }

  export type VentureUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: VentureCategoryUncheckedCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureInput
  }

  export type VentureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: VentureDetailUpdateOneRequiredWithoutVentureNestedInput
    owner?: UserUpdateOneRequiredWithoutVenturesNestedInput
    categories?: VentureCategoryUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: VentureCategoryUncheckedUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureNestedInput
  }

  export type VentureCreateManyInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XVentureVencureCategoryCreateInput = {
    Venture: VentureCreateNestedOneWithoutXVentureVencureCategoryInput
    VentureCategory: VentureCategoryCreateNestedOneWithoutXVentureVencureCategoryInput
  }

  export type XVentureVencureCategoryUncheckedCreateInput = {
    ventureId: string
    categoryId: string
  }

  export type XVentureVencureCategoryUpdateInput = {
    Venture?: VentureUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput
    VentureCategory?: VentureCategoryUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput
  }

  export type XVentureVencureCategoryUncheckedUpdateInput = {
    ventureId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XVentureVencureCategoryCreateManyInput = {
    ventureId: string
    categoryId: string
  }

  export type XVentureVencureCategoryUpdateManyMutationInput = {

  }

  export type XVentureVencureCategoryUncheckedUpdateManyInput = {
    ventureId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type VentureCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureUncheckedCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureDetailCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureCreateNestedOneWithoutDetailInput
    event?: VentureEventCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureUncheckedCreateNestedOneWithoutDetailInput
    event?: VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationUncheckedCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUpdateOneWithoutDetailNestedInput
    event?: VentureEventUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUncheckedUpdateOneWithoutDetailNestedInput
    event?: VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureEventCreateInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationCreateNestedManyWithoutVentureEventInput
    Location?: LocationCreateNestedManyWithoutVentureEventInput
    VentureDetail: VentureDetailCreateNestedOneWithoutEventInput
    XEventCategory?: XEventCategoryCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationUncheckedCreateNestedManyWithoutVentureEventInput
    Location?: LocationUncheckedCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUpdateManyWithoutVentureEventNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutEventNestedInput
    XEventCategory?: XEventCategoryUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUncheckedUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventCreateManyInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenturePublicationCreateInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentCreateNestedManyWithoutVenturePublicationInput
    detail: VentureDetailCreateNestedOneWithoutPublicationsInput
  }

  export type VenturePublicationUncheckedCreateInput = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentUncheckedCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUpdateManyWithoutVenturePublicationNestedInput
    detail?: VentureDetailUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type VenturePublicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detailId?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUncheckedUpdateManyWithoutVenturePublicationNestedInput
  }

  export type VenturePublicationCreateManyInput = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenturePublicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenturePublicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detailId?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipCreateInput = {
    id: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutVentureSponsorshipsInput
    VentureDetail: VentureDetailCreateNestedOneWithoutSponsorshipInput
  }

  export type VentureSponsorshipUncheckedCreateInput = {
    id: string
    sponsorId: string
    ventureDetailId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutVentureSponsorshipsNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutSponsorshipNestedInput
  }

  export type VentureSponsorshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sponsorId?: StringFieldUpdateOperationsInput | string
    ventureDetailId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipCreateManyInput = {
    id: string
    sponsorId: string
    ventureDetailId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sponsorId?: StringFieldUpdateOperationsInput | string
    ventureDetailId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionCreateInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutVentureSubscriptionsInput
    VentureDetail: VentureDetailCreateNestedOneWithoutSubscriptionInput
  }

  export type VentureSubscriptionUncheckedCreateInput = {
    id: string
    subscriberId: string
    ventureId: string
    createdAt?: Date | string
  }

  export type VentureSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutVentureSubscriptionsNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type VentureSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionCreateManyInput = {
    id: string
    subscriberId: string
    ventureId: string
    createdAt?: Date | string
  }

  export type VentureSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XEventCategoryCreateInput = {
    EventCategory: EventCategoryCreateNestedOneWithoutXEventCategoryInput
    VentureEvent: VentureEventCreateNestedOneWithoutXEventCategoryInput
  }

  export type XEventCategoryUncheckedCreateInput = {
    eventId: string
    categoryId: string
  }

  export type XEventCategoryUpdateInput = {
    EventCategory?: EventCategoryUpdateOneRequiredWithoutXEventCategoryNestedInput
    VentureEvent?: VentureEventUpdateOneRequiredWithoutXEventCategoryNestedInput
  }

  export type XEventCategoryUncheckedUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XEventCategoryCreateManyInput = {
    eventId: string
    categoryId: string
  }

  export type XEventCategoryUpdateManyMutationInput = {

  }

  export type XEventCategoryUncheckedUpdateManyInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XUserRolesCreateInput = {
    id: string
    createdAt?: Date | string
    Role: RoleCreateNestedOneWithoutXUserRolesInput
    User: UserCreateNestedOneWithoutXUserRolesInput
  }

  export type XUserRolesUncheckedCreateInput = {
    id: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type XUserRolesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutXUserRolesNestedInput
    User?: UserUpdateOneRequiredWithoutXUserRolesNestedInput
  }

  export type XUserRolesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesCreateManyInput = {
    id: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type XUserRolesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type EventDonationListRelationFilter = {
    every?: EventDonationWhereInput
    some?: EventDonationWhereInput
    none?: EventDonationWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PublicationClapListRelationFilter = {
    every?: PublicationClapWhereInput
    some?: PublicationClapWhereInput
    none?: PublicationClapWhereInput
  }

  export type VentureListRelationFilter = {
    every?: VentureWhereInput
    some?: VentureWhereInput
    none?: VentureWhereInput
  }

  export type VentureSponsorshipListRelationFilter = {
    every?: VentureSponsorshipWhereInput
    some?: VentureSponsorshipWhereInput
    none?: VentureSponsorshipWhereInput
  }

  export type VentureSubscriptionListRelationFilter = {
    every?: VentureSubscriptionWhereInput
    some?: VentureSubscriptionWhereInput
    none?: VentureSubscriptionWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type UserDetailNullableRelationFilter = {
    is?: UserDetailWhereInput | null
    isNot?: UserDetailWhereInput | null
  }

  export type XUserRolesListRelationFilter = {
    every?: XUserRolesWhereInput
    some?: XUserRolesWhereInput
    none?: XUserRolesWhereInput
  }

  export type VentureCategoryListRelationFilter = {
    every?: VentureCategoryWhereInput
    some?: VentureCategoryWhereInput
    none?: VentureCategoryWhereInput
  }

  export type XUserPreferencesListRelationFilter = {
    every?: XUserPreferencesWhereInput
    some?: XUserPreferencesWhereInput
    none?: XUserPreferencesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventDonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationClapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureSponsorshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XUserRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XUserPreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboardingCompleted?: SortOrder
    userDetailId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboardingCompleted?: SortOrder
    userDetailId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboardingCompleted?: SortOrder
    userDetailId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VentureCategoryRelationFilter = {
    is?: VentureCategoryWhereInput
    isNot?: VentureCategoryWhereInput
  }

  export type XUserPreferencesUserIdCategoryIdCompoundUniqueInput = {
    userId: string
    categoryId: string
  }

  export type XUserPreferencesCountOrderByAggregateInput = {
    userId?: SortOrder
    categoryId?: SortOrder
  }

  export type XUserPreferencesMaxOrderByAggregateInput = {
    userId?: SortOrder
    categoryId?: SortOrder
  }

  export type XUserPreferencesMinOrderByAggregateInput = {
    userId?: SortOrder
    categoryId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MunicipalityRelationFilter = {
    is?: MunicipalityWhereInput
    isNot?: MunicipalityWhereInput
  }

  export type UserDetailCountOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    municipalityId?: SortOrder
  }

  export type UserDetailAvgOrderByAggregateInput = {
    municipalityId?: SortOrder
  }

  export type UserDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    municipalityId?: SortOrder
  }

  export type UserDetailMinOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    municipalityId?: SortOrder
  }

  export type UserDetailSumOrderByAggregateInput = {
    municipalityId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MunicipalityListRelationFilter = {
    every?: MunicipalityWhereInput
    some?: MunicipalityWhereInput
    none?: MunicipalityWhereInput
  }

  export type MunicipalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserDetailListRelationFilter = {
    every?: UserDetailWhereInput
    some?: UserDetailWhereInput
    none?: UserDetailWhereInput
  }

  export type UserDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MunicipalityAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type MunicipalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MunicipalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MunicipalitySumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type VenturePublicationRelationFilter = {
    is?: VenturePublicationWhereInput
    isNot?: VenturePublicationWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XEventCategoryListRelationFilter = {
    every?: XEventCategoryWhereInput
    some?: XEventCategoryWhereInput
    none?: XEventCategoryWhereInput
  }

  export type VentureEventListRelationFilter = {
    every?: VentureEventWhereInput
    some?: VentureEventWhereInput
    none?: VentureEventWhereInput
  }

  export type XEventCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VentureEventRelationFilter = {
    is?: VentureEventWhereInput
    isNot?: VentureEventWhereInput
  }

  export type EventDonationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type EventDonationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EventDonationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type EventDonationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type EventDonationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    ventureEventId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    ventureEventId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    ventureEventId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type PublicationClapCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type PublicationClapMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type PublicationClapMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type PublicationContentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationContentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationContentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type EnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type VentureDetailRelationFilter = {
    is?: VentureDetailWhereInput
    isNot?: VentureDetailWhereInput
  }

  export type XVentureVencureCategoryListRelationFilter = {
    every?: XVentureVencureCategoryWhereInput
    some?: XVentureVencureCategoryWhereInput
    none?: XVentureVencureCategoryWhereInput
  }

  export type XVentureVencureCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    coverPhoto?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    detailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    coverPhoto?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    detailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    coverPhoto?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    active?: SortOrder
    verified?: SortOrder
    detailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureRelationFilter = {
    is?: VentureWhereInput
    isNot?: VentureWhereInput
  }

  export type XVentureVencureCategoryVentureIdCategoryIdCompoundUniqueInput = {
    ventureId: string
    categoryId: string
  }

  export type XVentureVencureCategoryCountOrderByAggregateInput = {
    ventureId?: SortOrder
    categoryId?: SortOrder
  }

  export type XVentureVencureCategoryMaxOrderByAggregateInput = {
    ventureId?: SortOrder
    categoryId?: SortOrder
  }

  export type XVentureVencureCategoryMinOrderByAggregateInput = {
    ventureId?: SortOrder
    categoryId?: SortOrder
  }

  export type VentureCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureNullableRelationFilter = {
    is?: VentureWhereInput | null
    isNot?: VentureWhereInput | null
  }

  export type VenturePublicationListRelationFilter = {
    every?: VenturePublicationWhereInput
    some?: VenturePublicationWhereInput
    none?: VenturePublicationWhereInput
  }

  export type VenturePublicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureDetailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureDetailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type EventCategoryListRelationFilter = {
    every?: EventCategoryWhereInput
    some?: EventCategoryWhereInput
    none?: EventCategoryWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VentureEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverPhoto?: SortOrder
    ventureId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverPhoto?: SortOrder
    ventureId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverPhoto?: SortOrder
    ventureId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPublicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationType | EnumPublicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationTypeFilter<$PrismaModel> | $Enums.PublicationType
  }

  export type PublicationContentListRelationFilter = {
    every?: PublicationContentWhereInput
    some?: PublicationContentWhereInput
    none?: PublicationContentWhereInput
  }

  export type PublicationContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenturePublicationCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    detailId?: SortOrder
    type?: SortOrder
    clapsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenturePublicationAvgOrderByAggregateInput = {
    clapsCount?: SortOrder
  }

  export type VenturePublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    detailId?: SortOrder
    type?: SortOrder
    clapsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenturePublicationMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    detailId?: SortOrder
    type?: SortOrder
    clapsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenturePublicationSumOrderByAggregateInput = {
    clapsCount?: SortOrder
  }

  export type EnumPublicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationType | EnumPublicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.PublicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationTypeFilter<$PrismaModel>
    _max?: NestedEnumPublicationTypeFilter<$PrismaModel>
  }

  export type VentureSponsorshipCountOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    ventureDetailId?: SortOrder
    monthlyAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureSponsorshipAvgOrderByAggregateInput = {
    monthlyAmount?: SortOrder
  }

  export type VentureSponsorshipMaxOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    ventureDetailId?: SortOrder
    monthlyAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureSponsorshipMinOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    ventureDetailId?: SortOrder
    monthlyAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VentureSponsorshipSumOrderByAggregateInput = {
    monthlyAmount?: SortOrder
  }

  export type VentureSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    ventureId?: SortOrder
    createdAt?: SortOrder
  }

  export type VentureSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    ventureId?: SortOrder
    createdAt?: SortOrder
  }

  export type VentureSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    subscriberId?: SortOrder
    ventureId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCategoryRelationFilter = {
    is?: EventCategoryWhereInput
    isNot?: EventCategoryWhereInput
  }

  export type XEventCategoryEventIdCategoryIdCompoundUniqueInput = {
    eventId: string
    categoryId: string
  }

  export type XEventCategoryCountOrderByAggregateInput = {
    eventId?: SortOrder
    categoryId?: SortOrder
  }

  export type XEventCategoryMaxOrderByAggregateInput = {
    eventId?: SortOrder
    categoryId?: SortOrder
  }

  export type XEventCategoryMinOrderByAggregateInput = {
    eventId?: SortOrder
    categoryId?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type XUserRolesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type XUserRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type XUserRolesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EventDonationCreateNestedManyWithoutUserInput = {
    create?: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput> | EventDonationCreateWithoutUserInput[] | EventDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutUserInput | EventDonationCreateOrConnectWithoutUserInput[]
    createMany?: EventDonationCreateManyUserInputEnvelope
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PublicationClapCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput> | PublicationClapCreateWithoutUserInput[] | PublicationClapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutUserInput | PublicationClapCreateOrConnectWithoutUserInput[]
    createMany?: PublicationClapCreateManyUserInputEnvelope
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
  }

  export type VentureCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput> | VentureCreateWithoutOwnerInput[] | VentureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutOwnerInput | VentureCreateOrConnectWithoutOwnerInput[]
    createMany?: VentureCreateManyOwnerInputEnvelope
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
  }

  export type VentureSponsorshipCreateNestedManyWithoutUserInput = {
    create?: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput> | VentureSponsorshipCreateWithoutUserInput[] | VentureSponsorshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutUserInput | VentureSponsorshipCreateOrConnectWithoutUserInput[]
    createMany?: VentureSponsorshipCreateManyUserInputEnvelope
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
  }

  export type VentureSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput> | VentureSubscriptionCreateWithoutUserInput[] | VentureSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutUserInput | VentureSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: VentureSubscriptionCreateManyUserInputEnvelope
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type UserDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<UserDetailCreateWithoutUserInput, UserDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailCreateOrConnectWithoutUserInput
    connect?: UserDetailWhereUniqueInput
  }

  export type XUserRolesCreateNestedManyWithoutUserInput = {
    create?: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput> | XUserRolesCreateWithoutUserInput[] | XUserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutUserInput | XUserRolesCreateOrConnectWithoutUserInput[]
    createMany?: XUserRolesCreateManyUserInputEnvelope
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
  }

  export type VentureCategoryCreateNestedManyWithoutUsersInput = {
    create?: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput> | VentureCategoryCreateWithoutUsersInput[] | VentureCategoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutUsersInput | VentureCategoryCreateOrConnectWithoutUsersInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
  }

  export type XUserPreferencesCreateNestedManyWithoutUserInput = {
    create?: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput> | XUserPreferencesCreateWithoutUserInput[] | XUserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutUserInput | XUserPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: XUserPreferencesCreateManyUserInputEnvelope
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EventDonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput> | EventDonationCreateWithoutUserInput[] | EventDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutUserInput | EventDonationCreateOrConnectWithoutUserInput[]
    createMany?: EventDonationCreateManyUserInputEnvelope
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PublicationClapUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput> | PublicationClapCreateWithoutUserInput[] | PublicationClapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutUserInput | PublicationClapCreateOrConnectWithoutUserInput[]
    createMany?: PublicationClapCreateManyUserInputEnvelope
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
  }

  export type VentureUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput> | VentureCreateWithoutOwnerInput[] | VentureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutOwnerInput | VentureCreateOrConnectWithoutOwnerInput[]
    createMany?: VentureCreateManyOwnerInputEnvelope
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
  }

  export type VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput> | VentureSponsorshipCreateWithoutUserInput[] | VentureSponsorshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutUserInput | VentureSponsorshipCreateOrConnectWithoutUserInput[]
    createMany?: VentureSponsorshipCreateManyUserInputEnvelope
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
  }

  export type VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput> | VentureSubscriptionCreateWithoutUserInput[] | VentureSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutUserInput | VentureSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: VentureSubscriptionCreateManyUserInputEnvelope
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type XUserRolesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput> | XUserRolesCreateWithoutUserInput[] | XUserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutUserInput | XUserRolesCreateOrConnectWithoutUserInput[]
    createMany?: XUserRolesCreateManyUserInputEnvelope
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
  }

  export type VentureCategoryUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput> | VentureCategoryCreateWithoutUsersInput[] | VentureCategoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutUsersInput | VentureCategoryCreateOrConnectWithoutUsersInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
  }

  export type XUserPreferencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput> | XUserPreferencesCreateWithoutUserInput[] | XUserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutUserInput | XUserPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: XUserPreferencesCreateManyUserInputEnvelope
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EventDonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput> | EventDonationCreateWithoutUserInput[] | EventDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutUserInput | EventDonationCreateOrConnectWithoutUserInput[]
    upsert?: EventDonationUpsertWithWhereUniqueWithoutUserInput | EventDonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventDonationCreateManyUserInputEnvelope
    set?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    disconnect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    delete?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    update?: EventDonationUpdateWithWhereUniqueWithoutUserInput | EventDonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventDonationUpdateManyWithWhereWithoutUserInput | EventDonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PublicationClapUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput> | PublicationClapCreateWithoutUserInput[] | PublicationClapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutUserInput | PublicationClapCreateOrConnectWithoutUserInput[]
    upsert?: PublicationClapUpsertWithWhereUniqueWithoutUserInput | PublicationClapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationClapCreateManyUserInputEnvelope
    set?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    disconnect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    delete?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    update?: PublicationClapUpdateWithWhereUniqueWithoutUserInput | PublicationClapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationClapUpdateManyWithWhereWithoutUserInput | PublicationClapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
  }

  export type VentureUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput> | VentureCreateWithoutOwnerInput[] | VentureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutOwnerInput | VentureCreateOrConnectWithoutOwnerInput[]
    upsert?: VentureUpsertWithWhereUniqueWithoutOwnerInput | VentureUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VentureCreateManyOwnerInputEnvelope
    set?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    disconnect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    delete?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    update?: VentureUpdateWithWhereUniqueWithoutOwnerInput | VentureUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VentureUpdateManyWithWhereWithoutOwnerInput | VentureUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VentureScalarWhereInput | VentureScalarWhereInput[]
  }

  export type VentureSponsorshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput> | VentureSponsorshipCreateWithoutUserInput[] | VentureSponsorshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutUserInput | VentureSponsorshipCreateOrConnectWithoutUserInput[]
    upsert?: VentureSponsorshipUpsertWithWhereUniqueWithoutUserInput | VentureSponsorshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VentureSponsorshipCreateManyUserInputEnvelope
    set?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    disconnect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    delete?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    update?: VentureSponsorshipUpdateWithWhereUniqueWithoutUserInput | VentureSponsorshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VentureSponsorshipUpdateManyWithWhereWithoutUserInput | VentureSponsorshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
  }

  export type VentureSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput> | VentureSubscriptionCreateWithoutUserInput[] | VentureSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutUserInput | VentureSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: VentureSubscriptionUpsertWithWhereUniqueWithoutUserInput | VentureSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VentureSubscriptionCreateManyUserInputEnvelope
    set?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    disconnect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    delete?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    update?: VentureSubscriptionUpdateWithWhereUniqueWithoutUserInput | VentureSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VentureSubscriptionUpdateManyWithWhereWithoutUserInput | VentureSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUsersInput | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUsersInput | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUsersInput | RoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserDetailCreateWithoutUserInput, UserDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDetailCreateOrConnectWithoutUserInput
    upsert?: UserDetailUpsertWithoutUserInput
    disconnect?: UserDetailWhereInput | boolean
    delete?: UserDetailWhereInput | boolean
    connect?: UserDetailWhereUniqueInput
    update?: XOR<XOR<UserDetailUpdateToOneWithWhereWithoutUserInput, UserDetailUpdateWithoutUserInput>, UserDetailUncheckedUpdateWithoutUserInput>
  }

  export type XUserRolesUpdateManyWithoutUserNestedInput = {
    create?: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput> | XUserRolesCreateWithoutUserInput[] | XUserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutUserInput | XUserRolesCreateOrConnectWithoutUserInput[]
    upsert?: XUserRolesUpsertWithWhereUniqueWithoutUserInput | XUserRolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XUserRolesCreateManyUserInputEnvelope
    set?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    disconnect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    delete?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    update?: XUserRolesUpdateWithWhereUniqueWithoutUserInput | XUserRolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XUserRolesUpdateManyWithWhereWithoutUserInput | XUserRolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
  }

  export type VentureCategoryUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput> | VentureCategoryCreateWithoutUsersInput[] | VentureCategoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutUsersInput | VentureCategoryCreateOrConnectWithoutUsersInput[]
    upsert?: VentureCategoryUpsertWithWhereUniqueWithoutUsersInput | VentureCategoryUpsertWithWhereUniqueWithoutUsersInput[]
    set?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    disconnect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    delete?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    update?: VentureCategoryUpdateWithWhereUniqueWithoutUsersInput | VentureCategoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VentureCategoryUpdateManyWithWhereWithoutUsersInput | VentureCategoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
  }

  export type XUserPreferencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput> | XUserPreferencesCreateWithoutUserInput[] | XUserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutUserInput | XUserPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: XUserPreferencesUpsertWithWhereUniqueWithoutUserInput | XUserPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XUserPreferencesCreateManyUserInputEnvelope
    set?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    disconnect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    delete?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    update?: XUserPreferencesUpdateWithWhereUniqueWithoutUserInput | XUserPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XUserPreferencesUpdateManyWithWhereWithoutUserInput | XUserPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EventDonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput> | EventDonationCreateWithoutUserInput[] | EventDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutUserInput | EventDonationCreateOrConnectWithoutUserInput[]
    upsert?: EventDonationUpsertWithWhereUniqueWithoutUserInput | EventDonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventDonationCreateManyUserInputEnvelope
    set?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    disconnect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    delete?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    update?: EventDonationUpdateWithWhereUniqueWithoutUserInput | EventDonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventDonationUpdateManyWithWhereWithoutUserInput | EventDonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PublicationClapUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput> | PublicationClapCreateWithoutUserInput[] | PublicationClapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutUserInput | PublicationClapCreateOrConnectWithoutUserInput[]
    upsert?: PublicationClapUpsertWithWhereUniqueWithoutUserInput | PublicationClapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationClapCreateManyUserInputEnvelope
    set?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    disconnect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    delete?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    update?: PublicationClapUpdateWithWhereUniqueWithoutUserInput | PublicationClapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationClapUpdateManyWithWhereWithoutUserInput | PublicationClapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
  }

  export type VentureUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput> | VentureCreateWithoutOwnerInput[] | VentureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutOwnerInput | VentureCreateOrConnectWithoutOwnerInput[]
    upsert?: VentureUpsertWithWhereUniqueWithoutOwnerInput | VentureUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VentureCreateManyOwnerInputEnvelope
    set?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    disconnect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    delete?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    update?: VentureUpdateWithWhereUniqueWithoutOwnerInput | VentureUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VentureUpdateManyWithWhereWithoutOwnerInput | VentureUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VentureScalarWhereInput | VentureScalarWhereInput[]
  }

  export type VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput> | VentureSponsorshipCreateWithoutUserInput[] | VentureSponsorshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutUserInput | VentureSponsorshipCreateOrConnectWithoutUserInput[]
    upsert?: VentureSponsorshipUpsertWithWhereUniqueWithoutUserInput | VentureSponsorshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VentureSponsorshipCreateManyUserInputEnvelope
    set?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    disconnect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    delete?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    update?: VentureSponsorshipUpdateWithWhereUniqueWithoutUserInput | VentureSponsorshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VentureSponsorshipUpdateManyWithWhereWithoutUserInput | VentureSponsorshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
  }

  export type VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput> | VentureSubscriptionCreateWithoutUserInput[] | VentureSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutUserInput | VentureSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: VentureSubscriptionUpsertWithWhereUniqueWithoutUserInput | VentureSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VentureSubscriptionCreateManyUserInputEnvelope
    set?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    disconnect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    delete?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    update?: VentureSubscriptionUpdateWithWhereUniqueWithoutUserInput | VentureSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VentureSubscriptionUpdateManyWithWhereWithoutUserInput | VentureSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput> | RoleCreateWithoutUsersInput[] | RoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput | RoleCreateOrConnectWithoutUsersInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutUsersInput | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutUsersInput | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutUsersInput | RoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type XUserRolesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput> | XUserRolesCreateWithoutUserInput[] | XUserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutUserInput | XUserRolesCreateOrConnectWithoutUserInput[]
    upsert?: XUserRolesUpsertWithWhereUniqueWithoutUserInput | XUserRolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XUserRolesCreateManyUserInputEnvelope
    set?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    disconnect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    delete?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    update?: XUserRolesUpdateWithWhereUniqueWithoutUserInput | XUserRolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XUserRolesUpdateManyWithWhereWithoutUserInput | XUserRolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
  }

  export type VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput> | VentureCategoryCreateWithoutUsersInput[] | VentureCategoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutUsersInput | VentureCategoryCreateOrConnectWithoutUsersInput[]
    upsert?: VentureCategoryUpsertWithWhereUniqueWithoutUsersInput | VentureCategoryUpsertWithWhereUniqueWithoutUsersInput[]
    set?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    disconnect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    delete?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    update?: VentureCategoryUpdateWithWhereUniqueWithoutUsersInput | VentureCategoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VentureCategoryUpdateManyWithWhereWithoutUsersInput | VentureCategoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
  }

  export type XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput> | XUserPreferencesCreateWithoutUserInput[] | XUserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutUserInput | XUserPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: XUserPreferencesUpsertWithWhereUniqueWithoutUserInput | XUserPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XUserPreferencesCreateManyUserInputEnvelope
    set?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    disconnect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    delete?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    update?: XUserPreferencesUpdateWithWhereUniqueWithoutUserInput | XUserPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XUserPreferencesUpdateManyWithWhereWithoutUserInput | XUserPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutXUserPreferencesInput = {
    create?: XOR<UserCreateWithoutXUserPreferencesInput, UserUncheckedCreateWithoutXUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXUserPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type VentureCategoryCreateNestedOneWithoutXUserPreferencesInput = {
    create?: XOR<VentureCategoryCreateWithoutXUserPreferencesInput, VentureCategoryUncheckedCreateWithoutXUserPreferencesInput>
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutXUserPreferencesInput
    connect?: VentureCategoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutXUserPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutXUserPreferencesInput, UserUncheckedCreateWithoutXUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXUserPreferencesInput
    upsert?: UserUpsertWithoutXUserPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXUserPreferencesInput, UserUpdateWithoutXUserPreferencesInput>, UserUncheckedUpdateWithoutXUserPreferencesInput>
  }

  export type VentureCategoryUpdateOneRequiredWithoutXUserPreferencesNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutXUserPreferencesInput, VentureCategoryUncheckedCreateWithoutXUserPreferencesInput>
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutXUserPreferencesInput
    upsert?: VentureCategoryUpsertWithoutXUserPreferencesInput
    connect?: VentureCategoryWhereUniqueInput
    update?: XOR<XOR<VentureCategoryUpdateToOneWithWhereWithoutXUserPreferencesInput, VentureCategoryUpdateWithoutXUserPreferencesInput>, VentureCategoryUncheckedUpdateWithoutXUserPreferencesInput>
  }

  export type UserCreateNestedOneWithoutDetailInput = {
    create?: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutDetailInput
    connect?: UserWhereUniqueInput
  }

  export type MunicipalityCreateNestedOneWithoutUserDetailInput = {
    create?: XOR<MunicipalityCreateWithoutUserDetailInput, MunicipalityUncheckedCreateWithoutUserDetailInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutUserDetailInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type UserUncheckedCreateNestedOneWithoutDetailInput = {
    create?: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutDetailInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutDetailNestedInput = {
    create?: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutDetailInput
    upsert?: UserUpsertWithoutDetailInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDetailInput, UserUpdateWithoutDetailInput>, UserUncheckedUpdateWithoutDetailInput>
  }

  export type MunicipalityUpdateOneRequiredWithoutUserDetailNestedInput = {
    create?: XOR<MunicipalityCreateWithoutUserDetailInput, MunicipalityUncheckedCreateWithoutUserDetailInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutUserDetailInput
    upsert?: MunicipalityUpsertWithoutUserDetailInput
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutUserDetailInput, MunicipalityUpdateWithoutUserDetailInput>, MunicipalityUncheckedUpdateWithoutUserDetailInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateOneWithoutDetailNestedInput = {
    create?: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutDetailInput
    upsert?: UserUpsertWithoutDetailInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDetailInput, UserUpdateWithoutDetailInput>, UserUncheckedUpdateWithoutDetailInput>
  }

  export type MunicipalityCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type MunicipalityUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type MunicipalityUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput | MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput | MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutDepartmentInput | MunicipalityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type MunicipalityUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput | MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput | MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutDepartmentInput | MunicipalityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutMunicipalitiesInput = {
    create?: XOR<DepartmentCreateWithoutMunicipalitiesInput, DepartmentUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMunicipalitiesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserDetailCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput> | UserDetailCreateWithoutMunicipalityInput[] | UserDetailUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserDetailCreateOrConnectWithoutMunicipalityInput | UserDetailCreateOrConnectWithoutMunicipalityInput[]
    createMany?: UserDetailCreateManyMunicipalityInputEnvelope
    connect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
  }

  export type UserDetailUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput> | UserDetailCreateWithoutMunicipalityInput[] | UserDetailUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserDetailCreateOrConnectWithoutMunicipalityInput | UserDetailCreateOrConnectWithoutMunicipalityInput[]
    createMany?: UserDetailCreateManyMunicipalityInputEnvelope
    connect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
  }

  export type DepartmentUpdateOneWithoutMunicipalitiesNestedInput = {
    create?: XOR<DepartmentCreateWithoutMunicipalitiesInput, DepartmentUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMunicipalitiesInput
    upsert?: DepartmentUpsertWithoutMunicipalitiesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutMunicipalitiesInput, DepartmentUpdateWithoutMunicipalitiesInput>, DepartmentUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type UserDetailUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput> | UserDetailCreateWithoutMunicipalityInput[] | UserDetailUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserDetailCreateOrConnectWithoutMunicipalityInput | UserDetailCreateOrConnectWithoutMunicipalityInput[]
    upsert?: UserDetailUpsertWithWhereUniqueWithoutMunicipalityInput | UserDetailUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: UserDetailCreateManyMunicipalityInputEnvelope
    set?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    disconnect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    delete?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    connect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    update?: UserDetailUpdateWithWhereUniqueWithoutMunicipalityInput | UserDetailUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: UserDetailUpdateManyWithWhereWithoutMunicipalityInput | UserDetailUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: UserDetailScalarWhereInput | UserDetailScalarWhereInput[]
  }

  export type UserDetailUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput> | UserDetailCreateWithoutMunicipalityInput[] | UserDetailUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: UserDetailCreateOrConnectWithoutMunicipalityInput | UserDetailCreateOrConnectWithoutMunicipalityInput[]
    upsert?: UserDetailUpsertWithWhereUniqueWithoutMunicipalityInput | UserDetailUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: UserDetailCreateManyMunicipalityInputEnvelope
    set?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    disconnect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    delete?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    connect?: UserDetailWhereUniqueInput | UserDetailWhereUniqueInput[]
    update?: UserDetailUpdateWithWhereUniqueWithoutMunicipalityInput | UserDetailUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: UserDetailUpdateManyWithWhereWithoutMunicipalityInput | UserDetailUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: UserDetailScalarWhereInput | UserDetailScalarWhereInput[]
  }

  export type VenturePublicationCreateNestedOneWithoutCommentInput = {
    create?: XOR<VenturePublicationCreateWithoutCommentInput, VenturePublicationUncheckedCreateWithoutCommentInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutCommentInput
    connect?: VenturePublicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type VenturePublicationUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<VenturePublicationCreateWithoutCommentInput, VenturePublicationUncheckedCreateWithoutCommentInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutCommentInput
    upsert?: VenturePublicationUpsertWithoutCommentInput
    connect?: VenturePublicationWhereUniqueInput
    update?: XOR<XOR<VenturePublicationUpdateToOneWithWhereWithoutCommentInput, VenturePublicationUpdateWithoutCommentInput>, VenturePublicationUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type XEventCategoryCreateNestedManyWithoutEventCategoryInput = {
    create?: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput> | XEventCategoryCreateWithoutEventCategoryInput[] | XEventCategoryUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutEventCategoryInput | XEventCategoryCreateOrConnectWithoutEventCategoryInput[]
    createMany?: XEventCategoryCreateManyEventCategoryInputEnvelope
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
  }

  export type VentureEventCreateNestedManyWithoutEventCategoryInput = {
    create?: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput> | VentureEventCreateWithoutEventCategoryInput[] | VentureEventUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventCategoryInput | VentureEventCreateOrConnectWithoutEventCategoryInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
  }

  export type XEventCategoryUncheckedCreateNestedManyWithoutEventCategoryInput = {
    create?: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput> | XEventCategoryCreateWithoutEventCategoryInput[] | XEventCategoryUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutEventCategoryInput | XEventCategoryCreateOrConnectWithoutEventCategoryInput[]
    createMany?: XEventCategoryCreateManyEventCategoryInputEnvelope
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
  }

  export type VentureEventUncheckedCreateNestedManyWithoutEventCategoryInput = {
    create?: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput> | VentureEventCreateWithoutEventCategoryInput[] | VentureEventUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventCategoryInput | VentureEventCreateOrConnectWithoutEventCategoryInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
  }

  export type XEventCategoryUpdateManyWithoutEventCategoryNestedInput = {
    create?: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput> | XEventCategoryCreateWithoutEventCategoryInput[] | XEventCategoryUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutEventCategoryInput | XEventCategoryCreateOrConnectWithoutEventCategoryInput[]
    upsert?: XEventCategoryUpsertWithWhereUniqueWithoutEventCategoryInput | XEventCategoryUpsertWithWhereUniqueWithoutEventCategoryInput[]
    createMany?: XEventCategoryCreateManyEventCategoryInputEnvelope
    set?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    disconnect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    delete?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    update?: XEventCategoryUpdateWithWhereUniqueWithoutEventCategoryInput | XEventCategoryUpdateWithWhereUniqueWithoutEventCategoryInput[]
    updateMany?: XEventCategoryUpdateManyWithWhereWithoutEventCategoryInput | XEventCategoryUpdateManyWithWhereWithoutEventCategoryInput[]
    deleteMany?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
  }

  export type VentureEventUpdateManyWithoutEventCategoryNestedInput = {
    create?: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput> | VentureEventCreateWithoutEventCategoryInput[] | VentureEventUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventCategoryInput | VentureEventCreateOrConnectWithoutEventCategoryInput[]
    upsert?: VentureEventUpsertWithWhereUniqueWithoutEventCategoryInput | VentureEventUpsertWithWhereUniqueWithoutEventCategoryInput[]
    set?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    disconnect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    delete?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    update?: VentureEventUpdateWithWhereUniqueWithoutEventCategoryInput | VentureEventUpdateWithWhereUniqueWithoutEventCategoryInput[]
    updateMany?: VentureEventUpdateManyWithWhereWithoutEventCategoryInput | VentureEventUpdateManyWithWhereWithoutEventCategoryInput[]
    deleteMany?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
  }

  export type XEventCategoryUncheckedUpdateManyWithoutEventCategoryNestedInput = {
    create?: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput> | XEventCategoryCreateWithoutEventCategoryInput[] | XEventCategoryUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutEventCategoryInput | XEventCategoryCreateOrConnectWithoutEventCategoryInput[]
    upsert?: XEventCategoryUpsertWithWhereUniqueWithoutEventCategoryInput | XEventCategoryUpsertWithWhereUniqueWithoutEventCategoryInput[]
    createMany?: XEventCategoryCreateManyEventCategoryInputEnvelope
    set?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    disconnect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    delete?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    update?: XEventCategoryUpdateWithWhereUniqueWithoutEventCategoryInput | XEventCategoryUpdateWithWhereUniqueWithoutEventCategoryInput[]
    updateMany?: XEventCategoryUpdateManyWithWhereWithoutEventCategoryInput | XEventCategoryUpdateManyWithWhereWithoutEventCategoryInput[]
    deleteMany?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
  }

  export type VentureEventUncheckedUpdateManyWithoutEventCategoryNestedInput = {
    create?: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput> | VentureEventCreateWithoutEventCategoryInput[] | VentureEventUncheckedCreateWithoutEventCategoryInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventCategoryInput | VentureEventCreateOrConnectWithoutEventCategoryInput[]
    upsert?: VentureEventUpsertWithWhereUniqueWithoutEventCategoryInput | VentureEventUpsertWithWhereUniqueWithoutEventCategoryInput[]
    set?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    disconnect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    delete?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    update?: VentureEventUpdateWithWhereUniqueWithoutEventCategoryInput | VentureEventUpdateWithWhereUniqueWithoutEventCategoryInput[]
    updateMany?: VentureEventUpdateManyWithWhereWithoutEventCategoryInput | VentureEventUpdateManyWithWhereWithoutEventCategoryInput[]
    deleteMany?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
  }

  export type VentureEventCreateNestedOneWithoutEventDonationInput = {
    create?: XOR<VentureEventCreateWithoutEventDonationInput, VentureEventUncheckedCreateWithoutEventDonationInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventDonationInput
    connect?: VentureEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventDonationsInput = {
    create?: XOR<UserCreateWithoutEventDonationsInput, UserUncheckedCreateWithoutEventDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VentureEventUpdateOneRequiredWithoutEventDonationNestedInput = {
    create?: XOR<VentureEventCreateWithoutEventDonationInput, VentureEventUncheckedCreateWithoutEventDonationInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutEventDonationInput
    upsert?: VentureEventUpsertWithoutEventDonationInput
    connect?: VentureEventWhereUniqueInput
    update?: XOR<XOR<VentureEventUpdateToOneWithWhereWithoutEventDonationInput, VentureEventUpdateWithoutEventDonationInput>, VentureEventUncheckedUpdateWithoutEventDonationInput>
  }

  export type UserUpdateOneRequiredWithoutEventDonationsNestedInput = {
    create?: XOR<UserCreateWithoutEventDonationsInput, UserUncheckedCreateWithoutEventDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventDonationsInput
    upsert?: UserUpsertWithoutEventDonationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventDonationsInput, UserUpdateWithoutEventDonationsInput>, UserUncheckedUpdateWithoutEventDonationsInput>
  }

  export type VentureEventCreateNestedOneWithoutLocationInput = {
    create?: XOR<VentureEventCreateWithoutLocationInput, VentureEventUncheckedCreateWithoutLocationInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutLocationInput
    connect?: VentureEventWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VentureEventUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<VentureEventCreateWithoutLocationInput, VentureEventUncheckedCreateWithoutLocationInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutLocationInput
    upsert?: VentureEventUpsertWithoutLocationInput
    connect?: VentureEventWhereUniqueInput
    update?: XOR<XOR<VentureEventUpdateToOneWithWhereWithoutLocationInput, VentureEventUpdateWithoutLocationInput>, VentureEventUncheckedUpdateWithoutLocationInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type VenturePublicationCreateNestedOneWithoutPublicationClapInput = {
    create?: XOR<VenturePublicationCreateWithoutPublicationClapInput, VenturePublicationUncheckedCreateWithoutPublicationClapInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutPublicationClapInput
    connect?: VenturePublicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPublicationClapsInput = {
    create?: XOR<UserCreateWithoutPublicationClapsInput, UserUncheckedCreateWithoutPublicationClapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationClapsInput
    connect?: UserWhereUniqueInput
  }

  export type VenturePublicationUpdateOneRequiredWithoutPublicationClapNestedInput = {
    create?: XOR<VenturePublicationCreateWithoutPublicationClapInput, VenturePublicationUncheckedCreateWithoutPublicationClapInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutPublicationClapInput
    upsert?: VenturePublicationUpsertWithoutPublicationClapInput
    connect?: VenturePublicationWhereUniqueInput
    update?: XOR<XOR<VenturePublicationUpdateToOneWithWhereWithoutPublicationClapInput, VenturePublicationUpdateWithoutPublicationClapInput>, VenturePublicationUncheckedUpdateWithoutPublicationClapInput>
  }

  export type UserUpdateOneRequiredWithoutPublicationClapsNestedInput = {
    create?: XOR<UserCreateWithoutPublicationClapsInput, UserUncheckedCreateWithoutPublicationClapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationClapsInput
    upsert?: UserUpsertWithoutPublicationClapsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublicationClapsInput, UserUpdateWithoutPublicationClapsInput>, UserUncheckedUpdateWithoutPublicationClapsInput>
  }

  export type VenturePublicationCreateNestedOneWithoutPublicationContentInput = {
    create?: XOR<VenturePublicationCreateWithoutPublicationContentInput, VenturePublicationUncheckedCreateWithoutPublicationContentInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutPublicationContentInput
    connect?: VenturePublicationWhereUniqueInput
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type VenturePublicationUpdateOneRequiredWithoutPublicationContentNestedInput = {
    create?: XOR<VenturePublicationCreateWithoutPublicationContentInput, VenturePublicationUncheckedCreateWithoutPublicationContentInput>
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutPublicationContentInput
    upsert?: VenturePublicationUpsertWithoutPublicationContentInput
    connect?: VenturePublicationWhereUniqueInput
    update?: XOR<XOR<VenturePublicationUpdateToOneWithWhereWithoutPublicationContentInput, VenturePublicationUpdateWithoutPublicationContentInput>, VenturePublicationUncheckedUpdateWithoutPublicationContentInput>
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type XUserRolesCreateNestedManyWithoutRoleInput = {
    create?: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput> | XUserRolesCreateWithoutRoleInput[] | XUserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutRoleInput | XUserRolesCreateOrConnectWithoutRoleInput[]
    createMany?: XUserRolesCreateManyRoleInputEnvelope
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type XUserRolesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput> | XUserRolesCreateWithoutRoleInput[] | XUserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutRoleInput | XUserRolesCreateOrConnectWithoutRoleInput[]
    createMany?: XUserRolesCreateManyRoleInputEnvelope
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
  }

  export type EnumAppRoleFieldUpdateOperationsInput = {
    set?: $Enums.AppRole
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type XUserRolesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput> | XUserRolesCreateWithoutRoleInput[] | XUserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutRoleInput | XUserRolesCreateOrConnectWithoutRoleInput[]
    upsert?: XUserRolesUpsertWithWhereUniqueWithoutRoleInput | XUserRolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: XUserRolesCreateManyRoleInputEnvelope
    set?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    disconnect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    delete?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    update?: XUserRolesUpdateWithWhereUniqueWithoutRoleInput | XUserRolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: XUserRolesUpdateManyWithWhereWithoutRoleInput | XUserRolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type XUserRolesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput> | XUserRolesCreateWithoutRoleInput[] | XUserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: XUserRolesCreateOrConnectWithoutRoleInput | XUserRolesCreateOrConnectWithoutRoleInput[]
    upsert?: XUserRolesUpsertWithWhereUniqueWithoutRoleInput | XUserRolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: XUserRolesCreateManyRoleInputEnvelope
    set?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    disconnect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    delete?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    connect?: XUserRolesWhereUniqueInput | XUserRolesWhereUniqueInput[]
    update?: XUserRolesUpdateWithWhereUniqueWithoutRoleInput | XUserRolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: XUserRolesUpdateManyWithWhereWithoutRoleInput | XUserRolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
  }

  export type VentureDetailCreateNestedOneWithoutVentureInput = {
    create?: XOR<VentureDetailCreateWithoutVentureInput, VentureDetailUncheckedCreateWithoutVentureInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutVentureInput
    connect?: VentureDetailWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVenturesInput = {
    create?: XOR<UserCreateWithoutVenturesInput, UserUncheckedCreateWithoutVenturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenturesInput
    connect?: UserWhereUniqueInput
  }

  export type VentureCategoryCreateNestedManyWithoutVenturesInput = {
    create?: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput> | VentureCategoryCreateWithoutVenturesInput[] | VentureCategoryUncheckedCreateWithoutVenturesInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutVenturesInput | VentureCategoryCreateOrConnectWithoutVenturesInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
  }

  export type XVentureVencureCategoryCreateNestedManyWithoutVentureInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput> | XVentureVencureCategoryCreateWithoutVentureInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureInput | XVentureVencureCategoryCreateOrConnectWithoutVentureInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureInputEnvelope
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
  }

  export type VentureCategoryUncheckedCreateNestedManyWithoutVenturesInput = {
    create?: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput> | VentureCategoryCreateWithoutVenturesInput[] | VentureCategoryUncheckedCreateWithoutVenturesInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutVenturesInput | VentureCategoryCreateOrConnectWithoutVenturesInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
  }

  export type XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput> | XVentureVencureCategoryCreateWithoutVentureInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureInput | XVentureVencureCategoryCreateOrConnectWithoutVentureInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureInputEnvelope
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
  }

  export type VentureDetailUpdateOneRequiredWithoutVentureNestedInput = {
    create?: XOR<VentureDetailCreateWithoutVentureInput, VentureDetailUncheckedCreateWithoutVentureInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutVentureInput
    upsert?: VentureDetailUpsertWithoutVentureInput
    connect?: VentureDetailWhereUniqueInput
    update?: XOR<XOR<VentureDetailUpdateToOneWithWhereWithoutVentureInput, VentureDetailUpdateWithoutVentureInput>, VentureDetailUncheckedUpdateWithoutVentureInput>
  }

  export type UserUpdateOneRequiredWithoutVenturesNestedInput = {
    create?: XOR<UserCreateWithoutVenturesInput, UserUncheckedCreateWithoutVenturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenturesInput
    upsert?: UserUpsertWithoutVenturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVenturesInput, UserUpdateWithoutVenturesInput>, UserUncheckedUpdateWithoutVenturesInput>
  }

  export type VentureCategoryUpdateManyWithoutVenturesNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput> | VentureCategoryCreateWithoutVenturesInput[] | VentureCategoryUncheckedCreateWithoutVenturesInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutVenturesInput | VentureCategoryCreateOrConnectWithoutVenturesInput[]
    upsert?: VentureCategoryUpsertWithWhereUniqueWithoutVenturesInput | VentureCategoryUpsertWithWhereUniqueWithoutVenturesInput[]
    set?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    disconnect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    delete?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    update?: VentureCategoryUpdateWithWhereUniqueWithoutVenturesInput | VentureCategoryUpdateWithWhereUniqueWithoutVenturesInput[]
    updateMany?: VentureCategoryUpdateManyWithWhereWithoutVenturesInput | VentureCategoryUpdateManyWithWhereWithoutVenturesInput[]
    deleteMany?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
  }

  export type XVentureVencureCategoryUpdateManyWithoutVentureNestedInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput> | XVentureVencureCategoryCreateWithoutVentureInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureInput | XVentureVencureCategoryCreateOrConnectWithoutVentureInput[]
    upsert?: XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureInput | XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureInputEnvelope
    set?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    disconnect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    delete?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    update?: XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureInput | XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureInput[]
    updateMany?: XVentureVencureCategoryUpdateManyWithWhereWithoutVentureInput | XVentureVencureCategoryUpdateManyWithWhereWithoutVentureInput[]
    deleteMany?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
  }

  export type VentureCategoryUncheckedUpdateManyWithoutVenturesNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput> | VentureCategoryCreateWithoutVenturesInput[] | VentureCategoryUncheckedCreateWithoutVenturesInput[]
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutVenturesInput | VentureCategoryCreateOrConnectWithoutVenturesInput[]
    upsert?: VentureCategoryUpsertWithWhereUniqueWithoutVenturesInput | VentureCategoryUpsertWithWhereUniqueWithoutVenturesInput[]
    set?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    disconnect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    delete?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    connect?: VentureCategoryWhereUniqueInput | VentureCategoryWhereUniqueInput[]
    update?: VentureCategoryUpdateWithWhereUniqueWithoutVenturesInput | VentureCategoryUpdateWithWhereUniqueWithoutVenturesInput[]
    updateMany?: VentureCategoryUpdateManyWithWhereWithoutVenturesInput | VentureCategoryUpdateManyWithWhereWithoutVenturesInput[]
    deleteMany?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
  }

  export type XVentureVencureCategoryUncheckedUpdateManyWithoutVentureNestedInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput> | XVentureVencureCategoryCreateWithoutVentureInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureInput | XVentureVencureCategoryCreateOrConnectWithoutVentureInput[]
    upsert?: XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureInput | XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureInputEnvelope
    set?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    disconnect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    delete?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    update?: XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureInput | XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureInput[]
    updateMany?: XVentureVencureCategoryUpdateManyWithWhereWithoutVentureInput | XVentureVencureCategoryUpdateManyWithWhereWithoutVentureInput[]
    deleteMany?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
  }

  export type VentureCreateNestedOneWithoutXVentureVencureCategoryInput = {
    create?: XOR<VentureCreateWithoutXVentureVencureCategoryInput, VentureUncheckedCreateWithoutXVentureVencureCategoryInput>
    connectOrCreate?: VentureCreateOrConnectWithoutXVentureVencureCategoryInput
    connect?: VentureWhereUniqueInput
  }

  export type VentureCategoryCreateNestedOneWithoutXVentureVencureCategoryInput = {
    create?: XOR<VentureCategoryCreateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedCreateWithoutXVentureVencureCategoryInput>
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutXVentureVencureCategoryInput
    connect?: VentureCategoryWhereUniqueInput
  }

  export type VentureUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput = {
    create?: XOR<VentureCreateWithoutXVentureVencureCategoryInput, VentureUncheckedCreateWithoutXVentureVencureCategoryInput>
    connectOrCreate?: VentureCreateOrConnectWithoutXVentureVencureCategoryInput
    upsert?: VentureUpsertWithoutXVentureVencureCategoryInput
    connect?: VentureWhereUniqueInput
    update?: XOR<XOR<VentureUpdateToOneWithWhereWithoutXVentureVencureCategoryInput, VentureUpdateWithoutXVentureVencureCategoryInput>, VentureUncheckedUpdateWithoutXVentureVencureCategoryInput>
  }

  export type VentureCategoryUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput = {
    create?: XOR<VentureCategoryCreateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedCreateWithoutXVentureVencureCategoryInput>
    connectOrCreate?: VentureCategoryCreateOrConnectWithoutXVentureVencureCategoryInput
    upsert?: VentureCategoryUpsertWithoutXVentureVencureCategoryInput
    connect?: VentureCategoryWhereUniqueInput
    update?: XOR<XOR<VentureCategoryUpdateToOneWithWhereWithoutXVentureVencureCategoryInput, VentureCategoryUpdateWithoutXVentureVencureCategoryInput>, VentureCategoryUncheckedUpdateWithoutXVentureVencureCategoryInput>
  }

  export type UserCreateNestedManyWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput> | UserCreateWithoutPreferencesInput[] | UserUncheckedCreateWithoutPreferencesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput | UserCreateOrConnectWithoutPreferencesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type XUserPreferencesCreateNestedManyWithoutVentureCategoryInput = {
    create?: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput> | XUserPreferencesCreateWithoutVentureCategoryInput[] | XUserPreferencesUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutVentureCategoryInput | XUserPreferencesCreateOrConnectWithoutVentureCategoryInput[]
    createMany?: XUserPreferencesCreateManyVentureCategoryInputEnvelope
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
  }

  export type VentureCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput> | VentureCreateWithoutCategoriesInput[] | VentureUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutCategoriesInput | VentureCreateOrConnectWithoutCategoriesInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
  }

  export type XVentureVencureCategoryCreateNestedManyWithoutVentureCategoryInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput> | XVentureVencureCategoryCreateWithoutVentureCategoryInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput | XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureCategoryInputEnvelope
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput> | UserCreateWithoutPreferencesInput[] | UserUncheckedCreateWithoutPreferencesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput | UserCreateOrConnectWithoutPreferencesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type XUserPreferencesUncheckedCreateNestedManyWithoutVentureCategoryInput = {
    create?: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput> | XUserPreferencesCreateWithoutVentureCategoryInput[] | XUserPreferencesUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutVentureCategoryInput | XUserPreferencesCreateOrConnectWithoutVentureCategoryInput[]
    createMany?: XUserPreferencesCreateManyVentureCategoryInputEnvelope
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
  }

  export type VentureUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput> | VentureCreateWithoutCategoriesInput[] | VentureUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutCategoriesInput | VentureCreateOrConnectWithoutCategoriesInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
  }

  export type XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureCategoryInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput> | XVentureVencureCategoryCreateWithoutVentureCategoryInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput | XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureCategoryInputEnvelope
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput> | UserCreateWithoutPreferencesInput[] | UserUncheckedCreateWithoutPreferencesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput | UserCreateOrConnectWithoutPreferencesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPreferencesInput | UserUpsertWithWhereUniqueWithoutPreferencesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPreferencesInput | UserUpdateWithWhereUniqueWithoutPreferencesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPreferencesInput | UserUpdateManyWithWhereWithoutPreferencesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type XUserPreferencesUpdateManyWithoutVentureCategoryNestedInput = {
    create?: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput> | XUserPreferencesCreateWithoutVentureCategoryInput[] | XUserPreferencesUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutVentureCategoryInput | XUserPreferencesCreateOrConnectWithoutVentureCategoryInput[]
    upsert?: XUserPreferencesUpsertWithWhereUniqueWithoutVentureCategoryInput | XUserPreferencesUpsertWithWhereUniqueWithoutVentureCategoryInput[]
    createMany?: XUserPreferencesCreateManyVentureCategoryInputEnvelope
    set?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    disconnect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    delete?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    update?: XUserPreferencesUpdateWithWhereUniqueWithoutVentureCategoryInput | XUserPreferencesUpdateWithWhereUniqueWithoutVentureCategoryInput[]
    updateMany?: XUserPreferencesUpdateManyWithWhereWithoutVentureCategoryInput | XUserPreferencesUpdateManyWithWhereWithoutVentureCategoryInput[]
    deleteMany?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
  }

  export type VentureUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput> | VentureCreateWithoutCategoriesInput[] | VentureUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutCategoriesInput | VentureCreateOrConnectWithoutCategoriesInput[]
    upsert?: VentureUpsertWithWhereUniqueWithoutCategoriesInput | VentureUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    disconnect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    delete?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    update?: VentureUpdateWithWhereUniqueWithoutCategoriesInput | VentureUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: VentureUpdateManyWithWhereWithoutCategoriesInput | VentureUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: VentureScalarWhereInput | VentureScalarWhereInput[]
  }

  export type XVentureVencureCategoryUpdateManyWithoutVentureCategoryNestedInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput> | XVentureVencureCategoryCreateWithoutVentureCategoryInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput | XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput[]
    upsert?: XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureCategoryInput | XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureCategoryInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureCategoryInputEnvelope
    set?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    disconnect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    delete?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    update?: XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureCategoryInput | XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureCategoryInput[]
    updateMany?: XVentureVencureCategoryUpdateManyWithWhereWithoutVentureCategoryInput | XVentureVencureCategoryUpdateManyWithWhereWithoutVentureCategoryInput[]
    deleteMany?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput> | UserCreateWithoutPreferencesInput[] | UserUncheckedCreateWithoutPreferencesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput | UserCreateOrConnectWithoutPreferencesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPreferencesInput | UserUpsertWithWhereUniqueWithoutPreferencesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPreferencesInput | UserUpdateWithWhereUniqueWithoutPreferencesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPreferencesInput | UserUpdateManyWithWhereWithoutPreferencesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryNestedInput = {
    create?: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput> | XUserPreferencesCreateWithoutVentureCategoryInput[] | XUserPreferencesUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XUserPreferencesCreateOrConnectWithoutVentureCategoryInput | XUserPreferencesCreateOrConnectWithoutVentureCategoryInput[]
    upsert?: XUserPreferencesUpsertWithWhereUniqueWithoutVentureCategoryInput | XUserPreferencesUpsertWithWhereUniqueWithoutVentureCategoryInput[]
    createMany?: XUserPreferencesCreateManyVentureCategoryInputEnvelope
    set?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    disconnect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    delete?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    connect?: XUserPreferencesWhereUniqueInput | XUserPreferencesWhereUniqueInput[]
    update?: XUserPreferencesUpdateWithWhereUniqueWithoutVentureCategoryInput | XUserPreferencesUpdateWithWhereUniqueWithoutVentureCategoryInput[]
    updateMany?: XUserPreferencesUpdateManyWithWhereWithoutVentureCategoryInput | XUserPreferencesUpdateManyWithWhereWithoutVentureCategoryInput[]
    deleteMany?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
  }

  export type VentureUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput> | VentureCreateWithoutCategoriesInput[] | VentureUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: VentureCreateOrConnectWithoutCategoriesInput | VentureCreateOrConnectWithoutCategoriesInput[]
    upsert?: VentureUpsertWithWhereUniqueWithoutCategoriesInput | VentureUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    disconnect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    delete?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    connect?: VentureWhereUniqueInput | VentureWhereUniqueInput[]
    update?: VentureUpdateWithWhereUniqueWithoutCategoriesInput | VentureUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: VentureUpdateManyWithWhereWithoutCategoriesInput | VentureUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: VentureScalarWhereInput | VentureScalarWhereInput[]
  }

  export type XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryNestedInput = {
    create?: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput> | XVentureVencureCategoryCreateWithoutVentureCategoryInput[] | XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput[]
    connectOrCreate?: XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput | XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput[]
    upsert?: XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureCategoryInput | XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureCategoryInput[]
    createMany?: XVentureVencureCategoryCreateManyVentureCategoryInputEnvelope
    set?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    disconnect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    delete?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    connect?: XVentureVencureCategoryWhereUniqueInput | XVentureVencureCategoryWhereUniqueInput[]
    update?: XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureCategoryInput | XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureCategoryInput[]
    updateMany?: XVentureVencureCategoryUpdateManyWithWhereWithoutVentureCategoryInput | XVentureVencureCategoryUpdateManyWithWhereWithoutVentureCategoryInput[]
    deleteMany?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
  }

  export type VentureCreateNestedOneWithoutDetailInput = {
    create?: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
    connectOrCreate?: VentureCreateOrConnectWithoutDetailInput
    connect?: VentureWhereUniqueInput
  }

  export type VentureEventCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput> | VentureEventCreateWithoutVentureDetailInput[] | VentureEventUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutVentureDetailInput | VentureEventCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureEventCreateManyVentureDetailInputEnvelope
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
  }

  export type VenturePublicationCreateNestedManyWithoutDetailInput = {
    create?: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput> | VenturePublicationCreateWithoutDetailInput[] | VenturePublicationUncheckedCreateWithoutDetailInput[]
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutDetailInput | VenturePublicationCreateOrConnectWithoutDetailInput[]
    createMany?: VenturePublicationCreateManyDetailInputEnvelope
    connect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
  }

  export type VentureSponsorshipCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput> | VentureSponsorshipCreateWithoutVentureDetailInput[] | VentureSponsorshipUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutVentureDetailInput | VentureSponsorshipCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureSponsorshipCreateManyVentureDetailInputEnvelope
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
  }

  export type VentureSubscriptionCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput> | VentureSubscriptionCreateWithoutVentureDetailInput[] | VentureSubscriptionUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutVentureDetailInput | VentureSubscriptionCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureSubscriptionCreateManyVentureDetailInputEnvelope
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
  }

  export type VentureUncheckedCreateNestedOneWithoutDetailInput = {
    create?: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
    connectOrCreate?: VentureCreateOrConnectWithoutDetailInput
    connect?: VentureWhereUniqueInput
  }

  export type VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput> | VentureEventCreateWithoutVentureDetailInput[] | VentureEventUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutVentureDetailInput | VentureEventCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureEventCreateManyVentureDetailInputEnvelope
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
  }

  export type VenturePublicationUncheckedCreateNestedManyWithoutDetailInput = {
    create?: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput> | VenturePublicationCreateWithoutDetailInput[] | VenturePublicationUncheckedCreateWithoutDetailInput[]
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutDetailInput | VenturePublicationCreateOrConnectWithoutDetailInput[]
    createMany?: VenturePublicationCreateManyDetailInputEnvelope
    connect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
  }

  export type VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput> | VentureSponsorshipCreateWithoutVentureDetailInput[] | VentureSponsorshipUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutVentureDetailInput | VentureSponsorshipCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureSponsorshipCreateManyVentureDetailInputEnvelope
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
  }

  export type VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput = {
    create?: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput> | VentureSubscriptionCreateWithoutVentureDetailInput[] | VentureSubscriptionUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutVentureDetailInput | VentureSubscriptionCreateOrConnectWithoutVentureDetailInput[]
    createMany?: VentureSubscriptionCreateManyVentureDetailInputEnvelope
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
  }

  export type VentureUpdateOneWithoutDetailNestedInput = {
    create?: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
    connectOrCreate?: VentureCreateOrConnectWithoutDetailInput
    upsert?: VentureUpsertWithoutDetailInput
    disconnect?: VentureWhereInput | boolean
    delete?: VentureWhereInput | boolean
    connect?: VentureWhereUniqueInput
    update?: XOR<XOR<VentureUpdateToOneWithWhereWithoutDetailInput, VentureUpdateWithoutDetailInput>, VentureUncheckedUpdateWithoutDetailInput>
  }

  export type VentureEventUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput> | VentureEventCreateWithoutVentureDetailInput[] | VentureEventUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutVentureDetailInput | VentureEventCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureEventUpsertWithWhereUniqueWithoutVentureDetailInput | VentureEventUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureEventCreateManyVentureDetailInputEnvelope
    set?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    disconnect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    delete?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    update?: VentureEventUpdateWithWhereUniqueWithoutVentureDetailInput | VentureEventUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureEventUpdateManyWithWhereWithoutVentureDetailInput | VentureEventUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
  }

  export type VenturePublicationUpdateManyWithoutDetailNestedInput = {
    create?: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput> | VenturePublicationCreateWithoutDetailInput[] | VenturePublicationUncheckedCreateWithoutDetailInput[]
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutDetailInput | VenturePublicationCreateOrConnectWithoutDetailInput[]
    upsert?: VenturePublicationUpsertWithWhereUniqueWithoutDetailInput | VenturePublicationUpsertWithWhereUniqueWithoutDetailInput[]
    createMany?: VenturePublicationCreateManyDetailInputEnvelope
    set?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    disconnect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    delete?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    connect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    update?: VenturePublicationUpdateWithWhereUniqueWithoutDetailInput | VenturePublicationUpdateWithWhereUniqueWithoutDetailInput[]
    updateMany?: VenturePublicationUpdateManyWithWhereWithoutDetailInput | VenturePublicationUpdateManyWithWhereWithoutDetailInput[]
    deleteMany?: VenturePublicationScalarWhereInput | VenturePublicationScalarWhereInput[]
  }

  export type VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput> | VentureSponsorshipCreateWithoutVentureDetailInput[] | VentureSponsorshipUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutVentureDetailInput | VentureSponsorshipCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureSponsorshipUpsertWithWhereUniqueWithoutVentureDetailInput | VentureSponsorshipUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureSponsorshipCreateManyVentureDetailInputEnvelope
    set?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    disconnect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    delete?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    update?: VentureSponsorshipUpdateWithWhereUniqueWithoutVentureDetailInput | VentureSponsorshipUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureSponsorshipUpdateManyWithWhereWithoutVentureDetailInput | VentureSponsorshipUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
  }

  export type VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput> | VentureSubscriptionCreateWithoutVentureDetailInput[] | VentureSubscriptionUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutVentureDetailInput | VentureSubscriptionCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureSubscriptionUpsertWithWhereUniqueWithoutVentureDetailInput | VentureSubscriptionUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureSubscriptionCreateManyVentureDetailInputEnvelope
    set?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    disconnect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    delete?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    update?: VentureSubscriptionUpdateWithWhereUniqueWithoutVentureDetailInput | VentureSubscriptionUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureSubscriptionUpdateManyWithWhereWithoutVentureDetailInput | VentureSubscriptionUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
  }

  export type VentureUncheckedUpdateOneWithoutDetailNestedInput = {
    create?: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
    connectOrCreate?: VentureCreateOrConnectWithoutDetailInput
    upsert?: VentureUpsertWithoutDetailInput
    disconnect?: VentureWhereInput | boolean
    delete?: VentureWhereInput | boolean
    connect?: VentureWhereUniqueInput
    update?: XOR<XOR<VentureUpdateToOneWithWhereWithoutDetailInput, VentureUpdateWithoutDetailInput>, VentureUncheckedUpdateWithoutDetailInput>
  }

  export type VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput> | VentureEventCreateWithoutVentureDetailInput[] | VentureEventUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureEventCreateOrConnectWithoutVentureDetailInput | VentureEventCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureEventUpsertWithWhereUniqueWithoutVentureDetailInput | VentureEventUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureEventCreateManyVentureDetailInputEnvelope
    set?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    disconnect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    delete?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    connect?: VentureEventWhereUniqueInput | VentureEventWhereUniqueInput[]
    update?: VentureEventUpdateWithWhereUniqueWithoutVentureDetailInput | VentureEventUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureEventUpdateManyWithWhereWithoutVentureDetailInput | VentureEventUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
  }

  export type VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput = {
    create?: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput> | VenturePublicationCreateWithoutDetailInput[] | VenturePublicationUncheckedCreateWithoutDetailInput[]
    connectOrCreate?: VenturePublicationCreateOrConnectWithoutDetailInput | VenturePublicationCreateOrConnectWithoutDetailInput[]
    upsert?: VenturePublicationUpsertWithWhereUniqueWithoutDetailInput | VenturePublicationUpsertWithWhereUniqueWithoutDetailInput[]
    createMany?: VenturePublicationCreateManyDetailInputEnvelope
    set?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    disconnect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    delete?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    connect?: VenturePublicationWhereUniqueInput | VenturePublicationWhereUniqueInput[]
    update?: VenturePublicationUpdateWithWhereUniqueWithoutDetailInput | VenturePublicationUpdateWithWhereUniqueWithoutDetailInput[]
    updateMany?: VenturePublicationUpdateManyWithWhereWithoutDetailInput | VenturePublicationUpdateManyWithWhereWithoutDetailInput[]
    deleteMany?: VenturePublicationScalarWhereInput | VenturePublicationScalarWhereInput[]
  }

  export type VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput> | VentureSponsorshipCreateWithoutVentureDetailInput[] | VentureSponsorshipUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSponsorshipCreateOrConnectWithoutVentureDetailInput | VentureSponsorshipCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureSponsorshipUpsertWithWhereUniqueWithoutVentureDetailInput | VentureSponsorshipUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureSponsorshipCreateManyVentureDetailInputEnvelope
    set?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    disconnect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    delete?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    connect?: VentureSponsorshipWhereUniqueInput | VentureSponsorshipWhereUniqueInput[]
    update?: VentureSponsorshipUpdateWithWhereUniqueWithoutVentureDetailInput | VentureSponsorshipUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureSponsorshipUpdateManyWithWhereWithoutVentureDetailInput | VentureSponsorshipUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
  }

  export type VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput = {
    create?: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput> | VentureSubscriptionCreateWithoutVentureDetailInput[] | VentureSubscriptionUncheckedCreateWithoutVentureDetailInput[]
    connectOrCreate?: VentureSubscriptionCreateOrConnectWithoutVentureDetailInput | VentureSubscriptionCreateOrConnectWithoutVentureDetailInput[]
    upsert?: VentureSubscriptionUpsertWithWhereUniqueWithoutVentureDetailInput | VentureSubscriptionUpsertWithWhereUniqueWithoutVentureDetailInput[]
    createMany?: VentureSubscriptionCreateManyVentureDetailInputEnvelope
    set?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    disconnect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    delete?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    connect?: VentureSubscriptionWhereUniqueInput | VentureSubscriptionWhereUniqueInput[]
    update?: VentureSubscriptionUpdateWithWhereUniqueWithoutVentureDetailInput | VentureSubscriptionUpdateWithWhereUniqueWithoutVentureDetailInput[]
    updateMany?: VentureSubscriptionUpdateManyWithWhereWithoutVentureDetailInput | VentureSubscriptionUpdateManyWithWhereWithoutVentureDetailInput[]
    deleteMany?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
  }

  export type EventDonationCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput> | EventDonationCreateWithoutVentureEventInput[] | EventDonationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutVentureEventInput | EventDonationCreateOrConnectWithoutVentureEventInput[]
    createMany?: EventDonationCreateManyVentureEventInputEnvelope
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput> | LocationCreateWithoutVentureEventInput[] | LocationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutVentureEventInput | LocationCreateOrConnectWithoutVentureEventInput[]
    createMany?: LocationCreateManyVentureEventInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type VentureDetailCreateNestedOneWithoutEventInput = {
    create?: XOR<VentureDetailCreateWithoutEventInput, VentureDetailUncheckedCreateWithoutEventInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutEventInput
    connect?: VentureDetailWhereUniqueInput
  }

  export type XEventCategoryCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput> | XEventCategoryCreateWithoutVentureEventInput[] | XEventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutVentureEventInput | XEventCategoryCreateOrConnectWithoutVentureEventInput[]
    createMany?: XEventCategoryCreateManyVentureEventInputEnvelope
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
  }

  export type EventCategoryCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput> | EventCategoryCreateWithoutVentureEventInput[] | EventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutVentureEventInput | EventCategoryCreateOrConnectWithoutVentureEventInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
  }

  export type EventDonationUncheckedCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput> | EventDonationCreateWithoutVentureEventInput[] | EventDonationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutVentureEventInput | EventDonationCreateOrConnectWithoutVentureEventInput[]
    createMany?: EventDonationCreateManyVentureEventInputEnvelope
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput> | LocationCreateWithoutVentureEventInput[] | LocationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutVentureEventInput | LocationCreateOrConnectWithoutVentureEventInput[]
    createMany?: LocationCreateManyVentureEventInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput> | XEventCategoryCreateWithoutVentureEventInput[] | XEventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutVentureEventInput | XEventCategoryCreateOrConnectWithoutVentureEventInput[]
    createMany?: XEventCategoryCreateManyVentureEventInputEnvelope
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
  }

  export type EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput = {
    create?: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput> | EventCategoryCreateWithoutVentureEventInput[] | EventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutVentureEventInput | EventCategoryCreateOrConnectWithoutVentureEventInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
  }

  export type EventDonationUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput> | EventDonationCreateWithoutVentureEventInput[] | EventDonationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutVentureEventInput | EventDonationCreateOrConnectWithoutVentureEventInput[]
    upsert?: EventDonationUpsertWithWhereUniqueWithoutVentureEventInput | EventDonationUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: EventDonationCreateManyVentureEventInputEnvelope
    set?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    disconnect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    delete?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    update?: EventDonationUpdateWithWhereUniqueWithoutVentureEventInput | EventDonationUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: EventDonationUpdateManyWithWhereWithoutVentureEventInput | EventDonationUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput> | LocationCreateWithoutVentureEventInput[] | LocationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutVentureEventInput | LocationCreateOrConnectWithoutVentureEventInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutVentureEventInput | LocationUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: LocationCreateManyVentureEventInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutVentureEventInput | LocationUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutVentureEventInput | LocationUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type VentureDetailUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<VentureDetailCreateWithoutEventInput, VentureDetailUncheckedCreateWithoutEventInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutEventInput
    upsert?: VentureDetailUpsertWithoutEventInput
    connect?: VentureDetailWhereUniqueInput
    update?: XOR<XOR<VentureDetailUpdateToOneWithWhereWithoutEventInput, VentureDetailUpdateWithoutEventInput>, VentureDetailUncheckedUpdateWithoutEventInput>
  }

  export type XEventCategoryUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput> | XEventCategoryCreateWithoutVentureEventInput[] | XEventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutVentureEventInput | XEventCategoryCreateOrConnectWithoutVentureEventInput[]
    upsert?: XEventCategoryUpsertWithWhereUniqueWithoutVentureEventInput | XEventCategoryUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: XEventCategoryCreateManyVentureEventInputEnvelope
    set?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    disconnect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    delete?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    update?: XEventCategoryUpdateWithWhereUniqueWithoutVentureEventInput | XEventCategoryUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: XEventCategoryUpdateManyWithWhereWithoutVentureEventInput | XEventCategoryUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
  }

  export type EventCategoryUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput> | EventCategoryCreateWithoutVentureEventInput[] | EventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutVentureEventInput | EventCategoryCreateOrConnectWithoutVentureEventInput[]
    upsert?: EventCategoryUpsertWithWhereUniqueWithoutVentureEventInput | EventCategoryUpsertWithWhereUniqueWithoutVentureEventInput[]
    set?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    disconnect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    delete?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    update?: EventCategoryUpdateWithWhereUniqueWithoutVentureEventInput | EventCategoryUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: EventCategoryUpdateManyWithWhereWithoutVentureEventInput | EventCategoryUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
  }

  export type EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput> | EventDonationCreateWithoutVentureEventInput[] | EventDonationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventDonationCreateOrConnectWithoutVentureEventInput | EventDonationCreateOrConnectWithoutVentureEventInput[]
    upsert?: EventDonationUpsertWithWhereUniqueWithoutVentureEventInput | EventDonationUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: EventDonationCreateManyVentureEventInputEnvelope
    set?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    disconnect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    delete?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    connect?: EventDonationWhereUniqueInput | EventDonationWhereUniqueInput[]
    update?: EventDonationUpdateWithWhereUniqueWithoutVentureEventInput | EventDonationUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: EventDonationUpdateManyWithWhereWithoutVentureEventInput | EventDonationUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput> | LocationCreateWithoutVentureEventInput[] | LocationUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutVentureEventInput | LocationCreateOrConnectWithoutVentureEventInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutVentureEventInput | LocationUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: LocationCreateManyVentureEventInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutVentureEventInput | LocationUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutVentureEventInput | LocationUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput> | XEventCategoryCreateWithoutVentureEventInput[] | XEventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: XEventCategoryCreateOrConnectWithoutVentureEventInput | XEventCategoryCreateOrConnectWithoutVentureEventInput[]
    upsert?: XEventCategoryUpsertWithWhereUniqueWithoutVentureEventInput | XEventCategoryUpsertWithWhereUniqueWithoutVentureEventInput[]
    createMany?: XEventCategoryCreateManyVentureEventInputEnvelope
    set?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    disconnect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    delete?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    connect?: XEventCategoryWhereUniqueInput | XEventCategoryWhereUniqueInput[]
    update?: XEventCategoryUpdateWithWhereUniqueWithoutVentureEventInput | XEventCategoryUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: XEventCategoryUpdateManyWithWhereWithoutVentureEventInput | XEventCategoryUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
  }

  export type EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput = {
    create?: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput> | EventCategoryCreateWithoutVentureEventInput[] | EventCategoryUncheckedCreateWithoutVentureEventInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutVentureEventInput | EventCategoryCreateOrConnectWithoutVentureEventInput[]
    upsert?: EventCategoryUpsertWithWhereUniqueWithoutVentureEventInput | EventCategoryUpsertWithWhereUniqueWithoutVentureEventInput[]
    set?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    disconnect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    delete?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    update?: EventCategoryUpdateWithWhereUniqueWithoutVentureEventInput | EventCategoryUpdateWithWhereUniqueWithoutVentureEventInput[]
    updateMany?: EventCategoryUpdateManyWithWhereWithoutVentureEventInput | EventCategoryUpdateManyWithWhereWithoutVentureEventInput[]
    deleteMany?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
  }

  export type CommentCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput> | CommentCreateWithoutVenturePublicationInput[] | CommentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVenturePublicationInput | CommentCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: CommentCreateManyVenturePublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PublicationClapCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput> | PublicationClapCreateWithoutVenturePublicationInput[] | PublicationClapUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutVenturePublicationInput | PublicationClapCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: PublicationClapCreateManyVenturePublicationInputEnvelope
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
  }

  export type PublicationContentCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput> | PublicationContentCreateWithoutVenturePublicationInput[] | PublicationContentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationContentCreateOrConnectWithoutVenturePublicationInput | PublicationContentCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: PublicationContentCreateManyVenturePublicationInputEnvelope
    connect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
  }

  export type VentureDetailCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<VentureDetailCreateWithoutPublicationsInput, VentureDetailUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutPublicationsInput
    connect?: VentureDetailWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput> | CommentCreateWithoutVenturePublicationInput[] | CommentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVenturePublicationInput | CommentCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: CommentCreateManyVenturePublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PublicationClapUncheckedCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput> | PublicationClapCreateWithoutVenturePublicationInput[] | PublicationClapUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutVenturePublicationInput | PublicationClapCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: PublicationClapCreateManyVenturePublicationInputEnvelope
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
  }

  export type PublicationContentUncheckedCreateNestedManyWithoutVenturePublicationInput = {
    create?: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput> | PublicationContentCreateWithoutVenturePublicationInput[] | PublicationContentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationContentCreateOrConnectWithoutVenturePublicationInput | PublicationContentCreateOrConnectWithoutVenturePublicationInput[]
    createMany?: PublicationContentCreateManyVenturePublicationInputEnvelope
    connect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
  }

  export type EnumPublicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.PublicationType
  }

  export type CommentUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput> | CommentCreateWithoutVenturePublicationInput[] | CommentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVenturePublicationInput | CommentCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVenturePublicationInput | CommentUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: CommentCreateManyVenturePublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVenturePublicationInput | CommentUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVenturePublicationInput | CommentUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PublicationClapUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput> | PublicationClapCreateWithoutVenturePublicationInput[] | PublicationClapUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutVenturePublicationInput | PublicationClapCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: PublicationClapUpsertWithWhereUniqueWithoutVenturePublicationInput | PublicationClapUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: PublicationClapCreateManyVenturePublicationInputEnvelope
    set?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    disconnect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    delete?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    update?: PublicationClapUpdateWithWhereUniqueWithoutVenturePublicationInput | PublicationClapUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: PublicationClapUpdateManyWithWhereWithoutVenturePublicationInput | PublicationClapUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
  }

  export type PublicationContentUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput> | PublicationContentCreateWithoutVenturePublicationInput[] | PublicationContentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationContentCreateOrConnectWithoutVenturePublicationInput | PublicationContentCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: PublicationContentUpsertWithWhereUniqueWithoutVenturePublicationInput | PublicationContentUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: PublicationContentCreateManyVenturePublicationInputEnvelope
    set?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    disconnect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    delete?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    connect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    update?: PublicationContentUpdateWithWhereUniqueWithoutVenturePublicationInput | PublicationContentUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: PublicationContentUpdateManyWithWhereWithoutVenturePublicationInput | PublicationContentUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: PublicationContentScalarWhereInput | PublicationContentScalarWhereInput[]
  }

  export type VentureDetailUpdateOneRequiredWithoutPublicationsNestedInput = {
    create?: XOR<VentureDetailCreateWithoutPublicationsInput, VentureDetailUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutPublicationsInput
    upsert?: VentureDetailUpsertWithoutPublicationsInput
    connect?: VentureDetailWhereUniqueInput
    update?: XOR<XOR<VentureDetailUpdateToOneWithWhereWithoutPublicationsInput, VentureDetailUpdateWithoutPublicationsInput>, VentureDetailUncheckedUpdateWithoutPublicationsInput>
  }

  export type CommentUncheckedUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput> | CommentCreateWithoutVenturePublicationInput[] | CommentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVenturePublicationInput | CommentCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVenturePublicationInput | CommentUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: CommentCreateManyVenturePublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVenturePublicationInput | CommentUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVenturePublicationInput | CommentUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PublicationClapUncheckedUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput> | PublicationClapCreateWithoutVenturePublicationInput[] | PublicationClapUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationClapCreateOrConnectWithoutVenturePublicationInput | PublicationClapCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: PublicationClapUpsertWithWhereUniqueWithoutVenturePublicationInput | PublicationClapUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: PublicationClapCreateManyVenturePublicationInputEnvelope
    set?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    disconnect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    delete?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    connect?: PublicationClapWhereUniqueInput | PublicationClapWhereUniqueInput[]
    update?: PublicationClapUpdateWithWhereUniqueWithoutVenturePublicationInput | PublicationClapUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: PublicationClapUpdateManyWithWhereWithoutVenturePublicationInput | PublicationClapUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
  }

  export type PublicationContentUncheckedUpdateManyWithoutVenturePublicationNestedInput = {
    create?: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput> | PublicationContentCreateWithoutVenturePublicationInput[] | PublicationContentUncheckedCreateWithoutVenturePublicationInput[]
    connectOrCreate?: PublicationContentCreateOrConnectWithoutVenturePublicationInput | PublicationContentCreateOrConnectWithoutVenturePublicationInput[]
    upsert?: PublicationContentUpsertWithWhereUniqueWithoutVenturePublicationInput | PublicationContentUpsertWithWhereUniqueWithoutVenturePublicationInput[]
    createMany?: PublicationContentCreateManyVenturePublicationInputEnvelope
    set?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    disconnect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    delete?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    connect?: PublicationContentWhereUniqueInput | PublicationContentWhereUniqueInput[]
    update?: PublicationContentUpdateWithWhereUniqueWithoutVenturePublicationInput | PublicationContentUpdateWithWhereUniqueWithoutVenturePublicationInput[]
    updateMany?: PublicationContentUpdateManyWithWhereWithoutVenturePublicationInput | PublicationContentUpdateManyWithWhereWithoutVenturePublicationInput[]
    deleteMany?: PublicationContentScalarWhereInput | PublicationContentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVentureSponsorshipsInput = {
    create?: XOR<UserCreateWithoutVentureSponsorshipsInput, UserUncheckedCreateWithoutVentureSponsorshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVentureSponsorshipsInput
    connect?: UserWhereUniqueInput
  }

  export type VentureDetailCreateNestedOneWithoutSponsorshipInput = {
    create?: XOR<VentureDetailCreateWithoutSponsorshipInput, VentureDetailUncheckedCreateWithoutSponsorshipInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutSponsorshipInput
    connect?: VentureDetailWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVentureSponsorshipsNestedInput = {
    create?: XOR<UserCreateWithoutVentureSponsorshipsInput, UserUncheckedCreateWithoutVentureSponsorshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVentureSponsorshipsInput
    upsert?: UserUpsertWithoutVentureSponsorshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVentureSponsorshipsInput, UserUpdateWithoutVentureSponsorshipsInput>, UserUncheckedUpdateWithoutVentureSponsorshipsInput>
  }

  export type VentureDetailUpdateOneRequiredWithoutSponsorshipNestedInput = {
    create?: XOR<VentureDetailCreateWithoutSponsorshipInput, VentureDetailUncheckedCreateWithoutSponsorshipInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutSponsorshipInput
    upsert?: VentureDetailUpsertWithoutSponsorshipInput
    connect?: VentureDetailWhereUniqueInput
    update?: XOR<XOR<VentureDetailUpdateToOneWithWhereWithoutSponsorshipInput, VentureDetailUpdateWithoutSponsorshipInput>, VentureDetailUncheckedUpdateWithoutSponsorshipInput>
  }

  export type UserCreateNestedOneWithoutVentureSubscriptionsInput = {
    create?: XOR<UserCreateWithoutVentureSubscriptionsInput, UserUncheckedCreateWithoutVentureSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVentureSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type VentureDetailCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<VentureDetailCreateWithoutSubscriptionInput, VentureDetailUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutSubscriptionInput
    connect?: VentureDetailWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVentureSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutVentureSubscriptionsInput, UserUncheckedCreateWithoutVentureSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVentureSubscriptionsInput
    upsert?: UserUpsertWithoutVentureSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVentureSubscriptionsInput, UserUpdateWithoutVentureSubscriptionsInput>, UserUncheckedUpdateWithoutVentureSubscriptionsInput>
  }

  export type VentureDetailUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<VentureDetailCreateWithoutSubscriptionInput, VentureDetailUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: VentureDetailCreateOrConnectWithoutSubscriptionInput
    upsert?: VentureDetailUpsertWithoutSubscriptionInput
    connect?: VentureDetailWhereUniqueInput
    update?: XOR<XOR<VentureDetailUpdateToOneWithWhereWithoutSubscriptionInput, VentureDetailUpdateWithoutSubscriptionInput>, VentureDetailUncheckedUpdateWithoutSubscriptionInput>
  }

  export type EventCategoryCreateNestedOneWithoutXEventCategoryInput = {
    create?: XOR<EventCategoryCreateWithoutXEventCategoryInput, EventCategoryUncheckedCreateWithoutXEventCategoryInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutXEventCategoryInput
    connect?: EventCategoryWhereUniqueInput
  }

  export type VentureEventCreateNestedOneWithoutXEventCategoryInput = {
    create?: XOR<VentureEventCreateWithoutXEventCategoryInput, VentureEventUncheckedCreateWithoutXEventCategoryInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutXEventCategoryInput
    connect?: VentureEventWhereUniqueInput
  }

  export type EventCategoryUpdateOneRequiredWithoutXEventCategoryNestedInput = {
    create?: XOR<EventCategoryCreateWithoutXEventCategoryInput, EventCategoryUncheckedCreateWithoutXEventCategoryInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutXEventCategoryInput
    upsert?: EventCategoryUpsertWithoutXEventCategoryInput
    connect?: EventCategoryWhereUniqueInput
    update?: XOR<XOR<EventCategoryUpdateToOneWithWhereWithoutXEventCategoryInput, EventCategoryUpdateWithoutXEventCategoryInput>, EventCategoryUncheckedUpdateWithoutXEventCategoryInput>
  }

  export type VentureEventUpdateOneRequiredWithoutXEventCategoryNestedInput = {
    create?: XOR<VentureEventCreateWithoutXEventCategoryInput, VentureEventUncheckedCreateWithoutXEventCategoryInput>
    connectOrCreate?: VentureEventCreateOrConnectWithoutXEventCategoryInput
    upsert?: VentureEventUpsertWithoutXEventCategoryInput
    connect?: VentureEventWhereUniqueInput
    update?: XOR<XOR<VentureEventUpdateToOneWithWhereWithoutXEventCategoryInput, VentureEventUpdateWithoutXEventCategoryInput>, VentureEventUncheckedUpdateWithoutXEventCategoryInput>
  }

  export type RoleCreateNestedOneWithoutXUserRolesInput = {
    create?: XOR<RoleCreateWithoutXUserRolesInput, RoleUncheckedCreateWithoutXUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutXUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutXUserRolesInput = {
    create?: XOR<UserCreateWithoutXUserRolesInput, UserUncheckedCreateWithoutXUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutXUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutXUserRolesInput, RoleUncheckedCreateWithoutXUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutXUserRolesInput
    upsert?: RoleUpsertWithoutXUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutXUserRolesInput, RoleUpdateWithoutXUserRolesInput>, RoleUncheckedUpdateWithoutXUserRolesInput>
  }

  export type UserUpdateOneRequiredWithoutXUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutXUserRolesInput, UserUncheckedCreateWithoutXUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutXUserRolesInput
    upsert?: UserUpsertWithoutXUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXUserRolesInput, UserUpdateWithoutXUserRolesInput>, UserUncheckedUpdateWithoutXUserRolesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type NestedEnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type NestedEnumPublicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationType | EnumPublicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationTypeFilter<$PrismaModel> | $Enums.PublicationType
  }

  export type NestedEnumPublicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationType | EnumPublicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationType[] | ListEnumPublicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.PublicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationTypeFilter<$PrismaModel>
    _max?: NestedEnumPublicationTypeFilter<$PrismaModel>
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    VenturePublication: VenturePublicationCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    publicationId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventDonationCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    createdAt?: Date | string
    VentureEvent: VentureEventCreateNestedOneWithoutEventDonationInput
  }

  export type EventDonationUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type EventDonationCreateOrConnectWithoutUserInput = {
    where: EventDonationWhereUniqueInput
    create: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput>
  }

  export type EventDonationCreateManyUserInputEnvelope = {
    data: EventDonationCreateManyUserInput | EventDonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PublicationClapCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    VenturePublication: VenturePublicationCreateNestedOneWithoutPublicationClapInput
  }

  export type PublicationClapUncheckedCreateWithoutUserInput = {
    id: string
    publicationId: string
    createdAt?: Date | string
  }

  export type PublicationClapCreateOrConnectWithoutUserInput = {
    where: PublicationClapWhereUniqueInput
    create: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput>
  }

  export type PublicationClapCreateManyUserInputEnvelope = {
    data: PublicationClapCreateManyUserInput | PublicationClapCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VentureCreateWithoutOwnerInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    detail: VentureDetailCreateNestedOneWithoutVentureInput
    categories?: VentureCategoryCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureInput
  }

  export type VentureUncheckedCreateWithoutOwnerInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: VentureCategoryUncheckedCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureInput
  }

  export type VentureCreateOrConnectWithoutOwnerInput = {
    where: VentureWhereUniqueInput
    create: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput>
  }

  export type VentureCreateManyOwnerInputEnvelope = {
    data: VentureCreateManyOwnerInput | VentureCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type VentureSponsorshipCreateWithoutUserInput = {
    id: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    VentureDetail: VentureDetailCreateNestedOneWithoutSponsorshipInput
  }

  export type VentureSponsorshipUncheckedCreateWithoutUserInput = {
    id: string
    ventureDetailId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipCreateOrConnectWithoutUserInput = {
    where: VentureSponsorshipWhereUniqueInput
    create: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput>
  }

  export type VentureSponsorshipCreateManyUserInputEnvelope = {
    data: VentureSponsorshipCreateManyUserInput | VentureSponsorshipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VentureSubscriptionCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    VentureDetail: VentureDetailCreateNestedOneWithoutSubscriptionInput
  }

  export type VentureSubscriptionUncheckedCreateWithoutUserInput = {
    id: string
    ventureId: string
    createdAt?: Date | string
  }

  export type VentureSubscriptionCreateOrConnectWithoutUserInput = {
    where: VentureSubscriptionWhereUniqueInput
    create: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type VentureSubscriptionCreateManyUserInputEnvelope = {
    data: VentureSubscriptionCreateManyUserInput | VentureSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XUserRoles?: XUserRolesCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserDetailCreateWithoutUserInput = {
    id?: string
    gender: string
    birthDate: Date | string
    municipality: MunicipalityCreateNestedOneWithoutUserDetailInput
  }

  export type UserDetailUncheckedCreateWithoutUserInput = {
    id?: string
    gender: string
    birthDate: Date | string
    municipalityId: number
  }

  export type UserDetailCreateOrConnectWithoutUserInput = {
    where: UserDetailWhereUniqueInput
    create: XOR<UserDetailCreateWithoutUserInput, UserDetailUncheckedCreateWithoutUserInput>
  }

  export type XUserRolesCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    Role: RoleCreateNestedOneWithoutXUserRolesInput
  }

  export type XUserRolesUncheckedCreateWithoutUserInput = {
    id: string
    roleId: string
    createdAt?: Date | string
  }

  export type XUserRolesCreateOrConnectWithoutUserInput = {
    where: XUserRolesWhereUniqueInput
    create: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput>
  }

  export type XUserRolesCreateManyUserInputEnvelope = {
    data: XUserRolesCreateManyUserInput | XUserRolesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VentureCategoryCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureUncheckedCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryCreateOrConnectWithoutUsersInput = {
    where: VentureCategoryWhereUniqueInput
    create: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput>
  }

  export type XUserPreferencesCreateWithoutUserInput = {
    VentureCategory: VentureCategoryCreateNestedOneWithoutXUserPreferencesInput
  }

  export type XUserPreferencesUncheckedCreateWithoutUserInput = {
    categoryId: string
  }

  export type XUserPreferencesCreateOrConnectWithoutUserInput = {
    where: XUserPreferencesWhereUniqueInput
    create: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type XUserPreferencesCreateManyUserInputEnvelope = {
    data: XUserPreferencesCreateManyUserInput | XUserPreferencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type EventDonationUpsertWithWhereUniqueWithoutUserInput = {
    where: EventDonationWhereUniqueInput
    update: XOR<EventDonationUpdateWithoutUserInput, EventDonationUncheckedUpdateWithoutUserInput>
    create: XOR<EventDonationCreateWithoutUserInput, EventDonationUncheckedCreateWithoutUserInput>
  }

  export type EventDonationUpdateWithWhereUniqueWithoutUserInput = {
    where: EventDonationWhereUniqueInput
    data: XOR<EventDonationUpdateWithoutUserInput, EventDonationUncheckedUpdateWithoutUserInput>
  }

  export type EventDonationUpdateManyWithWhereWithoutUserInput = {
    where: EventDonationScalarWhereInput
    data: XOR<EventDonationUpdateManyMutationInput, EventDonationUncheckedUpdateManyWithoutUserInput>
  }

  export type EventDonationScalarWhereInput = {
    AND?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
    OR?: EventDonationScalarWhereInput[]
    NOT?: EventDonationScalarWhereInput | EventDonationScalarWhereInput[]
    id?: StringFilter<"EventDonation"> | string
    userId?: StringFilter<"EventDonation"> | string
    eventId?: StringFilter<"EventDonation"> | string
    amount?: FloatFilter<"EventDonation"> | number
    currency?: StringFilter<"EventDonation"> | string
    createdAt?: DateTimeFilter<"EventDonation"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    description?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PublicationClapUpsertWithWhereUniqueWithoutUserInput = {
    where: PublicationClapWhereUniqueInput
    update: XOR<PublicationClapUpdateWithoutUserInput, PublicationClapUncheckedUpdateWithoutUserInput>
    create: XOR<PublicationClapCreateWithoutUserInput, PublicationClapUncheckedCreateWithoutUserInput>
  }

  export type PublicationClapUpdateWithWhereUniqueWithoutUserInput = {
    where: PublicationClapWhereUniqueInput
    data: XOR<PublicationClapUpdateWithoutUserInput, PublicationClapUncheckedUpdateWithoutUserInput>
  }

  export type PublicationClapUpdateManyWithWhereWithoutUserInput = {
    where: PublicationClapScalarWhereInput
    data: XOR<PublicationClapUpdateManyMutationInput, PublicationClapUncheckedUpdateManyWithoutUserInput>
  }

  export type PublicationClapScalarWhereInput = {
    AND?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
    OR?: PublicationClapScalarWhereInput[]
    NOT?: PublicationClapScalarWhereInput | PublicationClapScalarWhereInput[]
    id?: StringFilter<"PublicationClap"> | string
    userId?: StringFilter<"PublicationClap"> | string
    publicationId?: StringFilter<"PublicationClap"> | string
    createdAt?: DateTimeFilter<"PublicationClap"> | Date | string
  }

  export type VentureUpsertWithWhereUniqueWithoutOwnerInput = {
    where: VentureWhereUniqueInput
    update: XOR<VentureUpdateWithoutOwnerInput, VentureUncheckedUpdateWithoutOwnerInput>
    create: XOR<VentureCreateWithoutOwnerInput, VentureUncheckedCreateWithoutOwnerInput>
  }

  export type VentureUpdateWithWhereUniqueWithoutOwnerInput = {
    where: VentureWhereUniqueInput
    data: XOR<VentureUpdateWithoutOwnerInput, VentureUncheckedUpdateWithoutOwnerInput>
  }

  export type VentureUpdateManyWithWhereWithoutOwnerInput = {
    where: VentureScalarWhereInput
    data: XOR<VentureUpdateManyMutationInput, VentureUncheckedUpdateManyWithoutOwnerInput>
  }

  export type VentureScalarWhereInput = {
    AND?: VentureScalarWhereInput | VentureScalarWhereInput[]
    OR?: VentureScalarWhereInput[]
    NOT?: VentureScalarWhereInput | VentureScalarWhereInput[]
    id?: StringFilter<"Venture"> | string
    name?: StringFilter<"Venture"> | string
    slug?: StringFilter<"Venture"> | string
    coverPhoto?: StringFilter<"Venture"> | string
    description?: StringFilter<"Venture"> | string
    ownerId?: StringFilter<"Venture"> | string
    active?: BoolFilter<"Venture"> | boolean
    verified?: BoolFilter<"Venture"> | boolean
    detailId?: StringFilter<"Venture"> | string
    createdAt?: DateTimeFilter<"Venture"> | Date | string
    updatedAt?: DateTimeFilter<"Venture"> | Date | string
  }

  export type VentureSponsorshipUpsertWithWhereUniqueWithoutUserInput = {
    where: VentureSponsorshipWhereUniqueInput
    update: XOR<VentureSponsorshipUpdateWithoutUserInput, VentureSponsorshipUncheckedUpdateWithoutUserInput>
    create: XOR<VentureSponsorshipCreateWithoutUserInput, VentureSponsorshipUncheckedCreateWithoutUserInput>
  }

  export type VentureSponsorshipUpdateWithWhereUniqueWithoutUserInput = {
    where: VentureSponsorshipWhereUniqueInput
    data: XOR<VentureSponsorshipUpdateWithoutUserInput, VentureSponsorshipUncheckedUpdateWithoutUserInput>
  }

  export type VentureSponsorshipUpdateManyWithWhereWithoutUserInput = {
    where: VentureSponsorshipScalarWhereInput
    data: XOR<VentureSponsorshipUpdateManyMutationInput, VentureSponsorshipUncheckedUpdateManyWithoutUserInput>
  }

  export type VentureSponsorshipScalarWhereInput = {
    AND?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
    OR?: VentureSponsorshipScalarWhereInput[]
    NOT?: VentureSponsorshipScalarWhereInput | VentureSponsorshipScalarWhereInput[]
    id?: StringFilter<"VentureSponsorship"> | string
    sponsorId?: StringFilter<"VentureSponsorship"> | string
    ventureDetailId?: StringFilter<"VentureSponsorship"> | string
    monthlyAmount?: FloatFilter<"VentureSponsorship"> | number
    createdAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
    updatedAt?: DateTimeFilter<"VentureSponsorship"> | Date | string
  }

  export type VentureSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: VentureSubscriptionWhereUniqueInput
    update: XOR<VentureSubscriptionUpdateWithoutUserInput, VentureSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<VentureSubscriptionCreateWithoutUserInput, VentureSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type VentureSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: VentureSubscriptionWhereUniqueInput
    data: XOR<VentureSubscriptionUpdateWithoutUserInput, VentureSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type VentureSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: VentureSubscriptionScalarWhereInput
    data: XOR<VentureSubscriptionUpdateManyMutationInput, VentureSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type VentureSubscriptionScalarWhereInput = {
    AND?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
    OR?: VentureSubscriptionScalarWhereInput[]
    NOT?: VentureSubscriptionScalarWhereInput | VentureSubscriptionScalarWhereInput[]
    id?: StringFilter<"VentureSubscription"> | string
    subscriberId?: StringFilter<"VentureSubscription"> | string
    ventureId?: StringFilter<"VentureSubscription"> | string
    createdAt?: DateTimeFilter<"VentureSubscription"> | Date | string
  }

  export type RoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateManyWithWhereWithoutUsersInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutUsersInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: EnumAppRoleFilter<"Role"> | $Enums.AppRole
    label?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type UserDetailUpsertWithoutUserInput = {
    update: XOR<UserDetailUpdateWithoutUserInput, UserDetailUncheckedUpdateWithoutUserInput>
    create: XOR<UserDetailCreateWithoutUserInput, UserDetailUncheckedCreateWithoutUserInput>
    where?: UserDetailWhereInput
  }

  export type UserDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: UserDetailWhereInput
    data: XOR<UserDetailUpdateWithoutUserInput, UserDetailUncheckedUpdateWithoutUserInput>
  }

  export type UserDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    municipality?: MunicipalityUpdateOneRequiredWithoutUserDetailNestedInput
  }

  export type UserDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalityId?: IntFieldUpdateOperationsInput | number
  }

  export type XUserRolesUpsertWithWhereUniqueWithoutUserInput = {
    where: XUserRolesWhereUniqueInput
    update: XOR<XUserRolesUpdateWithoutUserInput, XUserRolesUncheckedUpdateWithoutUserInput>
    create: XOR<XUserRolesCreateWithoutUserInput, XUserRolesUncheckedCreateWithoutUserInput>
  }

  export type XUserRolesUpdateWithWhereUniqueWithoutUserInput = {
    where: XUserRolesWhereUniqueInput
    data: XOR<XUserRolesUpdateWithoutUserInput, XUserRolesUncheckedUpdateWithoutUserInput>
  }

  export type XUserRolesUpdateManyWithWhereWithoutUserInput = {
    where: XUserRolesScalarWhereInput
    data: XOR<XUserRolesUpdateManyMutationInput, XUserRolesUncheckedUpdateManyWithoutUserInput>
  }

  export type XUserRolesScalarWhereInput = {
    AND?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
    OR?: XUserRolesScalarWhereInput[]
    NOT?: XUserRolesScalarWhereInput | XUserRolesScalarWhereInput[]
    id?: StringFilter<"XUserRoles"> | string
    userId?: StringFilter<"XUserRoles"> | string
    roleId?: StringFilter<"XUserRoles"> | string
    createdAt?: DateTimeFilter<"XUserRoles"> | Date | string
  }

  export type VentureCategoryUpsertWithWhereUniqueWithoutUsersInput = {
    where: VentureCategoryWhereUniqueInput
    update: XOR<VentureCategoryUpdateWithoutUsersInput, VentureCategoryUncheckedUpdateWithoutUsersInput>
    create: XOR<VentureCategoryCreateWithoutUsersInput, VentureCategoryUncheckedCreateWithoutUsersInput>
  }

  export type VentureCategoryUpdateWithWhereUniqueWithoutUsersInput = {
    where: VentureCategoryWhereUniqueInput
    data: XOR<VentureCategoryUpdateWithoutUsersInput, VentureCategoryUncheckedUpdateWithoutUsersInput>
  }

  export type VentureCategoryUpdateManyWithWhereWithoutUsersInput = {
    where: VentureCategoryScalarWhereInput
    data: XOR<VentureCategoryUpdateManyMutationInput, VentureCategoryUncheckedUpdateManyWithoutUsersInput>
  }

  export type VentureCategoryScalarWhereInput = {
    AND?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
    OR?: VentureCategoryScalarWhereInput[]
    NOT?: VentureCategoryScalarWhereInput | VentureCategoryScalarWhereInput[]
    id?: StringFilter<"VentureCategory"> | string
    name?: StringFilter<"VentureCategory"> | string
    slug?: StringFilter<"VentureCategory"> | string
    description?: StringFilter<"VentureCategory"> | string
    createdAt?: DateTimeFilter<"VentureCategory"> | Date | string
    updatedAt?: DateTimeFilter<"VentureCategory"> | Date | string
  }

  export type XUserPreferencesUpsertWithWhereUniqueWithoutUserInput = {
    where: XUserPreferencesWhereUniqueInput
    update: XOR<XUserPreferencesUpdateWithoutUserInput, XUserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<XUserPreferencesCreateWithoutUserInput, XUserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type XUserPreferencesUpdateWithWhereUniqueWithoutUserInput = {
    where: XUserPreferencesWhereUniqueInput
    data: XOR<XUserPreferencesUpdateWithoutUserInput, XUserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type XUserPreferencesUpdateManyWithWhereWithoutUserInput = {
    where: XUserPreferencesScalarWhereInput
    data: XOR<XUserPreferencesUpdateManyMutationInput, XUserPreferencesUncheckedUpdateManyWithoutUserInput>
  }

  export type XUserPreferencesScalarWhereInput = {
    AND?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
    OR?: XUserPreferencesScalarWhereInput[]
    NOT?: XUserPreferencesScalarWhereInput | XUserPreferencesScalarWhereInput[]
    userId?: StringFilter<"XUserPreferences"> | string
    categoryId?: StringFilter<"XUserPreferences"> | string
  }

  export type UserCreateWithoutXUserPreferencesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutXUserPreferencesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutXUserPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXUserPreferencesInput, UserUncheckedCreateWithoutXUserPreferencesInput>
  }

  export type VentureCategoryCreateWithoutXUserPreferencesInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPreferencesInput
    ventures?: VentureCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryUncheckedCreateWithoutXUserPreferencesInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPreferencesInput
    ventures?: VentureUncheckedCreateNestedManyWithoutCategoriesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryCreateOrConnectWithoutXUserPreferencesInput = {
    where: VentureCategoryWhereUniqueInput
    create: XOR<VentureCategoryCreateWithoutXUserPreferencesInput, VentureCategoryUncheckedCreateWithoutXUserPreferencesInput>
  }

  export type UserUpsertWithoutXUserPreferencesInput = {
    update: XOR<UserUpdateWithoutXUserPreferencesInput, UserUncheckedUpdateWithoutXUserPreferencesInput>
    create: XOR<UserCreateWithoutXUserPreferencesInput, UserUncheckedCreateWithoutXUserPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXUserPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXUserPreferencesInput, UserUncheckedUpdateWithoutXUserPreferencesInput>
  }

  export type UserUpdateWithoutXUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutXUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type VentureCategoryUpsertWithoutXUserPreferencesInput = {
    update: XOR<VentureCategoryUpdateWithoutXUserPreferencesInput, VentureCategoryUncheckedUpdateWithoutXUserPreferencesInput>
    create: XOR<VentureCategoryCreateWithoutXUserPreferencesInput, VentureCategoryUncheckedCreateWithoutXUserPreferencesInput>
    where?: VentureCategoryWhereInput
  }

  export type VentureCategoryUpdateToOneWithWhereWithoutXUserPreferencesInput = {
    where?: VentureCategoryWhereInput
    data: XOR<VentureCategoryUpdateWithoutXUserPreferencesInput, VentureCategoryUncheckedUpdateWithoutXUserPreferencesInput>
  }

  export type VentureCategoryUpdateWithoutXUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPreferencesNestedInput
    ventures?: VentureUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateWithoutXUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPreferencesNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryNestedInput
  }

  export type UserCreateWithoutDetailInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDetailInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDetailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
  }

  export type MunicipalityCreateWithoutUserDetailInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Department?: DepartmentCreateNestedOneWithoutMunicipalitiesInput
  }

  export type MunicipalityUncheckedCreateWithoutUserDetailInput = {
    id?: number
    name: string
    departmentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MunicipalityCreateOrConnectWithoutUserDetailInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutUserDetailInput, MunicipalityUncheckedCreateWithoutUserDetailInput>
  }

  export type UserUpsertWithoutDetailInput = {
    update: XOR<UserUpdateWithoutDetailInput, UserUncheckedUpdateWithoutDetailInput>
    create: XOR<UserCreateWithoutDetailInput, UserUncheckedCreateWithoutDetailInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDetailInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDetailInput, UserUncheckedUpdateWithoutDetailInput>
  }

  export type UserUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MunicipalityUpsertWithoutUserDetailInput = {
    update: XOR<MunicipalityUpdateWithoutUserDetailInput, MunicipalityUncheckedUpdateWithoutUserDetailInput>
    create: XOR<MunicipalityCreateWithoutUserDetailInput, MunicipalityUncheckedCreateWithoutUserDetailInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutUserDetailInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutUserDetailInput, MunicipalityUncheckedUpdateWithoutUserDetailInput>
  }

  export type MunicipalityUpdateWithoutUserDetailInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Department?: DepartmentUpdateOneWithoutMunicipalitiesNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutUserDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityCreateWithoutDepartmentInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserDetail?: UserDetailCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserDetail?: UserDetailUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput>
  }

  export type MunicipalityCreateManyDepartmentInputEnvelope = {
    data: MunicipalityCreateManyDepartmentInput | MunicipalityCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    update: XOR<MunicipalityUpdateWithoutDepartmentInput, MunicipalityUncheckedUpdateWithoutDepartmentInput>
    create: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput>
  }

  export type MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    data: XOR<MunicipalityUpdateWithoutDepartmentInput, MunicipalityUncheckedUpdateWithoutDepartmentInput>
  }

  export type MunicipalityUpdateManyWithWhereWithoutDepartmentInput = {
    where: MunicipalityScalarWhereInput
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type MunicipalityScalarWhereInput = {
    AND?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    OR?: MunicipalityScalarWhereInput[]
    NOT?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    id?: IntFilter<"Municipality"> | number
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
    updatedAt?: DateTimeFilter<"Municipality"> | Date | string
  }

  export type DepartmentCreateWithoutMunicipalitiesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUncheckedCreateWithoutMunicipalitiesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutMunicipalitiesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutMunicipalitiesInput, DepartmentUncheckedCreateWithoutMunicipalitiesInput>
  }

  export type UserDetailCreateWithoutMunicipalityInput = {
    id?: string
    gender: string
    birthDate: Date | string
    user?: UserCreateNestedOneWithoutDetailInput
  }

  export type UserDetailUncheckedCreateWithoutMunicipalityInput = {
    id?: string
    gender: string
    birthDate: Date | string
    user?: UserUncheckedCreateNestedOneWithoutDetailInput
  }

  export type UserDetailCreateOrConnectWithoutMunicipalityInput = {
    where: UserDetailWhereUniqueInput
    create: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput>
  }

  export type UserDetailCreateManyMunicipalityInputEnvelope = {
    data: UserDetailCreateManyMunicipalityInput | UserDetailCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutMunicipalitiesInput = {
    update: XOR<DepartmentUpdateWithoutMunicipalitiesInput, DepartmentUncheckedUpdateWithoutMunicipalitiesInput>
    create: XOR<DepartmentCreateWithoutMunicipalitiesInput, DepartmentUncheckedCreateWithoutMunicipalitiesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutMunicipalitiesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutMunicipalitiesInput, DepartmentUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type DepartmentUpdateWithoutMunicipalitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutMunicipalitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDetailUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: UserDetailWhereUniqueInput
    update: XOR<UserDetailUpdateWithoutMunicipalityInput, UserDetailUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<UserDetailCreateWithoutMunicipalityInput, UserDetailUncheckedCreateWithoutMunicipalityInput>
  }

  export type UserDetailUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: UserDetailWhereUniqueInput
    data: XOR<UserDetailUpdateWithoutMunicipalityInput, UserDetailUncheckedUpdateWithoutMunicipalityInput>
  }

  export type UserDetailUpdateManyWithWhereWithoutMunicipalityInput = {
    where: UserDetailScalarWhereInput
    data: XOR<UserDetailUpdateManyMutationInput, UserDetailUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type UserDetailScalarWhereInput = {
    AND?: UserDetailScalarWhereInput | UserDetailScalarWhereInput[]
    OR?: UserDetailScalarWhereInput[]
    NOT?: UserDetailScalarWhereInput | UserDetailScalarWhereInput[]
    id?: StringFilter<"UserDetail"> | string
    gender?: StringFilter<"UserDetail"> | string
    birthDate?: DateTimeFilter<"UserDetail"> | Date | string
    municipalityId?: IntFilter<"UserDetail"> | number
  }

  export type VenturePublicationCreateWithoutCommentInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PublicationClap?: PublicationClapCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentCreateNestedManyWithoutVenturePublicationInput
    detail: VentureDetailCreateNestedOneWithoutPublicationsInput
  }

  export type VenturePublicationUncheckedCreateWithoutCommentInput = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PublicationClap?: PublicationClapUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentUncheckedCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationCreateOrConnectWithoutCommentInput = {
    where: VenturePublicationWhereUniqueInput
    create: XOR<VenturePublicationCreateWithoutCommentInput, VenturePublicationUncheckedCreateWithoutCommentInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type VenturePublicationUpsertWithoutCommentInput = {
    update: XOR<VenturePublicationUpdateWithoutCommentInput, VenturePublicationUncheckedUpdateWithoutCommentInput>
    create: XOR<VenturePublicationCreateWithoutCommentInput, VenturePublicationUncheckedCreateWithoutCommentInput>
    where?: VenturePublicationWhereInput
  }

  export type VenturePublicationUpdateToOneWithWhereWithoutCommentInput = {
    where?: VenturePublicationWhereInput
    data: XOR<VenturePublicationUpdateWithoutCommentInput, VenturePublicationUncheckedUpdateWithoutCommentInput>
  }

  export type VenturePublicationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationClap?: PublicationClapUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUpdateManyWithoutVenturePublicationNestedInput
    detail?: VentureDetailUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type VenturePublicationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detailId?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PublicationClap?: PublicationClapUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUncheckedUpdateManyWithoutVenturePublicationNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type XEventCategoryCreateWithoutEventCategoryInput = {
    VentureEvent: VentureEventCreateNestedOneWithoutXEventCategoryInput
  }

  export type XEventCategoryUncheckedCreateWithoutEventCategoryInput = {
    eventId: string
  }

  export type XEventCategoryCreateOrConnectWithoutEventCategoryInput = {
    where: XEventCategoryWhereUniqueInput
    create: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput>
  }

  export type XEventCategoryCreateManyEventCategoryInputEnvelope = {
    data: XEventCategoryCreateManyEventCategoryInput | XEventCategoryCreateManyEventCategoryInput[]
    skipDuplicates?: boolean
  }

  export type VentureEventCreateWithoutEventCategoryInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationCreateNestedManyWithoutVentureEventInput
    Location?: LocationCreateNestedManyWithoutVentureEventInput
    VentureDetail: VentureDetailCreateNestedOneWithoutEventInput
    XEventCategory?: XEventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateWithoutEventCategoryInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationUncheckedCreateNestedManyWithoutVentureEventInput
    Location?: LocationUncheckedCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventCreateOrConnectWithoutEventCategoryInput = {
    where: VentureEventWhereUniqueInput
    create: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput>
  }

  export type XEventCategoryUpsertWithWhereUniqueWithoutEventCategoryInput = {
    where: XEventCategoryWhereUniqueInput
    update: XOR<XEventCategoryUpdateWithoutEventCategoryInput, XEventCategoryUncheckedUpdateWithoutEventCategoryInput>
    create: XOR<XEventCategoryCreateWithoutEventCategoryInput, XEventCategoryUncheckedCreateWithoutEventCategoryInput>
  }

  export type XEventCategoryUpdateWithWhereUniqueWithoutEventCategoryInput = {
    where: XEventCategoryWhereUniqueInput
    data: XOR<XEventCategoryUpdateWithoutEventCategoryInput, XEventCategoryUncheckedUpdateWithoutEventCategoryInput>
  }

  export type XEventCategoryUpdateManyWithWhereWithoutEventCategoryInput = {
    where: XEventCategoryScalarWhereInput
    data: XOR<XEventCategoryUpdateManyMutationInput, XEventCategoryUncheckedUpdateManyWithoutEventCategoryInput>
  }

  export type XEventCategoryScalarWhereInput = {
    AND?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
    OR?: XEventCategoryScalarWhereInput[]
    NOT?: XEventCategoryScalarWhereInput | XEventCategoryScalarWhereInput[]
    eventId?: StringFilter<"XEventCategory"> | string
    categoryId?: StringFilter<"XEventCategory"> | string
  }

  export type VentureEventUpsertWithWhereUniqueWithoutEventCategoryInput = {
    where: VentureEventWhereUniqueInput
    update: XOR<VentureEventUpdateWithoutEventCategoryInput, VentureEventUncheckedUpdateWithoutEventCategoryInput>
    create: XOR<VentureEventCreateWithoutEventCategoryInput, VentureEventUncheckedCreateWithoutEventCategoryInput>
  }

  export type VentureEventUpdateWithWhereUniqueWithoutEventCategoryInput = {
    where: VentureEventWhereUniqueInput
    data: XOR<VentureEventUpdateWithoutEventCategoryInput, VentureEventUncheckedUpdateWithoutEventCategoryInput>
  }

  export type VentureEventUpdateManyWithWhereWithoutEventCategoryInput = {
    where: VentureEventScalarWhereInput
    data: XOR<VentureEventUpdateManyMutationInput, VentureEventUncheckedUpdateManyWithoutEventCategoryInput>
  }

  export type VentureEventScalarWhereInput = {
    AND?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
    OR?: VentureEventScalarWhereInput[]
    NOT?: VentureEventScalarWhereInput | VentureEventScalarWhereInput[]
    id?: StringFilter<"VentureEvent"> | string
    title?: StringFilter<"VentureEvent"> | string
    description?: StringFilter<"VentureEvent"> | string
    coverPhoto?: StringFilter<"VentureEvent"> | string
    ventureId?: StringFilter<"VentureEvent"> | string
    startDate?: DateTimeFilter<"VentureEvent"> | Date | string
    endDate?: DateTimeFilter<"VentureEvent"> | Date | string
    createdAt?: DateTimeFilter<"VentureEvent"> | Date | string
    updatedAt?: DateTimeFilter<"VentureEvent"> | Date | string
  }

  export type VentureEventCreateWithoutEventDonationInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationCreateNestedManyWithoutVentureEventInput
    VentureDetail: VentureDetailCreateNestedOneWithoutEventInput
    XEventCategory?: XEventCategoryCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateWithoutEventDonationInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Location?: LocationUncheckedCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventCreateOrConnectWithoutEventDonationInput = {
    where: VentureEventWhereUniqueInput
    create: XOR<VentureEventCreateWithoutEventDonationInput, VentureEventUncheckedCreateWithoutEventDonationInput>
  }

  export type UserCreateWithoutEventDonationsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventDonationsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventDonationsInput, UserUncheckedCreateWithoutEventDonationsInput>
  }

  export type VentureEventUpsertWithoutEventDonationInput = {
    update: XOR<VentureEventUpdateWithoutEventDonationInput, VentureEventUncheckedUpdateWithoutEventDonationInput>
    create: XOR<VentureEventCreateWithoutEventDonationInput, VentureEventUncheckedCreateWithoutEventDonationInput>
    where?: VentureEventWhereInput
  }

  export type VentureEventUpdateToOneWithWhereWithoutEventDonationInput = {
    where?: VentureEventWhereInput
    data: XOR<VentureEventUpdateWithoutEventDonationInput, VentureEventUncheckedUpdateWithoutEventDonationInput>
  }

  export type VentureEventUpdateWithoutEventDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUpdateManyWithoutVentureEventNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutEventNestedInput
    XEventCategory?: XEventCategoryUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateWithoutEventDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Location?: LocationUncheckedUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type UserUpsertWithoutEventDonationsInput = {
    update: XOR<UserUpdateWithoutEventDonationsInput, UserUncheckedUpdateWithoutEventDonationsInput>
    create: XOR<UserCreateWithoutEventDonationsInput, UserUncheckedCreateWithoutEventDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventDonationsInput, UserUncheckedUpdateWithoutEventDonationsInput>
  }

  export type UserUpdateWithoutEventDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VentureEventCreateWithoutLocationInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationCreateNestedManyWithoutVentureEventInput
    VentureDetail: VentureDetailCreateNestedOneWithoutEventInput
    XEventCategory?: XEventCategoryCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateWithoutLocationInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationUncheckedCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventCreateOrConnectWithoutLocationInput = {
    where: VentureEventWhereUniqueInput
    create: XOR<VentureEventCreateWithoutLocationInput, VentureEventUncheckedCreateWithoutLocationInput>
  }

  export type VentureEventUpsertWithoutLocationInput = {
    update: XOR<VentureEventUpdateWithoutLocationInput, VentureEventUncheckedUpdateWithoutLocationInput>
    create: XOR<VentureEventCreateWithoutLocationInput, VentureEventUncheckedCreateWithoutLocationInput>
    where?: VentureEventWhereInput
  }

  export type VentureEventUpdateToOneWithWhereWithoutLocationInput = {
    where?: VentureEventWhereInput
    data: XOR<VentureEventUpdateWithoutLocationInput, VentureEventUncheckedUpdateWithoutLocationInput>
  }

  export type VentureEventUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUpdateManyWithoutVentureEventNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutEventNestedInput
    XEventCategory?: XEventCategoryUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenturePublicationCreateWithoutPublicationClapInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentCreateNestedManyWithoutVenturePublicationInput
    detail: VentureDetailCreateNestedOneWithoutPublicationsInput
  }

  export type VenturePublicationUncheckedCreateWithoutPublicationClapInput = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentUncheckedCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationCreateOrConnectWithoutPublicationClapInput = {
    where: VenturePublicationWhereUniqueInput
    create: XOR<VenturePublicationCreateWithoutPublicationClapInput, VenturePublicationUncheckedCreateWithoutPublicationClapInput>
  }

  export type UserCreateWithoutPublicationClapsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublicationClapsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublicationClapsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublicationClapsInput, UserUncheckedCreateWithoutPublicationClapsInput>
  }

  export type VenturePublicationUpsertWithoutPublicationClapInput = {
    update: XOR<VenturePublicationUpdateWithoutPublicationClapInput, VenturePublicationUncheckedUpdateWithoutPublicationClapInput>
    create: XOR<VenturePublicationCreateWithoutPublicationClapInput, VenturePublicationUncheckedCreateWithoutPublicationClapInput>
    where?: VenturePublicationWhereInput
  }

  export type VenturePublicationUpdateToOneWithWhereWithoutPublicationClapInput = {
    where?: VenturePublicationWhereInput
    data: XOR<VenturePublicationUpdateWithoutPublicationClapInput, VenturePublicationUncheckedUpdateWithoutPublicationClapInput>
  }

  export type VenturePublicationUpdateWithoutPublicationClapInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUpdateManyWithoutVenturePublicationNestedInput
    detail?: VentureDetailUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type VenturePublicationUncheckedUpdateWithoutPublicationClapInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detailId?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUncheckedUpdateManyWithoutVenturePublicationNestedInput
  }

  export type UserUpsertWithoutPublicationClapsInput = {
    update: XOR<UserUpdateWithoutPublicationClapsInput, UserUncheckedUpdateWithoutPublicationClapsInput>
    create: XOR<UserCreateWithoutPublicationClapsInput, UserUncheckedCreateWithoutPublicationClapsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublicationClapsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublicationClapsInput, UserUncheckedUpdateWithoutPublicationClapsInput>
  }

  export type UserUpdateWithoutPublicationClapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublicationClapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenturePublicationCreateWithoutPublicationContentInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapCreateNestedManyWithoutVenturePublicationInput
    detail: VentureDetailCreateNestedOneWithoutPublicationsInput
  }

  export type VenturePublicationUncheckedCreateWithoutPublicationContentInput = {
    id: string
    description: string
    detailId: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapUncheckedCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationCreateOrConnectWithoutPublicationContentInput = {
    where: VenturePublicationWhereUniqueInput
    create: XOR<VenturePublicationCreateWithoutPublicationContentInput, VenturePublicationUncheckedCreateWithoutPublicationContentInput>
  }

  export type VenturePublicationUpsertWithoutPublicationContentInput = {
    update: XOR<VenturePublicationUpdateWithoutPublicationContentInput, VenturePublicationUncheckedUpdateWithoutPublicationContentInput>
    create: XOR<VenturePublicationCreateWithoutPublicationContentInput, VenturePublicationUncheckedCreateWithoutPublicationContentInput>
    where?: VenturePublicationWhereInput
  }

  export type VenturePublicationUpdateToOneWithWhereWithoutPublicationContentInput = {
    where?: VenturePublicationWhereInput
    data: XOR<VenturePublicationUpdateWithoutPublicationContentInput, VenturePublicationUncheckedUpdateWithoutPublicationContentInput>
  }

  export type VenturePublicationUpdateWithoutPublicationContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUpdateManyWithoutVenturePublicationNestedInput
    detail?: VentureDetailUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type VenturePublicationUncheckedUpdateWithoutPublicationContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detailId?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUncheckedUpdateManyWithoutVenturePublicationNestedInput
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type XUserRolesCreateWithoutRoleInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutXUserRolesInput
  }

  export type XUserRolesUncheckedCreateWithoutRoleInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type XUserRolesCreateOrConnectWithoutRoleInput = {
    where: XUserRolesWhereUniqueInput
    create: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput>
  }

  export type XUserRolesCreateManyRoleInputEnvelope = {
    data: XUserRolesCreateManyRoleInput | XUserRolesCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRolesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    picture?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    verified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    onboardingCompleted?: BoolFilter<"User"> | boolean
    userDetailId?: StringNullableFilter<"User"> | string | null
  }

  export type XUserRolesUpsertWithWhereUniqueWithoutRoleInput = {
    where: XUserRolesWhereUniqueInput
    update: XOR<XUserRolesUpdateWithoutRoleInput, XUserRolesUncheckedUpdateWithoutRoleInput>
    create: XOR<XUserRolesCreateWithoutRoleInput, XUserRolesUncheckedCreateWithoutRoleInput>
  }

  export type XUserRolesUpdateWithWhereUniqueWithoutRoleInput = {
    where: XUserRolesWhereUniqueInput
    data: XOR<XUserRolesUpdateWithoutRoleInput, XUserRolesUncheckedUpdateWithoutRoleInput>
  }

  export type XUserRolesUpdateManyWithWhereWithoutRoleInput = {
    where: XUserRolesScalarWhereInput
    data: XOR<XUserRolesUpdateManyMutationInput, XUserRolesUncheckedUpdateManyWithoutRoleInput>
  }

  export type VentureDetailCreateWithoutVentureInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event?: VentureEventCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateWithoutVentureInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event?: VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationUncheckedCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailCreateOrConnectWithoutVentureInput = {
    where: VentureDetailWhereUniqueInput
    create: XOR<VentureDetailCreateWithoutVentureInput, VentureDetailUncheckedCreateWithoutVentureInput>
  }

  export type UserCreateWithoutVenturesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVenturesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVenturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVenturesInput, UserUncheckedCreateWithoutVenturesInput>
  }

  export type VentureCategoryCreateWithoutVenturesInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutVentureCategoryInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryUncheckedCreateWithoutVenturesInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutVentureCategoryInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureCategoryInput
  }

  export type VentureCategoryCreateOrConnectWithoutVenturesInput = {
    where: VentureCategoryWhereUniqueInput
    create: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput>
  }

  export type XVentureVencureCategoryCreateWithoutVentureInput = {
    VentureCategory: VentureCategoryCreateNestedOneWithoutXVentureVencureCategoryInput
  }

  export type XVentureVencureCategoryUncheckedCreateWithoutVentureInput = {
    categoryId: string
  }

  export type XVentureVencureCategoryCreateOrConnectWithoutVentureInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    create: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput>
  }

  export type XVentureVencureCategoryCreateManyVentureInputEnvelope = {
    data: XVentureVencureCategoryCreateManyVentureInput | XVentureVencureCategoryCreateManyVentureInput[]
    skipDuplicates?: boolean
  }

  export type VentureDetailUpsertWithoutVentureInput = {
    update: XOR<VentureDetailUpdateWithoutVentureInput, VentureDetailUncheckedUpdateWithoutVentureInput>
    create: XOR<VentureDetailCreateWithoutVentureInput, VentureDetailUncheckedCreateWithoutVentureInput>
    where?: VentureDetailWhereInput
  }

  export type VentureDetailUpdateToOneWithWhereWithoutVentureInput = {
    where?: VentureDetailWhereInput
    data: XOR<VentureDetailUpdateWithoutVentureInput, VentureDetailUncheckedUpdateWithoutVentureInput>
  }

  export type VentureDetailUpdateWithoutVentureInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: VentureEventUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateWithoutVentureInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type UserUpsertWithoutVenturesInput = {
    update: XOR<UserUpdateWithoutVenturesInput, UserUncheckedUpdateWithoutVenturesInput>
    create: XOR<UserCreateWithoutVenturesInput, UserUncheckedCreateWithoutVenturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVenturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVenturesInput, UserUncheckedUpdateWithoutVenturesInput>
  }

  export type UserUpdateWithoutVenturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVenturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VentureCategoryUpsertWithWhereUniqueWithoutVenturesInput = {
    where: VentureCategoryWhereUniqueInput
    update: XOR<VentureCategoryUpdateWithoutVenturesInput, VentureCategoryUncheckedUpdateWithoutVenturesInput>
    create: XOR<VentureCategoryCreateWithoutVenturesInput, VentureCategoryUncheckedCreateWithoutVenturesInput>
  }

  export type VentureCategoryUpdateWithWhereUniqueWithoutVenturesInput = {
    where: VentureCategoryWhereUniqueInput
    data: XOR<VentureCategoryUpdateWithoutVenturesInput, VentureCategoryUncheckedUpdateWithoutVenturesInput>
  }

  export type VentureCategoryUpdateManyWithWhereWithoutVenturesInput = {
    where: VentureCategoryScalarWhereInput
    data: XOR<VentureCategoryUpdateManyMutationInput, VentureCategoryUncheckedUpdateManyWithoutVenturesInput>
  }

  export type XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    update: XOR<XVentureVencureCategoryUpdateWithoutVentureInput, XVentureVencureCategoryUncheckedUpdateWithoutVentureInput>
    create: XOR<XVentureVencureCategoryCreateWithoutVentureInput, XVentureVencureCategoryUncheckedCreateWithoutVentureInput>
  }

  export type XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    data: XOR<XVentureVencureCategoryUpdateWithoutVentureInput, XVentureVencureCategoryUncheckedUpdateWithoutVentureInput>
  }

  export type XVentureVencureCategoryUpdateManyWithWhereWithoutVentureInput = {
    where: XVentureVencureCategoryScalarWhereInput
    data: XOR<XVentureVencureCategoryUpdateManyMutationInput, XVentureVencureCategoryUncheckedUpdateManyWithoutVentureInput>
  }

  export type XVentureVencureCategoryScalarWhereInput = {
    AND?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
    OR?: XVentureVencureCategoryScalarWhereInput[]
    NOT?: XVentureVencureCategoryScalarWhereInput | XVentureVencureCategoryScalarWhereInput[]
    ventureId?: StringFilter<"XVentureVencureCategory"> | string
    categoryId?: StringFilter<"XVentureVencureCategory"> | string
  }

  export type VentureCreateWithoutXVentureVencureCategoryInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    detail: VentureDetailCreateNestedOneWithoutVentureInput
    owner: UserCreateNestedOneWithoutVenturesInput
    categories?: VentureCategoryCreateNestedManyWithoutVenturesInput
  }

  export type VentureUncheckedCreateWithoutXVentureVencureCategoryInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: VentureCategoryUncheckedCreateNestedManyWithoutVenturesInput
  }

  export type VentureCreateOrConnectWithoutXVentureVencureCategoryInput = {
    where: VentureWhereUniqueInput
    create: XOR<VentureCreateWithoutXVentureVencureCategoryInput, VentureUncheckedCreateWithoutXVentureVencureCategoryInput>
  }

  export type VentureCategoryCreateWithoutXVentureVencureCategoryInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureCreateNestedManyWithoutCategoriesInput
  }

  export type VentureCategoryUncheckedCreateWithoutXVentureVencureCategoryInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPreferencesInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutVentureCategoryInput
    ventures?: VentureUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type VentureCategoryCreateOrConnectWithoutXVentureVencureCategoryInput = {
    where: VentureCategoryWhereUniqueInput
    create: XOR<VentureCategoryCreateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedCreateWithoutXVentureVencureCategoryInput>
  }

  export type VentureUpsertWithoutXVentureVencureCategoryInput = {
    update: XOR<VentureUpdateWithoutXVentureVencureCategoryInput, VentureUncheckedUpdateWithoutXVentureVencureCategoryInput>
    create: XOR<VentureCreateWithoutXVentureVencureCategoryInput, VentureUncheckedCreateWithoutXVentureVencureCategoryInput>
    where?: VentureWhereInput
  }

  export type VentureUpdateToOneWithWhereWithoutXVentureVencureCategoryInput = {
    where?: VentureWhereInput
    data: XOR<VentureUpdateWithoutXVentureVencureCategoryInput, VentureUncheckedUpdateWithoutXVentureVencureCategoryInput>
  }

  export type VentureUpdateWithoutXVentureVencureCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: VentureDetailUpdateOneRequiredWithoutVentureNestedInput
    owner?: UserUpdateOneRequiredWithoutVenturesNestedInput
    categories?: VentureCategoryUpdateManyWithoutVenturesNestedInput
  }

  export type VentureUncheckedUpdateWithoutXVentureVencureCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: VentureCategoryUncheckedUpdateManyWithoutVenturesNestedInput
  }

  export type VentureCategoryUpsertWithoutXVentureVencureCategoryInput = {
    update: XOR<VentureCategoryUpdateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedUpdateWithoutXVentureVencureCategoryInput>
    create: XOR<VentureCategoryCreateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedCreateWithoutXVentureVencureCategoryInput>
    where?: VentureCategoryWhereInput
  }

  export type VentureCategoryUpdateToOneWithWhereWithoutXVentureVencureCategoryInput = {
    where?: VentureCategoryWhereInput
    data: XOR<VentureCategoryUpdateWithoutXVentureVencureCategoryInput, VentureCategoryUncheckedUpdateWithoutXVentureVencureCategoryInput>
  }

  export type VentureCategoryUpdateWithoutXVentureVencureCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUpdateManyWithoutCategoriesNestedInput
  }

  export type VentureCategoryUncheckedUpdateWithoutXVentureVencureCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type XUserPreferencesCreateWithoutVentureCategoryInput = {
    User: UserCreateNestedOneWithoutXUserPreferencesInput
  }

  export type XUserPreferencesUncheckedCreateWithoutVentureCategoryInput = {
    userId: string
  }

  export type XUserPreferencesCreateOrConnectWithoutVentureCategoryInput = {
    where: XUserPreferencesWhereUniqueInput
    create: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput>
  }

  export type XUserPreferencesCreateManyVentureCategoryInputEnvelope = {
    data: XUserPreferencesCreateManyVentureCategoryInput | XUserPreferencesCreateManyVentureCategoryInput[]
    skipDuplicates?: boolean
  }

  export type VentureCreateWithoutCategoriesInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    detail: VentureDetailCreateNestedOneWithoutVentureInput
    owner: UserCreateNestedOneWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureInput
  }

  export type VentureUncheckedCreateWithoutCategoriesInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureInput
  }

  export type VentureCreateOrConnectWithoutCategoriesInput = {
    where: VentureWhereUniqueInput
    create: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput>
  }

  export type XVentureVencureCategoryCreateWithoutVentureCategoryInput = {
    Venture: VentureCreateNestedOneWithoutXVentureVencureCategoryInput
  }

  export type XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput = {
    ventureId: string
  }

  export type XVentureVencureCategoryCreateOrConnectWithoutVentureCategoryInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    create: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput>
  }

  export type XVentureVencureCategoryCreateManyVentureCategoryInputEnvelope = {
    data: XVentureVencureCategoryCreateManyVentureCategoryInput | XVentureVencureCategoryCreateManyVentureCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateManyWithWhereWithoutPreferencesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPreferencesInput>
  }

  export type XUserPreferencesUpsertWithWhereUniqueWithoutVentureCategoryInput = {
    where: XUserPreferencesWhereUniqueInput
    update: XOR<XUserPreferencesUpdateWithoutVentureCategoryInput, XUserPreferencesUncheckedUpdateWithoutVentureCategoryInput>
    create: XOR<XUserPreferencesCreateWithoutVentureCategoryInput, XUserPreferencesUncheckedCreateWithoutVentureCategoryInput>
  }

  export type XUserPreferencesUpdateWithWhereUniqueWithoutVentureCategoryInput = {
    where: XUserPreferencesWhereUniqueInput
    data: XOR<XUserPreferencesUpdateWithoutVentureCategoryInput, XUserPreferencesUncheckedUpdateWithoutVentureCategoryInput>
  }

  export type XUserPreferencesUpdateManyWithWhereWithoutVentureCategoryInput = {
    where: XUserPreferencesScalarWhereInput
    data: XOR<XUserPreferencesUpdateManyMutationInput, XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryInput>
  }

  export type VentureUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: VentureWhereUniqueInput
    update: XOR<VentureUpdateWithoutCategoriesInput, VentureUncheckedUpdateWithoutCategoriesInput>
    create: XOR<VentureCreateWithoutCategoriesInput, VentureUncheckedCreateWithoutCategoriesInput>
  }

  export type VentureUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: VentureWhereUniqueInput
    data: XOR<VentureUpdateWithoutCategoriesInput, VentureUncheckedUpdateWithoutCategoriesInput>
  }

  export type VentureUpdateManyWithWhereWithoutCategoriesInput = {
    where: VentureScalarWhereInput
    data: XOR<VentureUpdateManyMutationInput, VentureUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type XVentureVencureCategoryUpsertWithWhereUniqueWithoutVentureCategoryInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    update: XOR<XVentureVencureCategoryUpdateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedUpdateWithoutVentureCategoryInput>
    create: XOR<XVentureVencureCategoryCreateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedCreateWithoutVentureCategoryInput>
  }

  export type XVentureVencureCategoryUpdateWithWhereUniqueWithoutVentureCategoryInput = {
    where: XVentureVencureCategoryWhereUniqueInput
    data: XOR<XVentureVencureCategoryUpdateWithoutVentureCategoryInput, XVentureVencureCategoryUncheckedUpdateWithoutVentureCategoryInput>
  }

  export type XVentureVencureCategoryUpdateManyWithWhereWithoutVentureCategoryInput = {
    where: XVentureVencureCategoryScalarWhereInput
    data: XOR<XVentureVencureCategoryUpdateManyMutationInput, XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryInput>
  }

  export type VentureCreateWithoutDetailInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutVenturesInput
    categories?: VentureCategoryCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryCreateNestedManyWithoutVentureInput
  }

  export type VentureUncheckedCreateWithoutDetailInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    ownerId: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: VentureCategoryUncheckedCreateNestedManyWithoutVenturesInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedCreateNestedManyWithoutVentureInput
  }

  export type VentureCreateOrConnectWithoutDetailInput = {
    where: VentureWhereUniqueInput
    create: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
  }

  export type VentureEventCreateWithoutVentureDetailInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationCreateNestedManyWithoutVentureEventInput
    Location?: LocationCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateWithoutVentureDetailInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationUncheckedCreateNestedManyWithoutVentureEventInput
    Location?: LocationUncheckedCreateNestedManyWithoutVentureEventInput
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventCreateOrConnectWithoutVentureDetailInput = {
    where: VentureEventWhereUniqueInput
    create: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureEventCreateManyVentureDetailInputEnvelope = {
    data: VentureEventCreateManyVentureDetailInput | VentureEventCreateManyVentureDetailInput[]
    skipDuplicates?: boolean
  }

  export type VenturePublicationCreateWithoutDetailInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationUncheckedCreateWithoutDetailInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationClap?: PublicationClapUncheckedCreateNestedManyWithoutVenturePublicationInput
    PublicationContent?: PublicationContentUncheckedCreateNestedManyWithoutVenturePublicationInput
  }

  export type VenturePublicationCreateOrConnectWithoutDetailInput = {
    where: VenturePublicationWhereUniqueInput
    create: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput>
  }

  export type VenturePublicationCreateManyDetailInputEnvelope = {
    data: VenturePublicationCreateManyDetailInput | VenturePublicationCreateManyDetailInput[]
    skipDuplicates?: boolean
  }

  export type VentureSponsorshipCreateWithoutVentureDetailInput = {
    id: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutVentureSponsorshipsInput
  }

  export type VentureSponsorshipUncheckedCreateWithoutVentureDetailInput = {
    id: string
    sponsorId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipCreateOrConnectWithoutVentureDetailInput = {
    where: VentureSponsorshipWhereUniqueInput
    create: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureSponsorshipCreateManyVentureDetailInputEnvelope = {
    data: VentureSponsorshipCreateManyVentureDetailInput | VentureSponsorshipCreateManyVentureDetailInput[]
    skipDuplicates?: boolean
  }

  export type VentureSubscriptionCreateWithoutVentureDetailInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutVentureSubscriptionsInput
  }

  export type VentureSubscriptionUncheckedCreateWithoutVentureDetailInput = {
    id: string
    subscriberId: string
    createdAt?: Date | string
  }

  export type VentureSubscriptionCreateOrConnectWithoutVentureDetailInput = {
    where: VentureSubscriptionWhereUniqueInput
    create: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureSubscriptionCreateManyVentureDetailInputEnvelope = {
    data: VentureSubscriptionCreateManyVentureDetailInput | VentureSubscriptionCreateManyVentureDetailInput[]
    skipDuplicates?: boolean
  }

  export type VentureUpsertWithoutDetailInput = {
    update: XOR<VentureUpdateWithoutDetailInput, VentureUncheckedUpdateWithoutDetailInput>
    create: XOR<VentureCreateWithoutDetailInput, VentureUncheckedCreateWithoutDetailInput>
    where?: VentureWhereInput
  }

  export type VentureUpdateToOneWithWhereWithoutDetailInput = {
    where?: VentureWhereInput
    data: XOR<VentureUpdateWithoutDetailInput, VentureUncheckedUpdateWithoutDetailInput>
  }

  export type VentureUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutVenturesNestedInput
    categories?: VentureCategoryUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: VentureCategoryUncheckedUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureNestedInput
  }

  export type VentureEventUpsertWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureEventWhereUniqueInput
    update: XOR<VentureEventUpdateWithoutVentureDetailInput, VentureEventUncheckedUpdateWithoutVentureDetailInput>
    create: XOR<VentureEventCreateWithoutVentureDetailInput, VentureEventUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureEventUpdateWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureEventWhereUniqueInput
    data: XOR<VentureEventUpdateWithoutVentureDetailInput, VentureEventUncheckedUpdateWithoutVentureDetailInput>
  }

  export type VentureEventUpdateManyWithWhereWithoutVentureDetailInput = {
    where: VentureEventScalarWhereInput
    data: XOR<VentureEventUpdateManyMutationInput, VentureEventUncheckedUpdateManyWithoutVentureDetailInput>
  }

  export type VenturePublicationUpsertWithWhereUniqueWithoutDetailInput = {
    where: VenturePublicationWhereUniqueInput
    update: XOR<VenturePublicationUpdateWithoutDetailInput, VenturePublicationUncheckedUpdateWithoutDetailInput>
    create: XOR<VenturePublicationCreateWithoutDetailInput, VenturePublicationUncheckedCreateWithoutDetailInput>
  }

  export type VenturePublicationUpdateWithWhereUniqueWithoutDetailInput = {
    where: VenturePublicationWhereUniqueInput
    data: XOR<VenturePublicationUpdateWithoutDetailInput, VenturePublicationUncheckedUpdateWithoutDetailInput>
  }

  export type VenturePublicationUpdateManyWithWhereWithoutDetailInput = {
    where: VenturePublicationScalarWhereInput
    data: XOR<VenturePublicationUpdateManyMutationInput, VenturePublicationUncheckedUpdateManyWithoutDetailInput>
  }

  export type VenturePublicationScalarWhereInput = {
    AND?: VenturePublicationScalarWhereInput | VenturePublicationScalarWhereInput[]
    OR?: VenturePublicationScalarWhereInput[]
    NOT?: VenturePublicationScalarWhereInput | VenturePublicationScalarWhereInput[]
    id?: StringFilter<"VenturePublication"> | string
    description?: StringFilter<"VenturePublication"> | string
    detailId?: StringFilter<"VenturePublication"> | string
    type?: EnumPublicationTypeFilter<"VenturePublication"> | $Enums.PublicationType
    clapsCount?: IntFilter<"VenturePublication"> | number
    createdAt?: DateTimeFilter<"VenturePublication"> | Date | string
    updatedAt?: DateTimeFilter<"VenturePublication"> | Date | string
  }

  export type VentureSponsorshipUpsertWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureSponsorshipWhereUniqueInput
    update: XOR<VentureSponsorshipUpdateWithoutVentureDetailInput, VentureSponsorshipUncheckedUpdateWithoutVentureDetailInput>
    create: XOR<VentureSponsorshipCreateWithoutVentureDetailInput, VentureSponsorshipUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureSponsorshipUpdateWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureSponsorshipWhereUniqueInput
    data: XOR<VentureSponsorshipUpdateWithoutVentureDetailInput, VentureSponsorshipUncheckedUpdateWithoutVentureDetailInput>
  }

  export type VentureSponsorshipUpdateManyWithWhereWithoutVentureDetailInput = {
    where: VentureSponsorshipScalarWhereInput
    data: XOR<VentureSponsorshipUpdateManyMutationInput, VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailInput>
  }

  export type VentureSubscriptionUpsertWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureSubscriptionWhereUniqueInput
    update: XOR<VentureSubscriptionUpdateWithoutVentureDetailInput, VentureSubscriptionUncheckedUpdateWithoutVentureDetailInput>
    create: XOR<VentureSubscriptionCreateWithoutVentureDetailInput, VentureSubscriptionUncheckedCreateWithoutVentureDetailInput>
  }

  export type VentureSubscriptionUpdateWithWhereUniqueWithoutVentureDetailInput = {
    where: VentureSubscriptionWhereUniqueInput
    data: XOR<VentureSubscriptionUpdateWithoutVentureDetailInput, VentureSubscriptionUncheckedUpdateWithoutVentureDetailInput>
  }

  export type VentureSubscriptionUpdateManyWithWhereWithoutVentureDetailInput = {
    where: VentureSubscriptionScalarWhereInput
    data: XOR<VentureSubscriptionUpdateManyMutationInput, VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailInput>
  }

  export type EventDonationCreateWithoutVentureEventInput = {
    id?: string
    amount: number
    currency: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutEventDonationsInput
  }

  export type EventDonationUncheckedCreateWithoutVentureEventInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type EventDonationCreateOrConnectWithoutVentureEventInput = {
    where: EventDonationWhereUniqueInput
    create: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput>
  }

  export type EventDonationCreateManyVentureEventInputEnvelope = {
    data: EventDonationCreateManyVentureEventInput | EventDonationCreateManyVentureEventInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutVentureEventInput = {
    id?: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUncheckedCreateWithoutVentureEventInput = {
    id?: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutVentureEventInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput>
  }

  export type LocationCreateManyVentureEventInputEnvelope = {
    data: LocationCreateManyVentureEventInput | LocationCreateManyVentureEventInput[]
    skipDuplicates?: boolean
  }

  export type VentureDetailCreateWithoutEventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureCreateNestedOneWithoutDetailInput
    publications?: VenturePublicationCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateWithoutEventInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureUncheckedCreateNestedOneWithoutDetailInput
    publications?: VenturePublicationUncheckedCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailCreateOrConnectWithoutEventInput = {
    where: VentureDetailWhereUniqueInput
    create: XOR<VentureDetailCreateWithoutEventInput, VentureDetailUncheckedCreateWithoutEventInput>
  }

  export type XEventCategoryCreateWithoutVentureEventInput = {
    EventCategory: EventCategoryCreateNestedOneWithoutXEventCategoryInput
  }

  export type XEventCategoryUncheckedCreateWithoutVentureEventInput = {
    categoryId: string
  }

  export type XEventCategoryCreateOrConnectWithoutVentureEventInput = {
    where: XEventCategoryWhereUniqueInput
    create: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput>
  }

  export type XEventCategoryCreateManyVentureEventInputEnvelope = {
    data: XEventCategoryCreateManyVentureEventInput | XEventCategoryCreateManyVentureEventInput[]
    skipDuplicates?: boolean
  }

  export type EventCategoryCreateWithoutVentureEventInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XEventCategory?: XEventCategoryCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutVentureEventInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    XEventCategory?: XEventCategoryUncheckedCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutVentureEventInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput>
  }

  export type EventDonationUpsertWithWhereUniqueWithoutVentureEventInput = {
    where: EventDonationWhereUniqueInput
    update: XOR<EventDonationUpdateWithoutVentureEventInput, EventDonationUncheckedUpdateWithoutVentureEventInput>
    create: XOR<EventDonationCreateWithoutVentureEventInput, EventDonationUncheckedCreateWithoutVentureEventInput>
  }

  export type EventDonationUpdateWithWhereUniqueWithoutVentureEventInput = {
    where: EventDonationWhereUniqueInput
    data: XOR<EventDonationUpdateWithoutVentureEventInput, EventDonationUncheckedUpdateWithoutVentureEventInput>
  }

  export type EventDonationUpdateManyWithWhereWithoutVentureEventInput = {
    where: EventDonationScalarWhereInput
    data: XOR<EventDonationUpdateManyMutationInput, EventDonationUncheckedUpdateManyWithoutVentureEventInput>
  }

  export type LocationUpsertWithWhereUniqueWithoutVentureEventInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutVentureEventInput, LocationUncheckedUpdateWithoutVentureEventInput>
    create: XOR<LocationCreateWithoutVentureEventInput, LocationUncheckedCreateWithoutVentureEventInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutVentureEventInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutVentureEventInput, LocationUncheckedUpdateWithoutVentureEventInput>
  }

  export type LocationUpdateManyWithWhereWithoutVentureEventInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutVentureEventInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    ventureEventId?: StringFilter<"Location"> | string
    lat?: FloatNullableFilter<"Location"> | number | null
    lng?: FloatNullableFilter<"Location"> | number | null
    description?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type VentureDetailUpsertWithoutEventInput = {
    update: XOR<VentureDetailUpdateWithoutEventInput, VentureDetailUncheckedUpdateWithoutEventInput>
    create: XOR<VentureDetailCreateWithoutEventInput, VentureDetailUncheckedCreateWithoutEventInput>
    where?: VentureDetailWhereInput
  }

  export type VentureDetailUpdateToOneWithWhereWithoutEventInput = {
    where?: VentureDetailWhereInput
    data: XOR<VentureDetailUpdateWithoutEventInput, VentureDetailUncheckedUpdateWithoutEventInput>
  }

  export type VentureDetailUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUpdateOneWithoutDetailNestedInput
    publications?: VenturePublicationUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUncheckedUpdateOneWithoutDetailNestedInput
    publications?: VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type XEventCategoryUpsertWithWhereUniqueWithoutVentureEventInput = {
    where: XEventCategoryWhereUniqueInput
    update: XOR<XEventCategoryUpdateWithoutVentureEventInput, XEventCategoryUncheckedUpdateWithoutVentureEventInput>
    create: XOR<XEventCategoryCreateWithoutVentureEventInput, XEventCategoryUncheckedCreateWithoutVentureEventInput>
  }

  export type XEventCategoryUpdateWithWhereUniqueWithoutVentureEventInput = {
    where: XEventCategoryWhereUniqueInput
    data: XOR<XEventCategoryUpdateWithoutVentureEventInput, XEventCategoryUncheckedUpdateWithoutVentureEventInput>
  }

  export type XEventCategoryUpdateManyWithWhereWithoutVentureEventInput = {
    where: XEventCategoryScalarWhereInput
    data: XOR<XEventCategoryUpdateManyMutationInput, XEventCategoryUncheckedUpdateManyWithoutVentureEventInput>
  }

  export type EventCategoryUpsertWithWhereUniqueWithoutVentureEventInput = {
    where: EventCategoryWhereUniqueInput
    update: XOR<EventCategoryUpdateWithoutVentureEventInput, EventCategoryUncheckedUpdateWithoutVentureEventInput>
    create: XOR<EventCategoryCreateWithoutVentureEventInput, EventCategoryUncheckedCreateWithoutVentureEventInput>
  }

  export type EventCategoryUpdateWithWhereUniqueWithoutVentureEventInput = {
    where: EventCategoryWhereUniqueInput
    data: XOR<EventCategoryUpdateWithoutVentureEventInput, EventCategoryUncheckedUpdateWithoutVentureEventInput>
  }

  export type EventCategoryUpdateManyWithWhereWithoutVentureEventInput = {
    where: EventCategoryScalarWhereInput
    data: XOR<EventCategoryUpdateManyMutationInput, EventCategoryUncheckedUpdateManyWithoutVentureEventInput>
  }

  export type EventCategoryScalarWhereInput = {
    AND?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
    OR?: EventCategoryScalarWhereInput[]
    NOT?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
    id?: StringFilter<"EventCategory"> | string
    name?: StringFilter<"EventCategory"> | string
    slug?: StringFilter<"EventCategory"> | string
    description?: StringFilter<"EventCategory"> | string
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
    updatedAt?: DateTimeFilter<"EventCategory"> | Date | string
  }

  export type CommentCreateWithoutVenturePublicationInput = {
    id?: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutVenturePublicationInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutVenturePublicationInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput>
  }

  export type CommentCreateManyVenturePublicationInputEnvelope = {
    data: CommentCreateManyVenturePublicationInput | CommentCreateManyVenturePublicationInput[]
    skipDuplicates?: boolean
  }

  export type PublicationClapCreateWithoutVenturePublicationInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutPublicationClapsInput
  }

  export type PublicationClapUncheckedCreateWithoutVenturePublicationInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type PublicationClapCreateOrConnectWithoutVenturePublicationInput = {
    where: PublicationClapWhereUniqueInput
    create: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput>
  }

  export type PublicationClapCreateManyVenturePublicationInputEnvelope = {
    data: PublicationClapCreateManyVenturePublicationInput | PublicationClapCreateManyVenturePublicationInput[]
    skipDuplicates?: boolean
  }

  export type PublicationContentCreateWithoutVenturePublicationInput = {
    id: string
    type: $Enums.ContentType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationContentUncheckedCreateWithoutVenturePublicationInput = {
    id: string
    type: $Enums.ContentType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationContentCreateOrConnectWithoutVenturePublicationInput = {
    where: PublicationContentWhereUniqueInput
    create: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput>
  }

  export type PublicationContentCreateManyVenturePublicationInputEnvelope = {
    data: PublicationContentCreateManyVenturePublicationInput | PublicationContentCreateManyVenturePublicationInput[]
    skipDuplicates?: boolean
  }

  export type VentureDetailCreateWithoutPublicationsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureCreateNestedOneWithoutDetailInput
    event?: VentureEventCreateNestedManyWithoutVentureDetailInput
    sponsorship?: VentureSponsorshipCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateWithoutPublicationsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureUncheckedCreateNestedOneWithoutDetailInput
    event?: VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput
    sponsorship?: VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput
    subscription?: VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailCreateOrConnectWithoutPublicationsInput = {
    where: VentureDetailWhereUniqueInput
    create: XOR<VentureDetailCreateWithoutPublicationsInput, VentureDetailUncheckedCreateWithoutPublicationsInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutVenturePublicationInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutVenturePublicationInput, CommentUncheckedUpdateWithoutVenturePublicationInput>
    create: XOR<CommentCreateWithoutVenturePublicationInput, CommentUncheckedCreateWithoutVenturePublicationInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutVenturePublicationInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutVenturePublicationInput, CommentUncheckedUpdateWithoutVenturePublicationInput>
  }

  export type CommentUpdateManyWithWhereWithoutVenturePublicationInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutVenturePublicationInput>
  }

  export type PublicationClapUpsertWithWhereUniqueWithoutVenturePublicationInput = {
    where: PublicationClapWhereUniqueInput
    update: XOR<PublicationClapUpdateWithoutVenturePublicationInput, PublicationClapUncheckedUpdateWithoutVenturePublicationInput>
    create: XOR<PublicationClapCreateWithoutVenturePublicationInput, PublicationClapUncheckedCreateWithoutVenturePublicationInput>
  }

  export type PublicationClapUpdateWithWhereUniqueWithoutVenturePublicationInput = {
    where: PublicationClapWhereUniqueInput
    data: XOR<PublicationClapUpdateWithoutVenturePublicationInput, PublicationClapUncheckedUpdateWithoutVenturePublicationInput>
  }

  export type PublicationClapUpdateManyWithWhereWithoutVenturePublicationInput = {
    where: PublicationClapScalarWhereInput
    data: XOR<PublicationClapUpdateManyMutationInput, PublicationClapUncheckedUpdateManyWithoutVenturePublicationInput>
  }

  export type PublicationContentUpsertWithWhereUniqueWithoutVenturePublicationInput = {
    where: PublicationContentWhereUniqueInput
    update: XOR<PublicationContentUpdateWithoutVenturePublicationInput, PublicationContentUncheckedUpdateWithoutVenturePublicationInput>
    create: XOR<PublicationContentCreateWithoutVenturePublicationInput, PublicationContentUncheckedCreateWithoutVenturePublicationInput>
  }

  export type PublicationContentUpdateWithWhereUniqueWithoutVenturePublicationInput = {
    where: PublicationContentWhereUniqueInput
    data: XOR<PublicationContentUpdateWithoutVenturePublicationInput, PublicationContentUncheckedUpdateWithoutVenturePublicationInput>
  }

  export type PublicationContentUpdateManyWithWhereWithoutVenturePublicationInput = {
    where: PublicationContentScalarWhereInput
    data: XOR<PublicationContentUpdateManyMutationInput, PublicationContentUncheckedUpdateManyWithoutVenturePublicationInput>
  }

  export type PublicationContentScalarWhereInput = {
    AND?: PublicationContentScalarWhereInput | PublicationContentScalarWhereInput[]
    OR?: PublicationContentScalarWhereInput[]
    NOT?: PublicationContentScalarWhereInput | PublicationContentScalarWhereInput[]
    id?: StringFilter<"PublicationContent"> | string
    type?: EnumContentTypeFilter<"PublicationContent"> | $Enums.ContentType
    content?: StringFilter<"PublicationContent"> | string
    publicationId?: StringFilter<"PublicationContent"> | string
    createdAt?: DateTimeFilter<"PublicationContent"> | Date | string
    updatedAt?: DateTimeFilter<"PublicationContent"> | Date | string
  }

  export type VentureDetailUpsertWithoutPublicationsInput = {
    update: XOR<VentureDetailUpdateWithoutPublicationsInput, VentureDetailUncheckedUpdateWithoutPublicationsInput>
    create: XOR<VentureDetailCreateWithoutPublicationsInput, VentureDetailUncheckedCreateWithoutPublicationsInput>
    where?: VentureDetailWhereInput
  }

  export type VentureDetailUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: VentureDetailWhereInput
    data: XOR<VentureDetailUpdateWithoutPublicationsInput, VentureDetailUncheckedUpdateWithoutPublicationsInput>
  }

  export type VentureDetailUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUpdateOneWithoutDetailNestedInput
    event?: VentureEventUpdateManyWithoutVentureDetailNestedInput
    sponsorship?: VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUncheckedUpdateOneWithoutDetailNestedInput
    event?: VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput
    sponsorship?: VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput
    subscription?: VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type UserCreateWithoutVentureSponsorshipsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVentureSponsorshipsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVentureSponsorshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVentureSponsorshipsInput, UserUncheckedCreateWithoutVentureSponsorshipsInput>
  }

  export type VentureDetailCreateWithoutSponsorshipInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureCreateNestedOneWithoutDetailInput
    event?: VentureEventCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationCreateNestedManyWithoutDetailInput
    subscription?: VentureSubscriptionCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateWithoutSponsorshipInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureUncheckedCreateNestedOneWithoutDetailInput
    event?: VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationUncheckedCreateNestedManyWithoutDetailInput
    subscription?: VentureSubscriptionUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailCreateOrConnectWithoutSponsorshipInput = {
    where: VentureDetailWhereUniqueInput
    create: XOR<VentureDetailCreateWithoutSponsorshipInput, VentureDetailUncheckedCreateWithoutSponsorshipInput>
  }

  export type UserUpsertWithoutVentureSponsorshipsInput = {
    update: XOR<UserUpdateWithoutVentureSponsorshipsInput, UserUncheckedUpdateWithoutVentureSponsorshipsInput>
    create: XOR<UserCreateWithoutVentureSponsorshipsInput, UserUncheckedCreateWithoutVentureSponsorshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVentureSponsorshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVentureSponsorshipsInput, UserUncheckedUpdateWithoutVentureSponsorshipsInput>
  }

  export type UserUpdateWithoutVentureSponsorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVentureSponsorshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VentureDetailUpsertWithoutSponsorshipInput = {
    update: XOR<VentureDetailUpdateWithoutSponsorshipInput, VentureDetailUncheckedUpdateWithoutSponsorshipInput>
    create: XOR<VentureDetailCreateWithoutSponsorshipInput, VentureDetailUncheckedCreateWithoutSponsorshipInput>
    where?: VentureDetailWhereInput
  }

  export type VentureDetailUpdateToOneWithWhereWithoutSponsorshipInput = {
    where?: VentureDetailWhereInput
    data: XOR<VentureDetailUpdateWithoutSponsorshipInput, VentureDetailUncheckedUpdateWithoutSponsorshipInput>
  }

  export type VentureDetailUpdateWithoutSponsorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUpdateOneWithoutDetailNestedInput
    event?: VentureEventUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUpdateManyWithoutDetailNestedInput
    subscription?: VentureSubscriptionUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateWithoutSponsorshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUncheckedUpdateOneWithoutDetailNestedInput
    event?: VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput
    subscription?: VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type UserCreateWithoutVentureSubscriptionsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    XUserRoles?: XUserRolesCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVentureSubscriptionsInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    XUserRoles?: XUserRolesUncheckedCreateNestedManyWithoutUserInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVentureSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVentureSubscriptionsInput, UserUncheckedCreateWithoutVentureSubscriptionsInput>
  }

  export type VentureDetailCreateWithoutSubscriptionInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureCreateNestedOneWithoutDetailInput
    event?: VentureEventCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailUncheckedCreateWithoutSubscriptionInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Venture?: VentureUncheckedCreateNestedOneWithoutDetailInput
    event?: VentureEventUncheckedCreateNestedManyWithoutVentureDetailInput
    publications?: VenturePublicationUncheckedCreateNestedManyWithoutDetailInput
    sponsorship?: VentureSponsorshipUncheckedCreateNestedManyWithoutVentureDetailInput
  }

  export type VentureDetailCreateOrConnectWithoutSubscriptionInput = {
    where: VentureDetailWhereUniqueInput
    create: XOR<VentureDetailCreateWithoutSubscriptionInput, VentureDetailUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutVentureSubscriptionsInput = {
    update: XOR<UserUpdateWithoutVentureSubscriptionsInput, UserUncheckedUpdateWithoutVentureSubscriptionsInput>
    create: XOR<UserCreateWithoutVentureSubscriptionsInput, UserUncheckedCreateWithoutVentureSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVentureSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVentureSubscriptionsInput, UserUncheckedUpdateWithoutVentureSubscriptionsInput>
  }

  export type UserUpdateWithoutVentureSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVentureSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VentureDetailUpsertWithoutSubscriptionInput = {
    update: XOR<VentureDetailUpdateWithoutSubscriptionInput, VentureDetailUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<VentureDetailCreateWithoutSubscriptionInput, VentureDetailUncheckedCreateWithoutSubscriptionInput>
    where?: VentureDetailWhereInput
  }

  export type VentureDetailUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: VentureDetailWhereInput
    data: XOR<VentureDetailUpdateWithoutSubscriptionInput, VentureDetailUncheckedUpdateWithoutSubscriptionInput>
  }

  export type VentureDetailUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUpdateOneWithoutDetailNestedInput
    event?: VentureEventUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUpdateManyWithoutVentureDetailNestedInput
  }

  export type VentureDetailUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venture?: VentureUncheckedUpdateOneWithoutDetailNestedInput
    event?: VentureEventUncheckedUpdateManyWithoutVentureDetailNestedInput
    publications?: VenturePublicationUncheckedUpdateManyWithoutDetailNestedInput
    sponsorship?: VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailNestedInput
  }

  export type EventCategoryCreateWithoutXEventCategoryInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    VentureEvent?: VentureEventCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutXEventCategoryInput = {
    id?: string
    name: string
    slug: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    VentureEvent?: VentureEventUncheckedCreateNestedManyWithoutEventCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutXEventCategoryInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutXEventCategoryInput, EventCategoryUncheckedCreateWithoutXEventCategoryInput>
  }

  export type VentureEventCreateWithoutXEventCategoryInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationCreateNestedManyWithoutVentureEventInput
    Location?: LocationCreateNestedManyWithoutVentureEventInput
    VentureDetail: VentureDetailCreateNestedOneWithoutEventInput
    EventCategory?: EventCategoryCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventUncheckedCreateWithoutXEventCategoryInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    ventureId: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    EventDonation?: EventDonationUncheckedCreateNestedManyWithoutVentureEventInput
    Location?: LocationUncheckedCreateNestedManyWithoutVentureEventInput
    EventCategory?: EventCategoryUncheckedCreateNestedManyWithoutVentureEventInput
  }

  export type VentureEventCreateOrConnectWithoutXEventCategoryInput = {
    where: VentureEventWhereUniqueInput
    create: XOR<VentureEventCreateWithoutXEventCategoryInput, VentureEventUncheckedCreateWithoutXEventCategoryInput>
  }

  export type EventCategoryUpsertWithoutXEventCategoryInput = {
    update: XOR<EventCategoryUpdateWithoutXEventCategoryInput, EventCategoryUncheckedUpdateWithoutXEventCategoryInput>
    create: XOR<EventCategoryCreateWithoutXEventCategoryInput, EventCategoryUncheckedCreateWithoutXEventCategoryInput>
    where?: EventCategoryWhereInput
  }

  export type EventCategoryUpdateToOneWithWhereWithoutXEventCategoryInput = {
    where?: EventCategoryWhereInput
    data: XOR<EventCategoryUpdateWithoutXEventCategoryInput, EventCategoryUncheckedUpdateWithoutXEventCategoryInput>
  }

  export type EventCategoryUpdateWithoutXEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureEvent?: VentureEventUpdateManyWithoutEventCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutXEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureEvent?: VentureEventUncheckedUpdateManyWithoutEventCategoryNestedInput
  }

  export type VentureEventUpsertWithoutXEventCategoryInput = {
    update: XOR<VentureEventUpdateWithoutXEventCategoryInput, VentureEventUncheckedUpdateWithoutXEventCategoryInput>
    create: XOR<VentureEventCreateWithoutXEventCategoryInput, VentureEventUncheckedCreateWithoutXEventCategoryInput>
    where?: VentureEventWhereInput
  }

  export type VentureEventUpdateToOneWithWhereWithoutXEventCategoryInput = {
    where?: VentureEventWhereInput
    data: XOR<VentureEventUpdateWithoutXEventCategoryInput, VentureEventUncheckedUpdateWithoutXEventCategoryInput>
  }

  export type VentureEventUpdateWithoutXEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUpdateManyWithoutVentureEventNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutEventNestedInput
    EventCategory?: EventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateWithoutXEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUncheckedUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type RoleCreateWithoutXUserRolesInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutXUserRolesInput = {
    id: string
    name: $Enums.AppRole
    label?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutXUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutXUserRolesInput, RoleUncheckedCreateWithoutXUserRolesInput>
  }

  export type UserCreateWithoutXUserRolesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    comments?: CommentCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapCreateNestedManyWithoutUserInput
    ventures?: VentureCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    detail?: UserDetailCreateNestedOneWithoutUserInput
    preferences?: VentureCategoryCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutXUserRolesInput = {
    id?: string
    picture: string
    email: string
    firstName: string
    lastName: string
    active?: boolean
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingCompleted?: boolean
    userDetailId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    eventDonations?: EventDonationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publicationClaps?: PublicationClapUncheckedCreateNestedManyWithoutUserInput
    ventures?: VentureUncheckedCreateNestedManyWithoutOwnerInput
    ventureSponsorships?: VentureSponsorshipUncheckedCreateNestedManyWithoutUserInput
    ventureSubscriptions?: VentureSubscriptionUncheckedCreateNestedManyWithoutUserInput
    roles?: RoleUncheckedCreateNestedManyWithoutUsersInput
    preferences?: VentureCategoryUncheckedCreateNestedManyWithoutUsersInput
    XUserPreferences?: XUserPreferencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutXUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXUserRolesInput, UserUncheckedCreateWithoutXUserRolesInput>
  }

  export type RoleUpsertWithoutXUserRolesInput = {
    update: XOR<RoleUpdateWithoutXUserRolesInput, RoleUncheckedUpdateWithoutXUserRolesInput>
    create: XOR<RoleCreateWithoutXUserRolesInput, RoleUncheckedCreateWithoutXUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutXUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutXUserRolesInput, RoleUncheckedUpdateWithoutXUserRolesInput>
  }

  export type RoleUpdateWithoutXUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutXUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type UserUpsertWithoutXUserRolesInput = {
    update: XOR<UserUpdateWithoutXUserRolesInput, UserUncheckedUpdateWithoutXUserRolesInput>
    create: XOR<UserCreateWithoutXUserRolesInput, UserUncheckedCreateWithoutXUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXUserRolesInput, UserUncheckedUpdateWithoutXUserRolesInput>
  }

  export type UserUpdateWithoutXUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutXUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateManyUserInput = {
    id?: string
    publicationId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventDonationCreateManyUserInput = {
    id?: string
    eventId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationClapCreateManyUserInput = {
    id: string
    publicationId: string
    createdAt?: Date | string
  }

  export type VentureCreateManyOwnerInput = {
    id: string
    name: string
    slug: string
    coverPhoto: string
    description: string
    active?: boolean
    verified?: boolean
    detailId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipCreateManyUserInput = {
    id: string
    ventureDetailId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSubscriptionCreateManyUserInput = {
    id: string
    ventureId: string
    createdAt?: Date | string
  }

  export type XUserRolesCreateManyUserInput = {
    id: string
    roleId: string
    createdAt?: Date | string
  }

  export type XUserPreferencesCreateManyUserInput = {
    categoryId: string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VenturePublication?: VenturePublicationUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureEvent?: VentureEventUpdateOneRequiredWithoutEventDonationNestedInput
  }

  export type EventDonationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VenturePublication?: VenturePublicationUpdateOneRequiredWithoutPublicationClapNestedInput
  }

  export type PublicationClapUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: VentureDetailUpdateOneRequiredWithoutVentureNestedInput
    categories?: VentureCategoryUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: VentureCategoryUncheckedUpdateManyWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutSponsorshipNestedInput
  }

  export type VentureSponsorshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureDetailId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureDetailId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type VentureSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XUserRoles?: XUserRolesUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutXUserRolesNestedInput
  }

  export type XUserRolesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureCategoryUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XUserPreferences?: XUserPreferencesUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutCategoriesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserPreferencesUpdateWithoutUserInput = {
    VentureCategory?: VentureCategoryUpdateOneRequiredWithoutXUserPreferencesNestedInput
  }

  export type XUserPreferencesUncheckedUpdateWithoutUserInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XUserPreferencesUncheckedUpdateManyWithoutUserInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityCreateManyDepartmentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MunicipalityUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDetail?: UserDetailUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserDetail?: UserDetailUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDetailCreateManyMunicipalityInput = {
    id?: string
    gender: string
    birthDate: Date | string
  }

  export type UserDetailUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDetailNestedInput
  }

  export type UserDetailUncheckedUpdateWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutDetailNestedInput
  }

  export type UserDetailUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XEventCategoryCreateManyEventCategoryInput = {
    eventId: string
  }

  export type XEventCategoryUpdateWithoutEventCategoryInput = {
    VentureEvent?: VentureEventUpdateOneRequiredWithoutXEventCategoryNestedInput
  }

  export type XEventCategoryUncheckedUpdateWithoutEventCategoryInput = {
    eventId?: StringFieldUpdateOperationsInput | string
  }

  export type XEventCategoryUncheckedUpdateManyWithoutEventCategoryInput = {
    eventId?: StringFieldUpdateOperationsInput | string
  }

  export type VentureEventUpdateWithoutEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUpdateManyWithoutVentureEventNestedInput
    VentureDetail?: VentureDetailUpdateOneRequiredWithoutEventNestedInput
    XEventCategory?: XEventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateWithoutEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUncheckedUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateManyWithoutEventCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    ventureId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesCreateManyRoleInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    preferences?: VentureCategoryUncheckedUpdateManyWithoutUsersNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type XUserRolesUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutXUserRolesNestedInput
  }

  export type XUserRolesUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XUserRolesUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XVentureVencureCategoryCreateManyVentureInput = {
    categoryId: string
  }

  export type VentureCategoryUpdateWithoutVenturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutVentureCategoryNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateWithoutVenturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPreferencesNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryNestedInput
  }

  export type VentureCategoryUncheckedUpdateManyWithoutVenturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XVentureVencureCategoryUpdateWithoutVentureInput = {
    VentureCategory?: VentureCategoryUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput
  }

  export type XVentureVencureCategoryUncheckedUpdateWithoutVentureInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XVentureVencureCategoryUncheckedUpdateManyWithoutVentureInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XUserPreferencesCreateManyVentureCategoryInput = {
    userId: string
  }

  export type XVentureVencureCategoryCreateManyVentureCategoryInput = {
    ventureId: string
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUpdateManyWithoutUserNestedInput
    ventures?: VentureUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUpdateManyWithoutUserNestedInput
    roles?: RoleUpdateManyWithoutUsersNestedInput
    detail?: UserDetailUpdateOneWithoutUserNestedInput
    XUserRoles?: XUserRolesUpdateManyWithoutUserNestedInput
    XUserPreferences?: XUserPreferencesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    eventDonations?: EventDonationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publicationClaps?: PublicationClapUncheckedUpdateManyWithoutUserNestedInput
    ventures?: VentureUncheckedUpdateManyWithoutOwnerNestedInput
    ventureSponsorships?: VentureSponsorshipUncheckedUpdateManyWithoutUserNestedInput
    ventureSubscriptions?: VentureSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    roles?: RoleUncheckedUpdateManyWithoutUsersNestedInput
    XUserRoles?: XUserRolesUncheckedUpdateManyWithoutUserNestedInput
    XUserPreferences?: XUserPreferencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    userDetailId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type XUserPreferencesUpdateWithoutVentureCategoryInput = {
    User?: UserUpdateOneRequiredWithoutXUserPreferencesNestedInput
  }

  export type XUserPreferencesUncheckedUpdateWithoutVentureCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type XUserPreferencesUncheckedUpdateManyWithoutVentureCategoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VentureUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: VentureDetailUpdateOneRequiredWithoutVentureNestedInput
    owner?: UserUpdateOneRequiredWithoutVenturesNestedInput
    XVentureVencureCategory?: XVentureVencureCategoryUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XVentureVencureCategory?: XVentureVencureCategoryUncheckedUpdateManyWithoutVentureNestedInput
  }

  export type VentureUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verified?: BoolFieldUpdateOperationsInput | boolean
    detailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XVentureVencureCategoryUpdateWithoutVentureCategoryInput = {
    Venture?: VentureUpdateOneRequiredWithoutXVentureVencureCategoryNestedInput
  }

  export type XVentureVencureCategoryUncheckedUpdateWithoutVentureCategoryInput = {
    ventureId?: StringFieldUpdateOperationsInput | string
  }

  export type XVentureVencureCategoryUncheckedUpdateManyWithoutVentureCategoryInput = {
    ventureId?: StringFieldUpdateOperationsInput | string
  }

  export type VentureEventCreateManyVentureDetailInput = {
    id: string
    title: string
    description: string
    coverPhoto: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenturePublicationCreateManyDetailInput = {
    id: string
    description: string
    type: $Enums.PublicationType
    clapsCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSponsorshipCreateManyVentureDetailInput = {
    id: string
    sponsorId: string
    monthlyAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VentureSubscriptionCreateManyVentureDetailInput = {
    id: string
    subscriberId: string
    createdAt?: Date | string
  }

  export type VentureEventUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventDonation?: EventDonationUncheckedUpdateManyWithoutVentureEventNestedInput
    Location?: LocationUncheckedUpdateManyWithoutVentureEventNestedInput
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
    EventCategory?: EventCategoryUncheckedUpdateManyWithoutVentureEventNestedInput
  }

  export type VentureEventUncheckedUpdateManyWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverPhoto?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenturePublicationUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUpdateManyWithoutVenturePublicationNestedInput
  }

  export type VenturePublicationUncheckedUpdateWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationClap?: PublicationClapUncheckedUpdateManyWithoutVenturePublicationNestedInput
    PublicationContent?: PublicationContentUncheckedUpdateManyWithoutVenturePublicationNestedInput
  }

  export type VenturePublicationUncheckedUpdateManyWithoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPublicationTypeFieldUpdateOperationsInput | $Enums.PublicationType
    clapsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutVentureSponsorshipsNestedInput
  }

  export type VentureSponsorshipUncheckedUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    sponsorId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSponsorshipUncheckedUpdateManyWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    sponsorId?: StringFieldUpdateOperationsInput | string
    monthlyAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutVentureSubscriptionsNestedInput
  }

  export type VentureSubscriptionUncheckedUpdateWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VentureSubscriptionUncheckedUpdateManyWithoutVentureDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationCreateManyVentureEventInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    createdAt?: Date | string
  }

  export type LocationCreateManyVentureEventInput = {
    id?: string
    lat?: number | null
    lng?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XEventCategoryCreateManyVentureEventInput = {
    categoryId: string
  }

  export type EventDonationUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEventDonationsNestedInput
  }

  export type EventDonationUncheckedUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventDonationUncheckedUpdateManyWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XEventCategoryUpdateWithoutVentureEventInput = {
    EventCategory?: EventCategoryUpdateOneRequiredWithoutXEventCategoryNestedInput
  }

  export type XEventCategoryUncheckedUpdateWithoutVentureEventInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type XEventCategoryUncheckedUpdateManyWithoutVentureEventInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type EventCategoryUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XEventCategory?: XEventCategoryUpdateManyWithoutEventCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    XEventCategory?: XEventCategoryUncheckedUpdateManyWithoutEventCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateManyWithoutVentureEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyVenturePublicationInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationClapCreateManyVenturePublicationInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type PublicationContentCreateManyVenturePublicationInput = {
    id: string
    type: $Enums.ContentType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPublicationClapsNestedInput
  }

  export type PublicationClapUncheckedUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationClapUncheckedUpdateManyWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentUncheckedUpdateWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationContentUncheckedUpdateManyWithoutVenturePublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipalityCountOutputTypeDefaultArgs instead
     */
    export type MunicipalityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryCountOutputTypeDefaultArgs instead
     */
    export type EventCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureCountOutputTypeDefaultArgs instead
     */
    export type VentureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureCategoryCountOutputTypeDefaultArgs instead
     */
    export type VentureCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureDetailCountOutputTypeDefaultArgs instead
     */
    export type VentureDetailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureDetailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureEventCountOutputTypeDefaultArgs instead
     */
    export type VentureEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenturePublicationCountOutputTypeDefaultArgs instead
     */
    export type VenturePublicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenturePublicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XUserPreferencesDefaultArgs instead
     */
    export type XUserPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XUserPreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDetailDefaultArgs instead
     */
    export type UserDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipalityDefaultArgs instead
     */
    export type MunicipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipalityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryDefaultArgs instead
     */
    export type EventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDonationDefaultArgs instead
     */
    export type EventDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDonationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationClapDefaultArgs instead
     */
    export type PublicationClapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationClapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationContentDefaultArgs instead
     */
    export type PublicationContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureDefaultArgs instead
     */
    export type VentureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XVentureVencureCategoryDefaultArgs instead
     */
    export type XVentureVencureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XVentureVencureCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureCategoryDefaultArgs instead
     */
    export type VentureCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureDetailDefaultArgs instead
     */
    export type VentureDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureEventDefaultArgs instead
     */
    export type VentureEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenturePublicationDefaultArgs instead
     */
    export type VenturePublicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenturePublicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureSponsorshipDefaultArgs instead
     */
    export type VentureSponsorshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureSponsorshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VentureSubscriptionDefaultArgs instead
     */
    export type VentureSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VentureSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XEventCategoryDefaultArgs instead
     */
    export type XEventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XEventCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XUserRolesDefaultArgs instead
     */
    export type XUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XUserRolesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}